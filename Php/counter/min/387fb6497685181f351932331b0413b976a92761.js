/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var document = window.document;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var
        version = "2.2.4",
        jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context);
        },
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        fcamelCase = function(all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
        },
        isPlainObject: function(obj) {
            var key;
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
                return false;
            }
            for (key in obj) {}
            return key === undefined || hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0,
                ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length,
            type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
    }
    var Sizzle =
        /*!
         * Sizzle CSS Selector Engine v2.2.1
         * http://sizzlejs.com/
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2015-10-17
         */
        (function(window) {
            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function(a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },
                MAX_NEGATIVE = 1 << 31,
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                indexOf = function(list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },
                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                whitespace = "[\\x20\\t\\r\\n\\f]",
                identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
                pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),
                matchExpr = {
                    "ID": new RegExp("^#(" + identifier + ")"),
                    "CLASS": new RegExp("^\\.(" + identifier + ")"),
                    "TAG": new RegExp("^(" + identifier + "|[*])"),
                    "ATTR": new RegExp("^" + attributes),
                    "PSEUDO": new RegExp("^" + pseudos),
                    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                    "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                rescape = /'|\\/g,
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function(_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 0x10000;
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                },
                unloadHandler = function() {
                    setDocument();
                };
            try {
                push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ? function(target, els) {
                        push_native.apply(target, slice.call(els));
                    } : function(target, els) {
                        var j = target.length,
                            i = 0;
                        while ((target[j++] = els[i++])) {}
                        target.length = j - 1;
                    }
                };
            }

            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument,
                    nodeType = context ? context.nodeType : 9;
                results = results || [];
                if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                    return results;
                }
                if (!seed) {
                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;
                    if (documentIsHTML) {
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                            if ((m = match[1])) {
                                if (nodeType === 9) {
                                    if ((elem = context.getElementById(m))) {
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                }
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;
                            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }
                        if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            if (nodeType !== 1) {
                                newContext = context;
                                newSelector = selector;
                            } else if (context.nodeName.toLowerCase() !== "object") {
                                if ((nid = context.getAttribute("id"))) {
                                    nid = nid.replace(rescape, "\\$&");
                                } else {
                                    context.setAttribute("id", (nid = expando));
                                }
                                groups = tokenize(selector);
                                i = groups.length;
                                nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                                while (i--) {
                                    groups[i] = nidselect + " " + toSelector(groups[i]);
                                }
                                newSelector = groups.join(",");
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            }
                            if (newSelector) {
                                try {
                                    push.apply(results, newContext.querySelectorAll(newSelector));
                                    return results;
                                } catch (qsaError) {} finally {
                                    if (nid === expando) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }

            function createCache() {
                var keys = [];

                function cache(key, value) {
                    if (keys.push(key + " ") > Expr.cacheLength) {
                        delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                }
                return cache;
            }

            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            function assert(fn) {
                var div = document.createElement("div");
                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    div = null;
                }
            }

            function addHandle(attrs, handler) {
                var arr = attrs.split("|"),
                    i = arr.length;
                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) -
                    (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) {
                    return diff;
                }
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }
                return a ? 1 : -1;
            }

            function createInputPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            function createButtonPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            function createPositionalPseudo(fn) {
                return markFunction(function(argument) {
                    argument = +argument;
                    return markFunction(function(seed, matches) {
                        var j, matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            function testContext(context) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }
            support = Sizzle.support = {};
            isXML = Sizzle.isXML = function(elem) {
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };
            setDocument = Sizzle.setDocument = function(node) {
                var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML(document);
                if ((parent = document.defaultView) && parent.top !== parent) {
                    if (parent.addEventListener) {
                        parent.addEventListener("unload", unloadHandler, false);
                    } else if (parent.attachEvent) {
                        parent.attachEvent("onunload", unloadHandler);
                    }
                }
                support.attributes = assert(function(div) {
                    div.className = "i";
                    return !div.getAttribute("className");
                });
                support.getElementsByTagName = assert(function(div) {
                    div.appendChild(document.createComment(""));
                    return !div.getElementsByTagName("*").length;
                });
                support.getElementsByClassName = rnative.test(document.getElementsByClassName);
                support.getById = assert(function(div) {
                    docElem.appendChild(div).id = expando;
                    return !document.getElementsByName || !document.getElementsByName(expando).length;
                });
                if (support.getById) {
                    Expr.find["ID"] = function(id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m ? [m] : [];
                        }
                    };
                    Expr.filter["ID"] = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                } else {
                    delete Expr.find["ID"];
                    Expr.filter["ID"] = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };
                }
                Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                    if (typeof context.getElementsByTagName !== "undefined") {
                        return context.getElementsByTagName(tag);
                    } else if (support.qsa) {
                        return context.querySelectorAll(tag);
                    }
                } : function(tag, context) {
                    var elem, tmp = [],
                        i = 0,
                        results = context.getElementsByTagName(tag);
                    if (tag === "*") {
                        while ((elem = results[i++])) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem);
                            }
                        }
                        return tmp;
                    }
                    return results;
                };
                Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                    if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };
                rbuggyMatches = [];
                rbuggyQSA = [];
                if ((support.qsa = rnative.test(document.querySelectorAll))) {
                    assert(function(div) {
                        docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                        if (div.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                        }
                        if (!div.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                        }
                        if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                            rbuggyQSA.push("~=");
                        }
                        if (!div.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked");
                        }
                        if (!div.querySelectorAll("a#" + expando + "+*").length) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });
                    assert(function(div) {
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden");
                        div.appendChild(input).setAttribute("name", "D");
                        if (div.querySelectorAll("[name=d]").length) {
                            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                        }
                        if (!div.querySelectorAll(":enabled").length) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }
                if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
                    assert(function(div) {
                        support.disconnectedMatch = matches.call(div, "div");
                        matches.call(div, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos);
                    });
                }
                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
                hasCompare = rnative.test(docElem.compareDocumentPosition);
                contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                    var adown = a.nodeType === 9 ? a.documentElement : a,
                        bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                } : function(a, b) {
                    if (b) {
                        while ((b = b.parentNode)) {
                            if (b === a) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                sortOrder = hasCompare ? function(a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                    if (compare) {
                        return compare;
                    }
                    compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                    if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
                        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                            return -1;
                        }
                        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                            return 1;
                        }
                        return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
                    }
                    return compare & 4 ? -1 : 1;
                } : function(a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var cur, i = 0,
                        aup = a.parentNode,
                        bup = b.parentNode,
                        ap = [a],
                        bp = [b];
                    if (!aup || !bup) {
                        return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
                    } else if (aup === bup) {
                        return siblingCheck(a, b);
                    }
                    cur = a;
                    while ((cur = cur.parentNode)) {
                        ap.unshift(cur);
                    }
                    cur = b;
                    while ((cur = cur.parentNode)) {
                        bp.unshift(cur);
                    }
                    while (ap[i] === bp[i]) {
                        i++;
                    }
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                };
                return document;
            };
            Sizzle.matches = function(expr, elements) {
                return Sizzle(expr, null, null, elements);
            };
            Sizzle.matchesSelector = function(elem, expr) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                expr = expr.replace(rattributeQuotes, "='$1']");
                if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {}
                }
                return Sizzle(expr, document, null, [elem]).length > 0;
            };
            Sizzle.contains = function(context, elem) {
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };
            Sizzle.attr = function(elem, name) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                var fn = Expr.attrHandle[name.toLowerCase()],
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            };
            Sizzle.error = function(msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            };
            Sizzle.uniqueSort = function(results) {
                var elem, duplicates = [],
                    j = 0,
                    i = 0;
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);
                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }
                sortInput = null;
                return results;
            };
            getText = Sizzle.getText = function(elem) {
                var node, ret = "",
                    i = 0,
                    nodeType = elem.nodeType;
                if (!nodeType) {
                    while ((node = elem[i++])) {
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                return ret;
            };
            Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: true
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: true
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    "ATTR": function(match) {
                        match[1] = match[1].replace(runescape, funescape);
                        match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                        if (match[2] === "~=") {
                            match[3] = " " + match[3] + " ";
                        }
                        return match.slice(0, 4);
                    },
                    "CHILD": function(match) {
                        match[1] = match[1].toLowerCase();
                        if (match[1].slice(0, 3) === "nth") {
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                            match[5] = +((match[7] + match[8]) || match[3] === "odd");
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }
                        return match;
                    },
                    "PSEUDO": function(match) {
                        var excess, unquoted = !match[6] && match[2];
                        if (matchExpr["CHILD"].test(match[0])) {
                            return null;
                        }
                        if (match[3]) {
                            match[2] = match[4] || match[5] || "";
                        } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }
                        return match.slice(0, 3);
                    }
                },
                filter: {
                    "TAG": function(nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === "*" ? function() {
                            return true;
                        } : function(elem) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                        };
                    },
                    "CLASS": function(className) {
                        var pattern = classCache[className + " "];
                        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                        });
                    },
                    "ATTR": function(name, operator, check) {
                        return function(elem) {
                            var result = Sizzle.attr(elem, name);
                            if (result == null) {
                                return operator === "!=";
                            }
                            if (!operator) {
                                return true;
                            }
                            result += "";
                            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                        };
                    },
                    "CHILD": function(type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";
                        return first === 1 && last === 0 ? function(elem) {
                            return !!elem.parentNode;
                        } : function(elem, context, xml) {
                            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                parent = elem.parentNode,
                                name = ofType && elem.nodeName.toLowerCase(),
                                useCache = !xml && !ofType,
                                diff = false;
                            if (parent) {
                                if (simple) {
                                    while (dir) {
                                        node = elem;
                                        while ((node = node[dir])) {
                                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                return false;
                                            }
                                        }
                                        start = dir = type === "only" && !start && "nextSibling";
                                    }
                                    return true;
                                }
                                start = [forward ? parent.firstChild : parent.lastChild];
                                if (forward && useCache) {
                                    node = parent;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex && cache[2];
                                    node = nodeIndex && parent.childNodes[nodeIndex];
                                    while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                            uniqueCache[type] = [dirruns, nodeIndex, diff];
                                            break;
                                        }
                                    }
                                } else {
                                    if (useCache) {
                                        node = elem;
                                        outerCache = node[expando] || (node[expando] = {});
                                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex;
                                    }
                                    if (diff === false) {
                                        while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                if (useCache) {
                                                    outerCache = node[expando] || (node[expando] = {});
                                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                    uniqueCache[type] = [dirruns, diff];
                                                }
                                                if (node === elem) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                diff -= last;
                                return diff === first || (diff % first === 0 && diff / first >= 0);
                            }
                        };
                    },
                    "PSEUDO": function(pseudo, argument) {
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                        if (fn[expando]) {
                            return fn(argument);
                        }
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, "", argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                var idx, matched = fn(seed, argument),
                                    i = matched.length;
                                while (i--) {
                                    idx = indexOf(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i]);
                                }
                            }) : function(elem) {
                                return fn(elem, 0, args);
                            };
                        }
                        return fn;
                    }
                },
                pseudos: {
                    "not": markFunction(function(selector) {
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, "$1"));
                        return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                            var elem, unmatched = matcher(seed, null, xml, []),
                                i = seed.length;
                            while (i--) {
                                if ((elem = unmatched[i])) {
                                    seed[i] = !(matches[i] = elem);
                                }
                            }
                        }) : function(elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            input[0] = null;
                            return !results.pop();
                        };
                    }),
                    "has": markFunction(function(selector) {
                        return function(elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),
                    "contains": markFunction(function(text) {
                        text = text.replace(runescape, funescape);
                        return function(elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),
                    "lang": markFunction(function(lang) {
                        if (!ridentifier.test(lang || "")) {
                            Sizzle.error("unsupported lang: " + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function(elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),
                    "target": function(elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },
                    "root": function(elem) {
                        return elem === docElem;
                    },
                    "focus": function(elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },
                    "enabled": function(elem) {
                        return elem.disabled === false;
                    },
                    "disabled": function(elem) {
                        return elem.disabled === true;
                    },
                    "checked": function(elem) {
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },
                    "selected": function(elem) {
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }
                        return elem.selected === true;
                    },
                    "empty": function(elem) {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },
                    "parent": function(elem) {
                        return !Expr.pseudos["empty"](elem);
                    },
                    "header": function(elem) {
                        return rheader.test(elem.nodeName);
                    },
                    "input": function(elem) {
                        return rinputs.test(elem.nodeName);
                    },
                    "button": function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },
                    "text": function(elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                    },
                    "first": createPositionalPseudo(function() {
                        return [0];
                    }),
                    "last": createPositionalPseudo(function(matchIndexes, length) {
                        return [length - 1];
                    }),
                    "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),
                    "even": createPositionalPseudo(function(matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    "odd": createPositionalPseudo(function(matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };
            Expr.pseudos["nth"] = Expr.pseudos["eq"];
            for (i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true
                }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {
                    submit: true,
                    reset: true
                }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }
                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;
                while (soFar) {
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }
                    matched = false;
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        });
                        soFar = soFar.slice(matched.length);
                    }
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }
                    if (!matched) {
                        break;
                    }
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;
                return combinator.first ? function(elem, context, xml) {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml);
                        }
                    }
                } : function(elem, context, xml) {
                    var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                    if (xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                if (matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    } else {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                                if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                    return (newCache[2] = oldCache[2]);
                                } else {
                                    uniqueCache[dir] = newCache;
                                    if ((newCache[2] = matcher(elem, context, xml))) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ? function(elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false;
                        }
                    }
                    return true;
                } : matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem, newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;
                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }
                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function(seed, results, context, xml) {
                    var temp, i, elem, preMap = [],
                        postMap = [],
                        preexisting = results.length,
                        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                        matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext, matcher, j, len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,
                    matchContext = addCombinator(function(elem) {
                        return elem === checkContext;
                    }, implicitRelative, true),
                    matchAnyContext = addCombinator(function(elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true),
                    matchers = [function(elem, context, xml) {
                        var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                        if (matcher[expando]) {
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                value: tokens[i - 2].type === " " ? "*" : ""
                            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
                        }
                        matchers.push(matcher);
                    }
                }
                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function(seed, context, xml, results, outermost) {
                        var elem, j, matcher, matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;
                        if (outermost) {
                            outermostContext = context === document || context || outermost;
                        }
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                if (!context && elem.ownerDocument !== document) {
                                    setDocument(elem);
                                    xml = !documentIsHTML;
                                }
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }
                            if (bySet) {
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }
                            if (seed) {
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }
                                setMatched = condense(setMatched);
                            }
                            push.apply(results, setMatched);
                            if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }
                        return unmatched;
                    };
                return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle.compile = function(selector, match) {
                var i, setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];
                if (!cached) {
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                    cached.selector = selector;
                }
                return cached;
            };
            select = Sizzle.select = function(selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));
                results = results || [];
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;
                        } else if (compiled) {
                            context = context.parentNode;
                        }
                        selector = selector.slice(tokens.shift().value.length);
                    }
                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
                (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
                return results;
            };
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            support.detectDuplicates = !!hasDuplicate;
            setDocument();
            support.sortDetached = assert(function(div1) {
                return div1.compareDocumentPosition(document.createElement("div")) & 1;
            });
            if (!assert(function(div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#";
                })) {
                addHandle("type|href|height|width", function(elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                    }
                });
            }
            if (!support.attributes || !assert(function(div) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute("value", "");
                    return div.firstChild.getAttribute("value") === "";
                })) {
                addHandle("value", function(elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue;
                    }
                });
            }
            if (!assert(function(div) {
                    return div.getAttribute("disabled") == null;
                })) {
                addHandle(booleans, function(elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                    }
                });
            }
            return Sizzle;
        })(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var dir = function(elem, dir, until) {
        var matched = [],
            truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
    var risSimple = /^.[^:#\[\.,]*$/;

    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return (elem === qualifier) !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return (indexOf.call(qualifier, elem) > -1) !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length,
                ret = [],
                self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        init = jQuery.fn.init = function(selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === "string") {
                if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                    match = [null, selector, null];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this),
                l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = (/\S+/g);

    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var
            firing, memory, fired, locked, list = [],
            queue = [],
            firingIndex = -1,
            fire = function() {
                locked = options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = "";
                    }
                }
            },
            self = {
                add: function() {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function(_, arg) {
                                if (jQuery.isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                                    add(arg);
                                }
                            });
                        })(arguments);
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function() {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function(fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function() {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function() {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function() {
                    return !list;
                },
                lock: function() {
                    locked = queue = [];
                    if (!memory) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function() {
                    return !!locked;
                },
                fireWith: function(context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function() {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function() {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.Callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function() {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function() {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0,
                resolveValues = slice.call(arguments),
                length = resolveValues.length,
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                updateFunc = function(i, contexts, values) {
                    return function(value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!(--remaining)) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },
                progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });

    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
                window.setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed);
                window.addEventListener("load", completed);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };

    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        register: function(owner, initial) {
            var value = initial || {};
            if (owner.nodeType) {
                owner[this.expando] = value;
            } else {
                Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                });
            }
            return owner[this.expando];
        },
        cache: function(owner) {
            if (!acceptData(owner)) {
                return {};
            }
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                for (prop in data) {
                    cache[prop] = data[prop];
                }
            }
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key === undefined) {
                this.register(owner);
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [key, camel];
                    } else {
                        name = camel;
                        name = name in cache ? [name] : (name.match(rnotwhite) || []);
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0],
                attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    dataUser.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
                    if (data !== undefined) {
                        return data;
                    }
                    camelKey = jQuery.camelCase(key);
                    data = dataUser.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                camelKey = jQuery.camelCase(key);
                this.each(function() {
                    var data = dataUser.get(this, camelKey);
                    dataUser.set(this, camelKey, value);
                    if (key.indexOf("-") > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function() {
                    jQuery.dequeue(elem, type);
                };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };

    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1,
            maxIterations = 20,
            currentValue = tween ? function() {
                return tween.cur();
            } : function() {
                return jQuery.css(elem, prop, "");
            },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
            initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || ".5";
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = (/^(?:checkbox|radio)$/i);
    var rtagName = (/<([\w:-]+)/);
    var rscriptType = (/^$|\/(?:java|ecma)script/i);
    var wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {
        var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }

    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
    }
    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === "object") {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = "";
                }
            }
        }
        fragment.textContent = "";
        i = 0;
        while ((elem = nodes[i++])) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
            if (typeof selector !== "string") {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [],
                args = slice.call(arguments),
                handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;
            if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX +
                        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                        (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY +
                        (doc && doc.scrollTop || body && body.scrollTop || 0) -
                        (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
        rnoInnerhtml = /<script|<style|<link/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }

    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }

    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            isFunction = jQuery.isFunction(value);
        if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
            return collection.each(function(index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }

    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;
        for (;
            (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special,
                i = 0;
            for (;
                (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        domManip: domManip,
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function() {
            var elem, i = 0;
            for (;
                (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {
        HTML: "block",
        BODY: "block"
    };

    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }

    function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = (/^margin/);
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var documentElement = document.documentElement;
    (function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"),
            div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);

        function computeStyleTests() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";
            documentElement.removeChild(container);
        }
        jQuery.extend(support, {
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {
                var ret, marginDiv = div.appendChild(document.createElement("div"));
                marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild(container);
                ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
                documentElement.removeChild(container);
                div.removeChild(marginDiv);
                return ret;
            }
        });
    })();

    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
        if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
        }
        if (computed) {
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        cssPrefixes = ["Webkit", "O", "Moz", "ms"],
        emptyStyle = document.createElement("div").style;

    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
            val = 0;
        for (; i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }

    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return (val +
            augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
    }

    function showHide(elements, show) {
        var display, elem, hidden, values = [],
            index = 0,
            length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = dataPriv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name),
                style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem),
                    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left -
                swap(elem, {
                    marginLeft: 0
                }, function() {
                    return elem.getBoundingClientRect().left;
                })) + "px";
        }
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return swap(elem, {
                "display": "inline-block"
            }, curCSS, [elem, "marginRight"]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0,
                    expanded = {},
                    parts = typeof value === "string" ? value.split(" ") : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {},
                    i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var
        fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function createFxNow() {
        window.setTimeout(function() {
            fxNow = undefined;
        });
        return (fxNow = jQuery.now());
    }

    function genFx(type, includeWidth) {
        var which, i = 0,
            attrs = {
                height: type
            };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result, stopped, index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function() {
                delete tick.elem;
            }),
            tick = function() {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [animation, percent, remaining]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function(gotoEnd) {
                    var index = 0,
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [animation, 1, 0]);
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }]
        },
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnotwhite);
            }
            var prop, index = 0,
                length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function() {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0,
            timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        window.clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0,
                attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return (elem[name] = value);
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;

    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr("class", "");
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function() {
                var className, i, self, classNames;
                if (type === "string") {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];
                    while ((className = classNames[i++])) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, "__className__", className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                    }
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while ((elem = this[i++])) {
                if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g,
        rspaces = /[\x20\t\r\n\f]+/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") > -1) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = "onfocusin" in window;
    if (!support.focusin) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = (/\?/);
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        prefilters = {},
        transports = {},
        allTypes = "*/".concat("*"),
        originAnchor = document.createElement("a");
    originAnchor.href = location.href;

    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while ((dataType = dataTypes[i++])) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }

    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents,
            dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {},
            dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, fireGlobals, i, s = jQuery.ajaxSetup({}, options),
                callbackContext = s.context || s,
                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                statusCode = s.statusCode || {},
                requestHeaders = {},
                requestHeadersNames = {},
                state = 0,
                strAbort = "canceled",
                jqXHR = {
                    readyState: 0,
                    getResponseHeader: function(key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function(name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function(type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function(map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function(statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] +
                (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                if (state === 2) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }

            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this),
                    contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return !jQuery.expr.filters.visible(elem);
    };
    jQuery.expr.filters.visible = function(elem) {
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [],
            add = function(key, value) {
                value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                        binary: xhr.response
                                    } : {
                                        text: xhr.responseText
                                    }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback("error");
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function() {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this,
            off = url.indexOf(" ");
        if (off > -1) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
                self.each(function() {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            });
        }
        return this;
    };
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };

    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0],
                box = {
                    top: 0,
                    left: 0
                },
                doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0],
                parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        size: function() {
            return this.length;
        }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var
        _jQuery = window.jQuery,
        _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));;
var written_count_global, goal_count_global, color_global, size_global, goal_type_global, goal_length_type_global, user_token_global;

function showHide() {
    $('#embed-goal-modal #embed-goal-btn').show();
    $('#embed-goal-modal .embed_code_txt').css({
        'opacity': '0',
        'height': '1px'
    });
    $('#embed-goal-modal #embed_input').height(1);
}

function setGoalButtonPercent(obj) {
    var percent = (100 * written_count_global) / (goal_count_global);
    if (percent <= 100) {
        $("#embed-goal-modal #goal-progress-bar").css("width", percent + "%");
    } else {
        $("#embed-goal-modal #goal-progress-bar").css("width", "100%");
    }
    $('#embed-goal-modal .progress #percent_text, #embed-goal-modal .progress-bar div').text(written_count_global + ' / ' + goal_count_global + ' ' + goal_type_global);
}

function setGoalButtonSize(obj) {
    var size = $(obj).val();
    switch (size) {
        case 'small':
            $('#embed-goal-modal .progress, #embed-goal-modal .progress-bar div').width(150);
            $('#embed-goal-modal .progress').height(20);
            $('#embed-goal-modal .progress #percent_text, #embed-goal-modal .progress-bar div').css({
                'line-height': '20px'
            });
            $('#embed-goal-modal .goal_button .progress #percent_text, #embed-goal-modal .progress-bar div').css('font-size', '12px');
            break;
        case 'middle':
            $('#embed-goal-modal .progress, #embed-goal-modal .progress-bar div').width(220);
            $('#embed-goal-modal .progress').height(30);
            $('#embed-goal-modal .progress #percent_text, #embed-goal-modal .progress-bar div').css({
                'line-height': '30px'
            });
            $('#embed-goal-modal .goal_button .progress #percent_text, #embed-goal-modal .progress-bar div').css('font-size', '19px');
            break;
        case 'large':
            $('#embed-goal-modal .progress, #embed-goal-modal .progress-bar div').width(350);
            $('#embed-goal-modal .progress').height(42);
            $('#embed-goal-modal .progress #percent_text, #embed-goal-modal .progress-bar div').css({
                'line-height': '42px'
            });
            $('#embed-goal-modal .goal_button .progress #percent_text, #embed-goal-modal .progress-bar div').css('font-size', '27px');
            break;
    }
    var iframe_width, iframe_height;
    if (size == 'small') {
        iframe_width = 157;
        iframe_height = 24;
    } else if (size == 'middle') {
        iframe_width = 227;
        iframe_height = 34;
    } else if (size == 'large') {
        iframe_width = 357;
        iframe_height = 46;
    }
    $('#embed_input').text('<div id="goal_embed_button"></div>' + '<script>(function(d, s, id) {' + 'var js, fjs = d.getElementsByTagName(s)[0];' + 'if (d.getElementById(id)) return;' + 'js = d.createElement(s); ' + 'js.id = id;' + 'js.setAttribute("data-token", "' + user_token_global + '");' + 'js.src = "' + share_path + 'js/goal_embed_view.min.js";' + 'fjs.parentNode.insertBefore(js, fjs);' + '}(document, "script", "embed_goal_js"));</script>');
}

function setGoalButtonColor(obj) {
    var goal_color = $(obj).val();
    switch (goal_color) {
        case 'blue':
            $('#embed-goal-modal .progress-bar').css('background-color', '#559cd9');
            $('#embed-goal-modal .progress').css('border-color', '#448bc8');
            $('#embed-goal-modal .progress #percent_text').css('color', '#448bc8');
            break;
        case 'red':
            $('#embed-goal-modal .progress-bar').css('background-color', '#ff8888');
            $('#embed-goal-modal .progress').css('border-color', '#ff0000');
            $('#embed-goal-modal .progress #percent_text').css('color', '#ff0000');
            break;
        case 'green':
            $('#embed-goal-modal .progress-bar').css('background-color', '#5cc55a');
            $('#embed-goal-modal .progress').css('border-color', '#4BB449');
            $('#embed-goal-modal .progress #percent_text').css('color', '#4BB449');
            break;
        case 'yellow':
            $('#embed-goal-modal .progress-bar').css('background-color', '#F8E37F');
            $('#embed-goal-modal .progress').css('border-color', '#e7d26e');
            $('#embed-goal-modal .progress #percent_text').css('color', '#e7d26e');
            break;
        case 'pink':
            $('#embed-goal-modal .progress-bar').css('background-color', '#FFC0CB');
            $('#embed-goal-modal .progress').css('border-color', '#eeb0ba');
            $('#embed-goal-modal .progress #percent_text').css('color', '#eeb0ba');
            break;
        case 'cyan':
            $('#embed-goal-modal .progress-bar').css('background-color', '#55dddd');
            $('#embed-goal-modal .progress').css('border-color', '#44cccc');
            $('#embed-goal-modal .progress #percent_text').css('color', '#44cccc');
            break;
        case 'brown':
            $('#embed-goal-modal .progress-bar').css('background-color', '#c74c4c');
            $('#embed-goal-modal .progress').css('border-color', '#A52A2A');
            $('#embed-goal-modal .progress #percent_text').css('color', '#A52A2A');
            break;
        case 'purple':
            $('#embed-goal-modal .progress-bar').css('background-color', '#c000c0');
            $('#embed-goal-modal .progress').css('border-color', '#a000a0');
            $('#embed-goal-modal .progress #percent_text').css('color', '#a000a0');
            break;
        case 'orange':
            $('#embed-goal-modal .progress-bar').css('background-color', '#ffb611');
            $('#embed-goal-modal .progress').css('border-color', '#FFA500');
            $('#embed-goal-modal .progress #percent_text').css('color', '#FFA500');
            break;
    }
}
$(document).ready(function() {
    $('.goal_embed').click(function() {
        $('#embed-goal-modal #embed-goal-btn').show();
        var goal_count = $('#goal_form input[name=goal_count]').val();
        var goal_type = $('#goal_form input[name=goal_type]').val();
        var written_count = $('#goal_form input[name=written_count]').val().replace(/,/gi, '');
        var goal_length_type = $('#goal_form input[name=goal_length_type]').val();
        var dataObject = {
            'embed_goal': true,
            'goal_count': goal_count,
            'written_count': written_count,
            'goal_type': goal_type,
            'goal_length_type': goal_length_type
        };
        jQuery.ajax({
            type: "POST",
            url: "site/embed-goal",
            data: dataObject,
            success: function(data) {
                if (data.success) {
                    goal_type_global = data.goal_type;
                    written_count_global = editor.commaSeparateNumber([data.written_count]);
                    goal_count_global = editor.commaSeparateNumber([data.goal_count]);
                    size_global = data.goal_size;
                    color_global = data.goal_color;
                    goal_length_type_global = data.goal_length_type;
                    user_token_global = data.user_token;
                    setGoalButtonPercent('#embed-goal-modal #caption');
                    $('#embed-goal-modal #col option').removeAttr('selected');
                    $('#embed-goal-modal #col option[value="' + color_global + '"]').attr('selected', 'selected');
                    $('#embed-goal-modal #size option').removeAttr('selected');
                    $('#embed-goal-modal #size option[value="' + size_global + '"]').attr('selected', 'selected');
                    setGoalButtonColor('#embed-goal-modal #col');
                    setGoalButtonSize('#embed-goal-modal #size');
                    $('#embed-goal-modal .embed_code_txt').css({
                        'opacity': '0',
                        'height': '1px'
                    });
                    $('#embed-goal-modal #embed_input').height(1);
                    var iframe_width, iframe_height;
                    if (size_global == 'small') {
                        iframe_width = 157;
                        iframe_height = 24;
                    } else if (size_global == 'middle') {
                        iframe_width = 227;
                        iframe_height = 34;
                    } else if (size_global == 'large') {
                        iframe_width = 357;
                        iframe_height = 46;
                    }
                    $('#embed_input').text('<div id="goal_embed_button"></div>' + '<script>(function(d, s, id) {' + 'var js, fjs = d.getElementsByTagName(s)[0];' + 'if (d.getElementById(id)) return;' + 'js = d.createElement(s); ' + 'js.id = id;' + 'js.setAttribute("data-token", "' + user_token_global + '");' + 'js.src = "' + share_path + 'js/goal_embed_view.min.js";' + 'fjs.parentNode.insertBefore(js, fjs);' + '}(document, "script", "embed_goal_js"));</script>');
                }
            }
        });
    });
    $('#embed_input').click(function() {
        $(this).focus();
        document.execCommand("SelectAll", false, null);
    });
    $('#copy-text-btn').click(function() {
        $(this).find('span:last-of-type').text(editor.selectedLanguage.copied);
        $('#embed_input').focus();
        document.execCommand('SelectAll');
        document.execCommand("Copy", false, null);
    });
    $('#embed-goal-modal #embed-goal-code-hide-btn').click(function() {
        $('#embed-goal-modal #embed-goal-btn').show();
        $('#embed-goal-modal .embed_code_txt').css({
            'opacity': '0',
            'height': '1px'
        });
        $('#embed-goal-modal #embed_input').height(1);
    });
    $('#embed-goal-btn').click(function() {
        var size = $('#embed-goal-modal #size').val();
        var color = $('#embed-goal-modal #col').val();
        var dataObject = {
            'goal_type': goal_type_global,
            'goal_count': goal_count_global,
            'written_count': written_count_global,
            'goal_length_type': goal_length_type_global,
            'goal_size': size,
            'goal_color': color
        };
        $.ajax({
            type: "POST",
            url: "site/embed-goal",
            data: dataObject,
            success: function(data) {
                if (data.success) {
                    $('#copy-text-btn').find('span:last-of-type').text(editor.selectedLanguage.copy);
                }
            }
        });
        $('#embed_input').focus();
        document.execCommand('SelectAll');
        document.execCommand("Copy", false, null);
        $('#embed-goal-modal .embed_code_txt').css({
            'opacity': '1',
            'height': 'auto'
        });
        $('#embed-goal-modal #embed_input').height('auto');
        $('#embed-goal-modal #embed-goal-btn').hide();
    });
});;
window.yii = (function($) {
    var pub = {
        reloadableScripts: [],
        clickableSelector: 'a, button, input[type="submit"], input[type="button"], input[type="reset"], input[type="image"]',
        changeableSelector: 'select, input, textarea',
        getCsrfParam: function() {
            return $('meta[name=csrf-param]').attr('content');
        },
        getCsrfToken: function() {
            return $('meta[name=csrf-token]').attr('content');
        },
        setCsrfToken: function(name, value) {
            $('meta[name=csrf-param]').attr('content', name);
            $('meta[name=csrf-token]').attr('content', value);
        },
        refreshCsrfToken: function() {
            var token = pub.getCsrfToken();
            if (token) {
                $('form input[name="' + pub.getCsrfParam() + '"]').val(token);
            }
        },
        confirm: function(message, ok, cancel) {
            if (confirm(message)) {
                !ok || ok();
            } else {
                !cancel || cancel();
            }
        },
        handleAction: function($e, event) {
            var $form = $e.attr('data-form') ? $('#' + $e.attr('data-form')) : $e.closest('form'),
                method = !$e.data('method') && $form ? $form.attr('method') : $e.data('method'),
                action = $e.attr('href'),
                params = $e.data('params'),
                pjax = $e.data('pjax'),
                pjaxPushState = !!$e.data('pjax-push-state'),
                pjaxReplaceState = !!$e.data('pjax-replace-state'),
                pjaxTimeout = $e.data('pjax-timeout'),
                pjaxScrollTo = $e.data('pjax-scrollto'),
                pjaxPushRedirect = $e.data('pjax-push-redirect'),
                pjaxReplaceRedirect = $e.data('pjax-replace-redirect'),
                pjaxSkipOuterContainers = $e.data('pjax-skip-outer-containers'),
                pjaxContainer, pjaxOptions = {};
            if (pjax !== undefined && $.support.pjax) {
                if ($e.data('pjax-container')) {
                    pjaxContainer = $e.data('pjax-container');
                } else {
                    pjaxContainer = $e.closest('[data-pjax-container=""]');
                }
                if (!pjaxContainer.length) {
                    pjaxContainer = $('body');
                }
                pjaxOptions = {
                    container: pjaxContainer,
                    push: pjaxPushState,
                    replace: pjaxReplaceState,
                    scrollTo: pjaxScrollTo,
                    pushRedirect: pjaxPushRedirect,
                    replaceRedirect: pjaxReplaceRedirect,
                    pjaxSkipOuterContainers: pjaxSkipOuterContainers,
                    timeout: pjaxTimeout,
                    originalEvent: event,
                    originalTarget: $e
                }
            }
            if (method === undefined) {
                if (action && action != '#') {
                    if (pjax !== undefined && $.support.pjax) {
                        $.pjax.click(event, pjaxOptions);
                    } else {
                        window.location = action;
                    }
                } else if ($e.is(':submit') && $form.length) {
                    if (pjax !== undefined && $.support.pjax) {
                        $form.on('submit', function(e) {
                            $.pjax.submit(e, pjaxOptions);
                        })
                    }
                    $form.trigger('submit');
                }
                return;
            }
            var newForm = !$form.length;
            if (newForm) {
                if (!action || !action.match(/(^\/|:\/\/)/)) {
                    action = window.location.href;
                }
                $form = $('<form/>', {
                    method: method,
                    action: action
                });
                var target = $e.attr('target');
                if (target) {
                    $form.attr('target', target);
                }
                if (!method.match(/(get|post)/i)) {
                    $form.append($('<input/>', {
                        name: '_method',
                        value: method,
                        type: 'hidden'
                    }));
                    method = 'POST';
                }
                if (!method.match(/(get|head|options)/i)) {
                    var csrfParam = pub.getCsrfParam();
                    if (csrfParam) {
                        $form.append($('<input/>', {
                            name: csrfParam,
                            value: pub.getCsrfToken(),
                            type: 'hidden'
                        }));
                    }
                }
                $form.hide().appendTo('body');
            }
            var activeFormData = $form.data('yiiActiveForm');
            if (activeFormData) {
                activeFormData.submitObject = $e;
            }
            if (params && $.isPlainObject(params)) {
                $.each(params, function(idx, obj) {
                    $form.append($('<input/>').attr({
                        name: idx,
                        value: obj,
                        type: 'hidden'
                    }));
                });
            }
            var oldMethod = $form.attr('method');
            $form.attr('method', method);
            var oldAction = null;
            if (action && action != '#') {
                oldAction = $form.attr('action');
                $form.attr('action', action);
            }
            if (pjax !== undefined && $.support.pjax) {
                $form.on('submit', function(e) {
                    $.pjax.submit(e, pjaxOptions);
                })
            }
            $form.trigger('submit');
            $.when($form.data('yiiSubmitFinalizePromise')).then(function() {
                if (oldAction != null) {
                    $form.attr('action', oldAction);
                }
                $form.attr('method', oldMethod);
                if (params && $.isPlainObject(params)) {
                    $.each(params, function(idx, obj) {
                        $('input[name="' + idx + '"]', $form).remove();
                    });
                }
                if (newForm) {
                    $form.remove();
                }
            });
        },
        getQueryParams: function(url) {
            var pos = url.indexOf('?');
            if (pos < 0) {
                return {};
            }
            var pairs = url.substring(pos + 1).split('#')[0].split('&'),
                params = {},
                pair, i;
            for (i = 0; i < pairs.length; i++) {
                pair = pairs[i].split('=');
                var name = decodeURIComponent(pair[0]);
                var value = decodeURIComponent(pair[1]);
                if (name.length) {
                    if (params[name] !== undefined) {
                        if (!$.isArray(params[name])) {
                            params[name] = [params[name]];
                        }
                        params[name].push(value || '');
                    } else {
                        params[name] = value || '';
                    }
                }
            }
            return params;
        },
        initModule: function(module) {
            if (module.isActive === undefined || module.isActive) {
                if ($.isFunction(module.init)) {
                    module.init();
                }
                $.each(module, function() {
                    if ($.isPlainObject(this)) {
                        pub.initModule(this);
                    }
                });
            }
        },
        init: function() {
            initCsrfHandler();
            initRedirectHandler();
            initScriptFilter();
            initDataMethods();
        }
    };

    function initRedirectHandler() {
        $(document).ajaxComplete(function(event, xhr, settings) {
            var url = xhr && xhr.getResponseHeader('X-Redirect');
            if (url) {
                window.location = url;
            }
        });
    }

    function initCsrfHandler() {
        $.ajaxPrefilter(function(options, originalOptions, xhr) {
            if (!options.crossDomain && pub.getCsrfParam()) {
                xhr.setRequestHeader('X-CSRF-Token', pub.getCsrfToken());
            }
        });
        pub.refreshCsrfToken();
    }

    function initDataMethods() {
        var handler = function(event) {
            var $this = $(this),
                method = $this.data('method'),
                message = $this.data('confirm'),
                form = $this.data('form');
            if (method === undefined && message === undefined && form === undefined) {
                return true;
            }
            if (message !== undefined) {
                $.proxy(pub.confirm, this)(message, function() {
                    pub.handleAction($this, event);
                });
            } else {
                pub.handleAction($this, event);
            }
            event.stopImmediatePropagation();
            return false;
        };
        $(document).on('click.yii', pub.clickableSelector, handler).on('change.yii', pub.changeableSelector, handler);
    }

    function isReloadable(url) {
        var hostInfo = getHostInfo();
        for (var i = 0; i < pub.reloadableScripts.length; i++) {
            var rule = pub.reloadableScripts[i];
            rule = rule.charAt(0) === '/' ? hostInfo + rule : rule;
            var match = new RegExp("^" + escapeRegExp(rule).split('\\*').join('.*') + "$").test(url);
            if (match === true) {
                return true;
            }
        }
        return false;
    }

    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }

    function getHostInfo() {
        return location.protocol + '//' + location.host;
    }

    function initScriptFilter() {
        var hostInfo = getHostInfo();
        var loadedScripts = {};
        var scripts = $('script[src]').map(function() {
            return this.src.charAt(0) === '/' ? hostInfo + this.src : this.src;
        }).toArray();
        for (var i = 0, len = scripts.length; i < len; i++) {
            loadedScripts[scripts[i]] = true;
        }
        $.ajaxPrefilter('script', function(options, originalOptions, xhr) {
            if (options.dataType == 'jsonp') {
                return;
            }
            var url = options.url.charAt(0) === '/' ? hostInfo + options.url : options.url;
            if (url in loadedScripts) {
                var item = loadedScripts[url];
                if (item !== true && !isReloadable(url)) {
                    item.done(function() {
                        if (xhr && xhr.readyState !== 4) {
                            xhr.abort();
                        }
                    });
                    xhr.done(function() {
                        if (item && item.readyState !== 4) {
                            item.abort();
                        }
                    });
                } else if (!isReloadable(url)) {
                    xhr.abort();
                }
            } else {
                loadedScripts[url] = xhr.done(function() {
                    loadedScripts[url] = true;
                }).fail(function() {
                    delete loadedScripts[url];
                });
            }
        });
        $(document).ajaxComplete(function(event, xhr, settings) {
            var styleSheets = [];
            $('link[rel=stylesheet]').each(function() {
                if (isReloadable(this.href)) {
                    return;
                }
                if ($.inArray(this.href, styleSheets) == -1) {
                    styleSheets.push(this.href)
                } else {
                    $(this).remove();
                }
            })
        });
    }
    return pub;
})(jQuery);
jQuery(function() {
    yii.initModule(yii);
});;
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */
if (typeof jQuery === 'undefined') {
    throw new Error('Bootstrap\'s JavaScript requires jQuery')
} +
function($) {
    'use strict';
    var version = $.fn.jquery.split(' ')[0].split('.')
    if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
    }
}(jQuery); + function($) {
    'use strict';

    function transitionEnd() {
        var el = document.createElement('bootstrap')
        var transEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd otransitionend',
            transition: 'transitionend'
        }
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                }
            }
        }
        return false
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false
        var $el = this
        $(this).one('bsTransitionEnd', function() {
            called = true
        })
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end)
        }
        setTimeout(callback, duration)
        return this
    }
    $(function() {
        $.support.transition = transitionEnd()
        if (!$.support.transition) return
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
            }
        }
    })
}(jQuery); + function($) {
    'use strict';
    var dismiss = '[data-dismiss="alert"]'
    var Alert = function(el) {
        $(el).on('click', dismiss, this.close)
    }
    Alert.VERSION = '3.3.7'
    Alert.TRANSITION_DURATION = 150
    Alert.prototype.close = function(e) {
        var $this = $(this)
        var selector = $this.attr('data-target')
        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '')
        }
        var $parent = $(selector === '#' ? [] : selector)
        if (e) e.preventDefault()
        if (!$parent.length) {
            $parent = $this.closest('.alert')
        }
        $parent.trigger(e = $.Event('close.bs.alert'))
        if (e.isDefaultPrevented()) return
        $parent.removeClass('in')

        function removeElement() {
            $parent.detach().trigger('closed.bs.alert').remove()
        }
        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement()
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.alert')
            if (!data) $this.data('bs.alert', (data = new Alert(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }
    var old = $.fn.alert
    $.fn.alert = Plugin
    $.fn.alert.Constructor = Alert
    $.fn.alert.noConflict = function() {
        $.fn.alert = old
        return this
    }
    $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
}(jQuery); + function($) {
    'use strict';
    var Button = function(element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Button.DEFAULTS, options)
        this.isLoading = false
    }
    Button.VERSION = '3.3.7'
    Button.DEFAULTS = {
        loadingText: 'loading...'
    }
    Button.prototype.setState = function(state) {
        var d = 'disabled'
        var $el = this.$element
        var val = $el.is('input') ? 'val' : 'html'
        var data = $el.data()
        state += 'Text'
        if (data.resetText == null) $el.data('resetText', $el[val]())
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state])
            if (state == 'loadingText') {
                this.isLoading = true
                $el.addClass(d).attr(d, d).prop(d, true)
            } else if (this.isLoading) {
                this.isLoading = false
                $el.removeClass(d).removeAttr(d).prop(d, false)
            }
        }, this), 0)
    }
    Button.prototype.toggle = function() {
        var changed = true
        var $parent = this.$element.closest('[data-toggle="buttons"]')
        if ($parent.length) {
            var $input = this.$element.find('input')
            if ($input.prop('type') == 'radio') {
                if ($input.prop('checked')) changed = false
                $parent.find('.active').removeClass('active')
                this.$element.addClass('active')
            } else if ($input.prop('type') == 'checkbox') {
                if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
                this.$element.toggleClass('active')
            }
            $input.prop('checked', this.$element.hasClass('active'))
            if (changed) $input.trigger('change')
        } else {
            this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
            this.$element.toggleClass('active')
        }
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.button')
            var options = typeof option == 'object' && option
            if (!data) $this.data('bs.button', (data = new Button(this, options)))
            if (option == 'toggle') data.toggle()
            else if (option) data.setState(option)
        })
    }
    var old = $.fn.button
    $.fn.button = Plugin
    $.fn.button.Constructor = Button
    $.fn.button.noConflict = function() {
        $.fn.button = old
        return this
    }
    $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest('.btn')
        Plugin.call($btn, 'toggle')
        if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
            e.preventDefault()
            if ($btn.is('input,button')) $btn.trigger('focus')
            else $btn.find('input:visible,button:visible').first().trigger('focus')
        }
    }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })
}(jQuery); + function($) {
    'use strict';
    var Carousel = function(element, options) {
        this.$element = $(element)
        this.$indicators = this.$element.find('.carousel-indicators')
        this.options = options
        this.paused = null
        this.sliding = null
        this.interval = null
        this.$active = null
        this.$items = null
        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
    }
    Carousel.VERSION = '3.3.7'
    Carousel.TRANSITION_DURATION = 600
    Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
    }
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return
        switch (e.which) {
            case 37:
                this.prev();
                break
            case 39:
                this.next();
                break
            default:
                return
        }
        e.preventDefault()
    }
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false)
        this.interval && clearInterval(this.interval)
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
        return this
    }
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children('.item')
        return this.$items.index(item || this.$active)
    }
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active)
        var willWrap = (direction == 'prev' && activeIndex === 0) || (direction == 'next' && activeIndex == (this.$items.length - 1))
        if (willWrap && !this.options.wrap) return active
        var delta = direction == 'prev' ? -1 : 1
        var itemIndex = (activeIndex + delta) % this.$items.length
        return this.$items.eq(itemIndex)
    }
    Carousel.prototype.to = function(pos) {
        var that = this
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
        if (pos > (this.$items.length - 1) || pos < 0) return
        if (this.sliding) return this.$element.one('slid.bs.carousel', function() {
            that.to(pos)
        })
        if (activeIndex == pos) return this.pause().cycle()
        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
    }
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true)
        if (this.$element.find('.next, .prev').length && $.support.transition) {
            this.$element.trigger($.support.transition.end)
            this.cycle(true)
        }
        this.interval = clearInterval(this.interval)
        return this
    }
    Carousel.prototype.next = function() {
        if (this.sliding) return
        return this.slide('next')
    }
    Carousel.prototype.prev = function() {
        if (this.sliding) return
        return this.slide('prev')
    }
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find('.item.active')
        var $next = next || this.getItemForDirection(type, $active)
        var isCycling = this.interval
        var direction = type == 'next' ? 'left' : 'right'
        var that = this
        if ($next.hasClass('active')) return (this.sliding = false)
        var relatedTarget = $next[0]
        var slideEvent = $.Event('slide.bs.carousel', {
            relatedTarget: relatedTarget,
            direction: direction
        })
        this.$element.trigger(slideEvent)
        if (slideEvent.isDefaultPrevented()) return
        this.sliding = true
        isCycling && this.pause()
        if (this.$indicators.length) {
            this.$indicators.find('.active').removeClass('active')
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
            $nextIndicator && $nextIndicator.addClass('active')
        }
        var slidEvent = $.Event('slid.bs.carousel', {
            relatedTarget: relatedTarget,
            direction: direction
        })
        if ($.support.transition && this.$element.hasClass('slide')) {
            $next.addClass(type)
            $next[0].offsetWidth
            $active.addClass(direction)
            $next.addClass(direction)
            $active.one('bsTransitionEnd', function() {
                $next.removeClass([type, direction].join(' ')).addClass('active')
                $active.removeClass(['active', direction].join(' '))
                that.sliding = false
                setTimeout(function() {
                    that.$element.trigger(slidEvent)
                }, 0)
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)
        } else {
            $active.removeClass('active')
            $next.addClass('active')
            this.sliding = false
            this.$element.trigger(slidEvent)
        }
        isCycling && this.cycle()
        return this
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.carousel')
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
            var action = typeof option == 'string' ? option : options.slide
            if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
            if (typeof option == 'number') data.to(option)
            else if (action) data[action]()
            else if (options.interval) data.pause().cycle()
        })
    }
    var old = $.fn.carousel
    $.fn.carousel = Plugin
    $.fn.carousel.Constructor = Carousel
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old
        return this
    }
    var clickHandler = function(e) {
        var href
        var $this = $(this)
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''))
        if (!$target.hasClass('carousel')) return
        var options = $.extend({}, $target.data(), $this.data())
        var slideIndex = $this.attr('data-slide-to')
        if (slideIndex) options.interval = false
        Plugin.call($target, options)
        if (slideIndex) {
            $target.data('bs.carousel').to(slideIndex)
        }
        e.preventDefault()
    }
    $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
    $(window).on('load', function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this)
            Plugin.call($carousel, $carousel.data())
        })
    })
}(jQuery); + function($) {
    'use strict';
    var Collapse = function(element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Collapse.DEFAULTS, options)
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]')
        this.transitioning = null
        if (this.options.parent) {
            this.$parent = this.getParent()
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger)
        }
        if (this.options.toggle) this.toggle()
    }
    Collapse.VERSION = '3.3.7'
    Collapse.TRANSITION_DURATION = 350
    Collapse.DEFAULTS = {
        toggle: true
    }
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass('width')
        return hasWidth ? 'width' : 'height'
    }
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass('in')) return
        var activesData
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
        if (actives && actives.length) {
            activesData = actives.data('bs.collapse')
            if (activesData && activesData.transitioning) return
        }
        var startEvent = $.Event('show.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return
        if (actives && actives.length) {
            Plugin.call(actives, 'hide')
            activesData || actives.data('bs.collapse', null)
        }
        var dimension = this.dimension()
        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true)
        this.$trigger.removeClass('collapsed').attr('aria-expanded', true)
        this.transitioning = 1
        var complete = function() {
            this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('')
            this.transitioning = 0
            this.$element.trigger('shown.bs.collapse')
        }
        if (!$.support.transition) return complete.call(this)
        var scrollSize = $.camelCase(['scroll', dimension].join('-'))
        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
    }
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass('in')) return
        var startEvent = $.Event('hide.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return
        var dimension = this.dimension()
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight
        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false)
        this.$trigger.addClass('collapsed').attr('aria-expanded', false)
        this.transitioning = 1
        var complete = function() {
            this.transitioning = 0
            this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse')
        }
        if (!$.support.transition) return complete.call(this)
        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    }
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element)
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this)).end()
    }
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass('in')
        $element.attr('aria-expanded', isOpen)
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen)
    }

    function getTargetFromTrigger($trigger) {
        var href
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')
        return $(target)
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.collapse')
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
            if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.collapse
    $.fn.collapse = Plugin
    $.fn.collapse.Constructor = Collapse
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old
        return this
    }
    $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
        var $this = $(this)
        if (!$this.attr('data-target')) e.preventDefault()
        var $target = getTargetFromTrigger($this)
        var data = $target.data('bs.collapse')
        var option = data ? 'toggle' : $this.data()
        Plugin.call($target, option)
    })
}(jQuery); + function($) {
    'use strict';
    var backdrop = '.dropdown-backdrop'
    var toggle = '[data-toggle="dropdown"]'
    var Dropdown = function(element) {
        $(element).on('click.bs.dropdown', this.toggle)
    }
    Dropdown.VERSION = '3.3.7'

    function getParent($this) {
        var selector = $this.attr('data-target')
        if (!selector) {
            selector = $this.attr('href')
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '')
        }
        var $parent = selector && $(selector)
        return $parent && $parent.length ? $parent : $this.parent()
    }

    function clearMenus(e) {
        if (e && e.which === 3) return
        $(backdrop).remove()
        $(toggle).each(function() {
            var $this = $(this)
            var $parent = getParent($this)
            var relatedTarget = {
                relatedTarget: this
            }
            if (!$parent.hasClass('open')) return
            if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return
            $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
            if (e.isDefaultPrevented()) return
            $this.attr('aria-expanded', 'false')
            $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
        })
    }
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this)
        if ($this.is('.disabled, :disabled')) return
        var $parent = getParent($this)
        var isActive = $parent.hasClass('open')
        clearMenus()
        if (!isActive) {
            if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
                $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus)
            }
            var relatedTarget = {
                relatedTarget: this
            }
            $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
            if (e.isDefaultPrevented()) return
            $this.trigger('focus').attr('aria-expanded', 'true')
            $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget))
        }
        return false
    }
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
        var $this = $(this)
        e.preventDefault()
        e.stopPropagation()
        if ($this.is('.disabled, :disabled')) return
        var $parent = getParent($this)
        var isActive = $parent.hasClass('open')
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger('focus')
            return $this.trigger('click')
        }
        var desc = ' li:not(.disabled):visible a'
        var $items = $parent.find('.dropdown-menu' + desc)
        if (!$items.length) return
        var index = $items.index(e.target)
        if (e.which == 38 && index > 0) index--
            if (e.which == 40 && index < $items.length - 1) index++
                if (!~index) index = 0
        $items.eq(index).trigger('focus')
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.dropdown')
            if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }
    var old = $.fn.dropdown
    $.fn.dropdown = Plugin
    $.fn.dropdown.Constructor = Dropdown
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old
        return this
    }
    $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
        e.stopPropagation()
    }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
}(jQuery); + function($) {
    'use strict';
    var Modal = function(element, options) {
        this.options = options
        this.$body = $(document.body)
        this.$element = $(element)
        this.$dialog = this.$element.find('.modal-dialog')
        this.$backdrop = null
        this.isShown = null
        this.originalBodyPad = null
        this.scrollbarWidth = 0
        this.ignoreBackdropClick = false
        if (this.options.remote) {
            this.$element.find('.modal-content').load(this.options.remote, $.proxy(function() {
                this.$element.trigger('loaded.bs.modal')
            }, this))
        }
    }
    Modal.VERSION = '3.3.7'
    Modal.TRANSITION_DURATION = 300
    Modal.BACKDROP_TRANSITION_DURATION = 150
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    }
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }
    Modal.prototype.show = function(_relatedTarget) {
        var that = this
        var e = $.Event('show.bs.modal', {
            relatedTarget: _relatedTarget
        })
        this.$element.trigger(e)
        if (this.isShown || e.isDefaultPrevented()) return
        this.isShown = true
        this.checkScrollbar()
        this.setScrollbar()
        this.$body.addClass('modal-open')
        this.escape()
        this.resize()
        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
        this.$dialog.on('mousedown.dismiss.bs.modal', function() {
            that.$element.one('mouseup.dismiss.bs.modal', function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
            })
        })
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass('fade')
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body)
            }
            that.$element.show().scrollTop(0)
            that.adjustDialog()
            if (transition) {
                that.$element[0].offsetWidth
            }
            that.$element.addClass('in')
            that.enforceFocus()
            var e = $.Event('shown.bs.modal', {
                relatedTarget: _relatedTarget
            })
            transition ? that.$dialog.one('bsTransitionEnd', function() {
                that.$element.trigger('focus').trigger(e)
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e)
        })
    }
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault()
        e = $.Event('hide.bs.modal')
        this.$element.trigger(e)
        if (!this.isShown || e.isDefaultPrevented()) return
        this.isShown = false
        this.escape()
        this.resize()
        $(document).off('focusin.bs.modal')
        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal')
        this.$dialog.off('mousedown.dismiss.bs.modal')
        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal()
    }
    Modal.prototype.enforceFocus = function() {
        $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function(e) {
            if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger('focus')
            }
        }, this))
    }
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
                e.which == 27 && this.hide()
            }, this))
        } else if (!this.isShown) {
            this.$element.off('keydown.dismiss.bs.modal')
        }
    }
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
        } else {
            $(window).off('resize.bs.modal')
        }
    }
    Modal.prototype.hideModal = function() {
        var that = this
        this.$element.hide()
        this.backdrop(function() {
            that.$body.removeClass('modal-open')
            that.resetAdjustments()
            that.resetScrollbar()
            that.$element.trigger('hidden.bs.modal')
        })
    }
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }
    Modal.prototype.backdrop = function(callback) {
        var that = this
        var animate = this.$element.hasClass('fade') ? 'fade' : ''
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate
            this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body)
            this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false
                    return
                }
                if (e.target !== e.currentTarget) return
                this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide()
            }, this))
            if (doAnimate) this.$backdrop[0].offsetWidth
            this.$backdrop.addClass('in')
            if (!callback) return
            doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass('in')
            var callbackRemove = function() {
                that.removeBackdrop()
                callback && callback()
            }
            $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove()
        } else if (callback) {
            callback()
        }
    }
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog()
    }
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        })
    }
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: '',
            paddingRight: ''
        })
    }
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect()
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
        this.scrollbarWidth = this.measureScrollbar()
    }
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
        this.originalBodyPad = document.body.style.paddingRight || ''
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
    }
    Modal.prototype.resetScrollbar = function() {
        this.$body.css('padding-right', this.originalBodyPad)
    }
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement('div')
        scrollDiv.className = 'modal-scrollbar-measure'
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
    }

    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.modal')
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
            if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option](_relatedTarget)
            else if (options.show) data.show(_relatedTarget)
        })
    }
    var old = $.fn.modal
    $.fn.modal = Plugin
    $.fn.modal.Constructor = Modal
    $.fn.modal.noConflict = function() {
        $.fn.modal = old
        return this
    }
    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
        var $this = $(this)
        var href = $this.attr('href')
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, '')))
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data())
        if ($this.is('a')) e.preventDefault()
        $target.one('show.bs.modal', function(showEvent) {
            if (showEvent.isDefaultPrevented()) return
            $target.one('hidden.bs.modal', function() {
                $this.is(':visible') && $this.trigger('focus')
            })
        })
        Plugin.call($target, option, this)
    })
}(jQuery); + function($) {
    'use strict';
    var Tooltip = function(element, options) {
        this.type = null
        this.options = null
        this.enabled = null
        this.timeout = null
        this.hoverState = null
        this.$element = null
        this.inState = null
        this.init('tooltip', element, options)
    }
    Tooltip.VERSION = '3.3.7'
    Tooltip.TRANSITION_DURATION = 150
    Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: 'body',
            padding: 0
        }
    }
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true
        this.type = type
        this.$element = $(element)
        this.options = this.getOptions(options)
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
        this.inState = {
            click: false,
            hover: false,
            focus: false
        }
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
        }
        var triggers = this.options.trigger.split(' ')
        for (var i = triggers.length; i--;) {
            var trigger = triggers[i]
            if (trigger == 'click') {
                this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
            } else if (trigger != 'manual') {
                var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin'
                var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
                this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
                this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
            }
        }
        this.options.selector ? (this._options = $.extend({}, this.options, {
            trigger: 'manual',
            selector: ''
        })) : this.fixTitle()
    }
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS
    }
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options)
        if (options.delay && typeof options.delay == 'number') {
            options.delay = {
                show: options.delay,
                hide: options.delay
            }
        }
        return options
    }
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {}
        var defaults = this.getDefaults()
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value
        })
        return options
    }
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type)
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data('bs.' + this.type, self)
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
        }
        if (self.tip().hasClass('in') || self.hoverState == 'in') {
            self.hoverState = 'in'
            return
        }
        clearTimeout(self.timeout)
        self.hoverState = 'in'
        if (!self.options.delay || !self.options.delay.show) return self.show()
        self.timeout = setTimeout(function() {
            if (self.hoverState == 'in') self.show()
        }, self.options.delay.show)
    }
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true
        }
        return false
    }
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type)
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data('bs.' + this.type, self)
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
        }
        if (self.isInStateTrue()) return
        clearTimeout(self.timeout)
        self.hoverState = 'out'
        if (!self.options.delay || !self.options.delay.hide) return self.hide()
        self.timeout = setTimeout(function() {
            if (self.hoverState == 'out') self.hide()
        }, self.options.delay.hide)
    }
    Tooltip.prototype.show = function() {
        var e = $.Event('show.bs.' + this.type)
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e)
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
            if (e.isDefaultPrevented() || !inDom) return
            var that = this
            var $tip = this.tip()
            var tipId = this.getUID(this.type)
            this.setContent()
            $tip.attr('id', tipId)
            this.$element.attr('aria-describedby', tipId)
            if (this.options.animation) $tip.addClass('fade')
            var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement
            var autoToken = /\s?auto?\s?/i
            var autoPlace = autoToken.test(placement)
            if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
            $tip.detach().css({
                top: 0,
                left: 0,
                display: 'block'
            }).addClass(placement).data('bs.' + this.type, this)
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
            this.$element.trigger('inserted.bs.' + this.type)
            var pos = this.getPosition()
            var actualWidth = $tip[0].offsetWidth
            var actualHeight = $tip[0].offsetHeight
            if (autoPlace) {
                var orgPlacement = placement
                var viewportDim = this.getPosition(this.$viewport)
                placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement
                $tip.removeClass(orgPlacement).addClass(placement)
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
            this.applyPlacement(calculatedOffset, placement)
            var complete = function() {
                var prevHoverState = that.hoverState
                that.$element.trigger('shown.bs.' + that.type)
                that.hoverState = null
                if (prevHoverState == 'out') that.leave(that)
            }
            $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        }
    }
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip()
        var width = $tip[0].offsetWidth
        var height = $tip[0].offsetHeight
        var marginTop = parseInt($tip.css('margin-top'), 10)
        var marginLeft = parseInt($tip.css('margin-left'), 10)
        if (isNaN(marginTop)) marginTop = 0
        if (isNaN(marginLeft)) marginLeft = 0
        offset.top += marginTop
        offset.left += marginLeft
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                })
            }
        }, offset), 0)
        $tip.addClass('in')
        var actualWidth = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight
        if (placement == 'top' && actualHeight != height) {
            offset.top = offset.top + height - actualHeight
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
        if (delta.left) offset.left += delta.left
        else offset.top += delta.top
        var isVertical = /top|bottom/.test(placement)
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
        $tip.offset(offset)
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    }
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '')
    }
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
        $tip.removeClass('fade in top bottom left right')
    }
    Tooltip.prototype.hide = function(callback) {
        var that = this
        var $tip = $(this.$tip)
        var e = $.Event('hide.bs.' + this.type)

        function complete() {
            if (that.hoverState != 'in') $tip.detach()
            if (that.$element) {
                that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type)
            }
            callback && callback()
        }
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip.removeClass('in')
        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        this.hoverState = null
        return this
    }
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
            $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
        }
    }
    Tooltip.prototype.hasContent = function() {
        return this.getTitle()
    }
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element
        var el = $element[0]
        var isBody = el.tagName == 'BODY'
        var elRect = el.getBoundingClientRect()
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            })
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : (isSvg ? null : $element.offset())
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        }
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null
        return $.extend({}, elRect, scroll, outerDims, elOffset)
    }
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        }
    }
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        }
        if (!this.$viewport) return delta
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
        var viewportDimensions = this.getPosition(this.$viewport)
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset
            } else if (rightEdgeOffset > viewportDimensions.right) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
            }
        }
        return delta
    }
    Tooltip.prototype.getTitle = function() {
        var title
        var $e = this.$element
        var o = this.options
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)
        return title
    }
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1000000)
        while (document.getElementById(prefix))
        return prefix
    }
    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template)
            if (this.$tip.length != 1) {
                throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
            }
        }
        return this.$tip
    }
    Tooltip.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
    }
    Tooltip.prototype.enable = function() {
        this.enabled = true
    }
    Tooltip.prototype.disable = function() {
        this.enabled = false
    }
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    }
    Tooltip.prototype.toggle = function(e) {
        var self = this
        if (e) {
            self = $(e.currentTarget).data('bs.' + this.type)
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions())
                $(e.currentTarget).data('bs.' + this.type, self)
            }
        }
        if (e) {
            self.inState.click = !self.inState.click
            if (self.isInStateTrue()) self.enter(self)
            else self.leave(self)
        } else {
            self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
        }
    }
    Tooltip.prototype.destroy = function() {
        var that = this
        clearTimeout(this.timeout)
        this.hide(function() {
            that.$element.off('.' + that.type).removeData('bs.' + that.type)
            if (that.$tip) {
                that.$tip.detach()
            }
            that.$tip = null
            that.$arrow = null
            that.$viewport = null
            that.$element = null
        })
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.tooltip')
            var options = typeof option == 'object' && option
            if (!data && /destroy|hide/.test(option)) return
            if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.tooltip
    $.fn.tooltip = Plugin
    $.fn.tooltip.Constructor = Tooltip
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old
        return this
    }
}(jQuery); + function($) {
    'use strict';
    var Popover = function(element, options) {
        this.init('popover', element, options)
    }
    if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
    Popover.VERSION = '3.3.7'
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    })
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
    Popover.prototype.constructor = Popover
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS
    }
    Popover.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()
        var content = this.getContent()
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
        $tip.find('.popover-content').children().detach().end()[this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'](content)
        $tip.removeClass('fade top bottom left right in')
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
    }
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    }
    Popover.prototype.getContent = function() {
        var $e = this.$element
        var o = this.options
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content)
    }
    Popover.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.popover')
            var options = typeof option == 'object' && option
            if (!data && /destroy|hide/.test(option)) return
            if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.popover
    $.fn.popover = Plugin
    $.fn.popover.Constructor = Popover
    $.fn.popover.noConflict = function() {
        $.fn.popover = old
        return this
    }
}(jQuery); + function($) {
    'use strict';

    function ScrollSpy(element, options) {
        this.$body = $(document.body)
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options)
        this.selector = (this.options.target || '') + ' .nav li > a'
        this.offsets = []
        this.targets = []
        this.activeTarget = null
        this.scrollHeight = 0
        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
        this.refresh()
        this.process()
    }
    ScrollSpy.VERSION = '3.3.7'
    ScrollSpy.DEFAULTS = {
        offset: 10
    }
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }
    ScrollSpy.prototype.refresh = function() {
        var that = this
        var offsetMethod = 'offset'
        var offsetBase = 0
        this.offsets = []
        this.targets = []
        this.scrollHeight = this.getScrollHeight()
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = 'position'
            offsetBase = this.$scrollElement.scrollTop()
        }
        this.$body.find(this.selector).map(function() {
            var $el = $(this)
            var href = $el.data('target') || $el.attr('href')
            var $href = /^#./.test(href) && $(href)
            return ($href && $href.length && $href.is(':visible') && [
                [$href[offsetMethod]().top + offsetBase, href]
            ]) || null
        }).sort(function(a, b) {
            return a[0] - b[0]
        }).each(function() {
            that.offsets.push(this[0])
            that.targets.push(this[1])
        })
    }
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
        var scrollHeight = this.getScrollHeight()
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
        var offsets = this.offsets
        var targets = this.targets
        var activeTarget = this.activeTarget
        var i
        if (this.scrollHeight != scrollHeight) {
            this.refresh()
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null
            return this.clear()
        }
        for (i = offsets.length; i--;) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i])
        }
    }
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target
        this.clear()
        var selector = this.selector + '[data-target="' + target + '"],' +
            this.selector + '[href="' + target + '"]'
        var active = $(selector).parents('li').addClass('active')
        if (active.parent('.dropdown-menu').length) {
            active = active.closest('li.dropdown').addClass('active')
        }
        active.trigger('activate.bs.scrollspy')
    }
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active')
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.scrollspy')
            var options = typeof option == 'object' && option
            if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.scrollspy
    $.fn.scrollspy = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old
        return this
    }
    $(window).on('load.bs.scrollspy.data-api', function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this)
            Plugin.call($spy, $spy.data())
        })
    })
}(jQuery); + function($) {
    'use strict';
    var Tab = function(element) {
        this.element = $(element)
    }
    Tab.VERSION = '3.3.7'
    Tab.TRANSITION_DURATION = 150
    Tab.prototype.show = function() {
        var $this = this.element
        var $ul = $this.closest('ul:not(.dropdown-menu)')
        var selector = $this.data('target')
        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '')
        }
        if ($this.parent('li').hasClass('active')) return
        var $previous = $ul.find('.active:last a')
        var hideEvent = $.Event('hide.bs.tab', {
            relatedTarget: $this[0]
        })
        var showEvent = $.Event('show.bs.tab', {
            relatedTarget: $previous[0]
        })
        $previous.trigger(hideEvent)
        $this.trigger(showEvent)
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
        var $target = $(selector)
        this.activate($this.closest('li'), $ul)
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: 'hidden.bs.tab',
                relatedTarget: $this[0]
            })
            $this.trigger({
                type: 'shown.bs.tab',
                relatedTarget: $previous[0]
            })
        })
    }
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find('> .active')
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

        function next() {
            $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false)
            element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true)
            if (transition) {
                element[0].offsetWidth
                element.addClass('in')
            } else {
                element.removeClass('fade')
            }
            if (element.parent('.dropdown-menu').length) {
                element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true)
            }
            callback && callback()
        }
        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next()
        $active.removeClass('in')
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.tab')
            if (!data) $this.data('bs.tab', (data = new Tab(this)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.tab
    $.fn.tab = Plugin
    $.fn.tab.Constructor = Tab
    $.fn.tab.noConflict = function() {
        $.fn.tab = old
        return this
    }
    var clickHandler = function(e) {
        e.preventDefault()
        Plugin.call($(this), 'show')
    }
    $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
}(jQuery); + function($) {
    'use strict';
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options)
        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this))
        this.$element = $(element)
        this.affixed = null
        this.unpin = null
        this.pinnedOffset = null
        this.checkPosition()
    }
    Affix.VERSION = '3.3.7'
    Affix.RESET = 'affix affix-top affix-bottom'
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    }
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        var targetHeight = this.$target.height()
        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
        if (this.affixed == 'bottom') {
            if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
            return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
        }
        var initializing = this.affixed == null
        var colliderTop = initializing ? scrollTop : position.top
        var colliderHeight = initializing ? targetHeight : height
        if (offsetTop != null && scrollTop <= offsetTop) return 'top'
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
        return false
    }
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset
        this.$element.removeClass(Affix.RESET).addClass('affix')
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        return (this.pinnedOffset = position.top - scrollTop)
    }
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1)
    }
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(':visible')) return
        var height = this.$element.height()
        var offset = this.options.offset
        var offsetTop = offset.top
        var offsetBottom = offset.bottom
        var scrollHeight = Math.max($(document).height(), $(document.body).height())
        if (typeof offset != 'object') offsetBottom = offsetTop = offset
        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element)
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css('top', '')
            var affixType = 'affix' + (affix ? '-' + affix : '')
            var e = $.Event(affixType + '.bs.affix')
            this.$element.trigger(e)
            if (e.isDefaultPrevented()) return
            this.affixed = affix
            this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
        }
        if (affix == 'bottom') {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            })
        }
    }

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.affix')
            var options = typeof option == 'object' && option
            if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }
    var old = $.fn.affix
    $.fn.affix = Plugin
    $.fn.affix.Constructor = Affix
    $.fn.affix.noConflict = function() {
        $.fn.affix = old
        return this
    }
    $(window).on('load', function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this)
            var data = $spy.data()
            data.offset = data.offset || {}
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
            if (data.offsetTop != null) data.offset.top = data.offsetTop
            Plugin.call($spy, data)
        })
    })
}(jQuery);;
jQuery(function($) {
    $.fn.authchoice = function(options) {
        options = $.extend({
            triggerSelector: 'a.auth-link',
            popup: {
                resizable: 'yes',
                scrollbars: 'no',
                toolbar: 'no',
                menubar: 'no',
                location: 'no',
                directories: 'no',
                status: 'yes',
                width: 450,
                height: 380
            }
        }, options);
        return this.each(function() {
            var $container = $(this);
            $container.find(options.triggerSelector).on('click', function(e) {
                e.preventDefault();
                var authChoicePopup = $container.data('authChoicePopup');
                if (authChoicePopup) {
                    authChoicePopup.close();
                }
                var url = this.href;
                var popupOptions = $.extend({}, options.popup);
                var localPopupWidth = this.getAttribute('data-popup-width');
                if (localPopupWidth) {
                    popupOptions.width = localPopupWidth;
                }
                var localPopupHeight = this.getAttribute('data-popup-height');
                if (localPopupWidth) {
                    popupOptions.height = localPopupHeight;
                }
                popupOptions.left = (window.screen.width - popupOptions.width) / 2;
                popupOptions.top = (window.screen.height - popupOptions.height) / 2;
                var popupFeatureParts = [];
                for (var propName in popupOptions) {
                    if (popupOptions.hasOwnProperty(propName)) {
                        popupFeatureParts.push(propName + '=' + popupOptions[propName]);
                    }
                }
                var popupFeature = popupFeatureParts.join(',');
                authChoicePopup = window.open(url, 'yii_auth_choice', popupFeature);
                authChoicePopup.focus();
                $container.data('authChoicePopup', authChoicePopup);
            });
        });
    };
});;

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
        }
        return arr2;
    }
}

function _extends() {
    _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
(function(global, factory) {
    (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.LazyLoad = factory();
})(this, function() {
    'use strict';
    var runningOnBrowser = typeof window !== "undefined";
    var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
    var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    var supportsClassList = runningOnBrowser && "classList" in document.createElement("p");
    var defaultSettings = {
        elements_selector: "img",
        container: isBot || runningOnBrowser ? document : null,
        threshold: 300,
        thresholds: null,
        data_src: "src",
        data_srcset: "srcset",
        data_sizes: "sizes",
        data_bg: "bg",
        class_loading: "loading",
        class_loaded: "loaded",
        class_error: "error",
        load_delay: 0,
        auto_unobserve: true,
        callback_enter: null,
        callback_exit: null,
        callback_reveal: null,
        callback_loaded: null,
        callback_error: null,
        callback_finish: null,
        use_native: false
    };
    var getInstanceSettings = function getInstanceSettings(customSettings) {
        return _extends({}, defaultSettings, customSettings);
    };
    var createInstance = function createInstance(classObj, options) {
        var event;
        var eventString = "LazyLoad::Initialized";
        var instance = new classObj(options);
        try {
            event = new CustomEvent(eventString, {
                detail: {
                    instance: instance
                }
            });
        } catch (err) {
            event = document.createEvent("CustomEvent");
            event.initCustomEvent(eventString, false, false, {
                instance: instance
            });
        }
        window.dispatchEvent(event);
    };

    function autoInitialize(classObj, options) {
        if (!options) {
            return;
        }
        if (!options.length) {
            createInstance(classObj, options);
        } else {
            for (var i = 0, optionsItem; optionsItem = options[i]; i += 1) {
                createInstance(classObj, optionsItem);
            }
        }
    }
    var dataPrefix = "data-";
    var processedDataName = "was-processed";
    var timeoutDataName = "ll-timeout";
    var trueString = "true";
    var getData = function getData(element, attribute) {
        return element.getAttribute(dataPrefix + attribute);
    };
    var setData = function setData(element, attribute, value) {
        var attrName = dataPrefix + attribute;
        if (value === null) {
            element.removeAttribute(attrName);
            return;
        }
        element.setAttribute(attrName, value);
    };
    var resetWasProcessedData = function resetWasProcessedData(element) {
        return setData(element, processedDataName, null);
    };
    var setWasProcessedData = function setWasProcessedData(element) {
        return setData(element, processedDataName, trueString);
    };
    var getWasProcessedData = function getWasProcessedData(element) {
        return getData(element, processedDataName) === trueString;
    };
    var setTimeoutData = function setTimeoutData(element, value) {
        return setData(element, timeoutDataName, value);
    };
    var getTimeoutData = function getTimeoutData(element) {
        return getData(element, timeoutDataName);
    };
    var purgeProcessedElements = function purgeProcessedElements(elements) {
        return elements.filter(function(element) {
            return !getWasProcessedData(element);
        });
    };
    var purgeOneElement = function purgeOneElement(elements, elementToPurge) {
        return elements.filter(function(element) {
            return element !== elementToPurge;
        });
    };
    var safeCallback = function safeCallback(callback, arg1, arg2, arg3) {
        if (!callback) {
            return;
        }
        if (arg3 !== undefined) {
            callback(arg1, arg2, arg3);
            return;
        }
        if (arg2 !== undefined) {
            callback(arg1, arg2);
            return;
        }
        callback(arg1);
    };
    var updateLoadingCount = function updateLoadingCount(instance, plusMinus) {
        instance._loadingCount += plusMinus;
        if (instance._elements.length === 0 && instance._loadingCount === 0) {
            safeCallback(instance._settings.callback_finish, instance);
        }
    };
    var getSourceTags = function getSourceTags(parentTag) {
        var sourceTags = [];
        for (var i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
            if (childTag.tagName === "SOURCE") {
                sourceTags.push(childTag);
            }
        }
        return sourceTags;
    };
    var setAttributeIfValue = function setAttributeIfValue(element, attrName, value) {
        if (!value) {
            return;
        }
        element.setAttribute(attrName, value);
    };
    var setImageAttributes = function setImageAttributes(element, settings) {
        setAttributeIfValue(element, "sizes", getData(element, settings.data_sizes));
        setAttributeIfValue(element, "srcset", getData(element, settings.data_srcset));
        setAttributeIfValue(element, "src", getData(element, settings.data_src));
    };
    var setSourcesImg = function setSourcesImg(element, settings) {
        var parent = element.parentNode;
        if (parent && parent.tagName === "PICTURE") {
            var sourceTags = getSourceTags(parent);
            sourceTags.forEach(function(sourceTag) {
                setImageAttributes(sourceTag, settings);
            });
        }
        setImageAttributes(element, settings);
    };
    var setSourcesIframe = function setSourcesIframe(element, settings) {
        setAttributeIfValue(element, "src", getData(element, settings.data_src));
    };
    var setSourcesVideo = function setSourcesVideo(element, settings) {
        var sourceTags = getSourceTags(element);
        sourceTags.forEach(function(sourceTag) {
            setAttributeIfValue(sourceTag, "src", getData(sourceTag, settings.data_src));
        });
        setAttributeIfValue(element, "src", getData(element, settings.data_src));
        element.load();
    };
    var setSourcesBgImage = function setSourcesBgImage(element, settings) {
        var srcDataValue = getData(element, settings.data_src);
        var bgDataValue = getData(element, settings.data_bg);
        if (srcDataValue) {
            element.style.backgroundImage = "url(\"".concat(srcDataValue, "\")");
        }
        if (bgDataValue) {
            element.style.backgroundImage = bgDataValue;
        }
    };
    var setSourcesFunctions = {
        IMG: setSourcesImg,
        IFRAME: setSourcesIframe,
        VIDEO: setSourcesVideo
    };
    var setSources = function setSources(element, instance) {
        var settings = instance._settings;
        var tagName = element.tagName;
        var setSourcesFunction = setSourcesFunctions[tagName];
        if (setSourcesFunction) {
            setSourcesFunction(element, settings);
            updateLoadingCount(instance, 1);
            instance._elements = purgeOneElement(instance._elements, element);
            return;
        }
        setSourcesBgImage(element, settings);
    };
    var addClass = function addClass(element, className) {
        if (supportsClassList) {
            element.classList.add(className);
            return;
        }
        element.className += (element.className ? " " : "") + className;
    };
    var removeClass = function removeClass(element, className) {
        if (supportsClassList) {
            element.classList.remove(className);
            return;
        }
        element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
    };
    var genericLoadEventName = "load";
    var mediaLoadEventName = "loadeddata";
    var errorEventName = "error";
    var addEventListener = function addEventListener(element, eventName, handler) {
        element.addEventListener(eventName, handler);
    };
    var removeEventListener = function removeEventListener(element, eventName, handler) {
        element.removeEventListener(eventName, handler);
    };
    var addEventListeners = function addEventListeners(element, loadHandler, errorHandler) {
        addEventListener(element, genericLoadEventName, loadHandler);
        addEventListener(element, mediaLoadEventName, loadHandler);
        addEventListener(element, errorEventName, errorHandler);
    };
    var removeEventListeners = function removeEventListeners(element, loadHandler, errorHandler) {
        removeEventListener(element, genericLoadEventName, loadHandler);
        removeEventListener(element, mediaLoadEventName, loadHandler);
        removeEventListener(element, errorEventName, errorHandler);
    };
    var eventHandler = function eventHandler(event, success, instance) {
        var settings = instance._settings;
        var className = success ? settings.class_loaded : settings.class_error;
        var callback = success ? settings.callback_loaded : settings.callback_error;
        var element = event.target;
        removeClass(element, settings.class_loading);
        addClass(element, className);
        safeCallback(callback, element, instance);
        updateLoadingCount(instance, -1);
    };
    var addOneShotEventListeners = function addOneShotEventListeners(element, instance) {
        var loadHandler = function loadHandler(event) {
            eventHandler(event, true, instance);
            removeEventListeners(element, loadHandler, errorHandler);
        };
        var errorHandler = function errorHandler(event) {
            eventHandler(event, false, instance);
            removeEventListeners(element, loadHandler, errorHandler);
        };
        addEventListeners(element, loadHandler, errorHandler);
    };
    var managedTags = ["IMG", "IFRAME", "VIDEO"];
    var onEnter = function onEnter(element, entry, instance) {
        var settings = instance._settings;
        safeCallback(settings.callback_enter, element, entry, instance);
        if (!settings.load_delay) {
            revealAndUnobserve(element, instance);
            return;
        }
        delayLoad(element, instance);
    };
    var revealAndUnobserve = function revealAndUnobserve(element, instance) {
        var observer = instance._observer;
        revealElement(element, instance);
        if (observer && instance._settings.auto_unobserve) {
            observer.unobserve(element);
        }
    };
    var onExit = function onExit(element, entry, instance) {
        var settings = instance._settings;
        safeCallback(settings.callback_exit, element, entry, instance);
        if (!settings.load_delay) {
            return;
        }
        cancelDelayLoad(element);
    };
    var cancelDelayLoad = function cancelDelayLoad(element) {
        var timeoutId = getTimeoutData(element);
        if (!timeoutId) {
            return;
        }
        clearTimeout(timeoutId);
        setTimeoutData(element, null);
    };
    var delayLoad = function delayLoad(element, instance) {
        var loadDelay = instance._settings.load_delay;
        var timeoutId = getTimeoutData(element);
        if (timeoutId) {
            return;
        }
        timeoutId = setTimeout(function() {
            revealAndUnobserve(element, instance);
            cancelDelayLoad(element);
        }, loadDelay);
        setTimeoutData(element, timeoutId);
    };
    var revealElement = function revealElement(element, instance, force) {
        var settings = instance._settings;
        if (!force && getWasProcessedData(element)) {
            return;
        }
        if (managedTags.indexOf(element.tagName) > -1) {
            addOneShotEventListeners(element, instance);
            addClass(element, settings.class_loading);
        }
        setSources(element, instance);
        setWasProcessedData(element);
        safeCallback(settings.callback_reveal, element, instance);
        safeCallback(settings.callback_set, element, instance);
    };
    var isIntersecting = function isIntersecting(entry) {
        return entry.isIntersecting || entry.intersectionRatio > 0;
    };
    var getObserverSettings = function getObserverSettings(settings) {
        return {
            root: settings.container === document ? null : settings.container,
            rootMargin: settings.thresholds || settings.threshold + "px"
        };
    };
    var setObserver = function setObserver(instance) {
        if (!supportsIntersectionObserver) {
            return false;
        }
        instance._observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                return isIntersecting(entry) ? onEnter(entry.target, entry, instance) : onExit(entry.target, entry, instance);
            });
        }, getObserverSettings(instance._settings));
        return true;
    };
    var nativeLazyTags = ["IMG", "IFRAME"];
    var shouldUseNative = function shouldUseNative(settings) {
        return settings.use_native && "loading" in HTMLImageElement.prototype;
    };
    var loadAllNative = function loadAllNative(instance) {
        instance._elements.forEach(function(element) {
            if (nativeLazyTags.indexOf(element.tagName) === -1) {
                return;
            }
            element.setAttribute("loading", "lazy");
            revealElement(element, instance);
        });
    };
    var nodeSetToArray = function nodeSetToArray(nodeSet) {
        return Array.prototype.slice.call(nodeSet);
    };
    var queryElements = function queryElements(settings) {
        return settings.container.querySelectorAll(settings.elements_selector);
    };
    var getElements = function getElements(elements, settings) {
        return purgeProcessedElements(nodeSetToArray(elements || queryElements(settings)));
    };
    var retryLazyLoad = function retryLazyLoad(instance) {
        var settings = instance._settings;
        var errorElements = settings.container.querySelectorAll("." + settings.class_error);
        _toConsumableArray(errorElements).forEach(function(element) {
            removeClass(element, settings.class_error);
            resetWasProcessedData(element);
        });
        instance.update();
    };
    var setOnlineCheck = function setOnlineCheck(instance) {
        if (!runningOnBrowser) {
            return;
        }
        window.addEventListener("online", function(event) {
            retryLazyLoad(instance);
        });
    };
    var LazyLoad = function LazyLoad(customSettings, elements) {
        this._settings = getInstanceSettings(customSettings);
        this._loadingCount = 0;
        setObserver(this);
        this.update(elements);
        setOnlineCheck(this);
    };
    LazyLoad.prototype = {
        update: function update(elements) {
            var _this = this;
            var settings = this._settings;
            this._elements = getElements(elements, settings);
            if (isBot || !this._observer) {
                this.loadAll();
                return;
            }
            if (shouldUseNative(settings)) {
                loadAllNative(this);
                this._elements = getElements(elements, settings);
            }
            this._elements.forEach(function(element) {
                _this._observer.observe(element);
            });
        },
        destroy: function destroy() {
            var _this2 = this;
            if (this._observer) {
                this._elements.forEach(function(element) {
                    _this2._observer.unobserve(element);
                });
                this._observer = null;
            }
            this._elements = null;
            this._settings = null;
        },
        load: function load(element, force) {
            revealElement(element, this, force);
        },
        loadAll: function loadAll() {
            var _this3 = this;
            this._elements.forEach(function(element) {
                revealAndUnobserve(element, _this3);
            });
        }
    };
    if (runningOnBrowser) {
        autoInitialize(LazyLoad, window.lazyLoadOptions);
    }
    return LazyLoad;
});;
(function(e) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], e)
    } else {
        e(jQuery)
    }
})(function(e) {
    function n(e) {
        return u.raw ? e : encodeURIComponent(e)
    }

    function r(e) {
        return u.raw ? e : decodeURIComponent(e)
    }

    function i(e) {
        return n(u.json ? JSON.stringify(e) : String(e))
    }

    function s(e) {
        if (e.indexOf('"') === 0) {
            e = e.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\")
        }
        try {
            e = decodeURIComponent(e.replace(t, " "));
            return u.json ? JSON.parse(e) : e
        } catch (n) {}
    }

    function o(t, n) {
        var r = u.raw ? t : s(t);
        return e.isFunction(n) ? n(r) : r
    }
    var t = /\+/g;
    var u = e.cookie = function(t, s, a) {
        if (s !== undefined && !e.isFunction(s)) {
            a = e.extend({}, u.defaults, a);
            if (typeof a.expires === "number") {
                var f = a.expires,
                    l = a.expires = new Date;
                l.setTime(+l + f * 864e5)
            }
            return document.cookie = [n(t), "=", i(s), a.expires ? "; expires=" + a.expires.toUTCString() : "", a.path ? "; path=" + a.path : "", a.domain ? "; domain=" + a.domain : "", a.secure ? "; secure" : ""].join("")
        }
        var c = t ? undefined : {};
        var h = document.cookie ? document.cookie.split("; ") : [];
        for (var p = 0, d = h.length; p < d; p++) {
            var v = h[p].split("=");
            var m = r(v.shift());
            var g = v.join("=");
            if (t && t === m) {
                c = o(g, s);
                break
            }
            if (!t && (g = o(g)) !== undefined) {
                c[m] = g
            }
        }
        return c
    };
    u.defaults = {};
    e.removeCookie = function(t, n) {
        if (e.cookie(t) === undefined) {
            return false
        }
        e.cookie(t, "", e.extend({}, n, {
            expires: -1
        }));
        return !e.cookie(t)
    }
});
String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
jQuery.wordStats = {
    unsortedWords: null,
    latinOnly: true,
    sortedWords: null,
    keywords: 1,
    topWords: null,
    topWeights: null,
    _computed: false,
    useStopWords: true,
    filterWords: function(str) {
        var returnWords = [];
        str = str.trim();
        if (str && str.length > 1) {
            var words = this.splitWords(str.toLowerCase());
            for (var i = 0; i < words.length; i++) {
                var word = words[i];
                if (word.slice(-1) == "'") {
                    word = word.replaceAll("'", '');
                }
                if (word.slice(0, 1) == "'") {
                    word = word.replaceAll("'", '');
                }
                word = word.replaceAll("–", '-');
                if ((word.length > 1 || (word.length == 1 && (word.toLowerCase() == 'i' || word.toLowerCase() == 'a'))) && (!this.stopWords[word] || this.useStopWords == true) && isNumeric(word) == false) {
                    returnWords.push(word)
                }
            }
        }
        return returnWords;
    },
    splitSentences: function(str) {
        return str.split(/[.!?\n]/);
    },
    createNGrams: function(words) {
        var ngrams = [];
        for (var i = 0; i < words.length - (this.keywords - 1); i++) {
            var ngram = [];
            for (var j = 0; j < this.keywords; j++) {
                ngram.push(words[j + i]);
            }
            ngrams.push(ngram.join(" "));
        }
        return ngrams;
    },
    addWords: function(str, weight) {
        var sentences = this.splitSentences(str);
        for (var i = 0; i < sentences.length; i++) {
            var filteredWords = this.filterWords(sentences[i]);
            var ngramArray = this.createNGrams(filteredWords);
            this.countNGrams(ngramArray, weight);
        }
    },
    countNGrams: function(ngrams, weight) {
        for (var x = 0, y = ngrams.length; x < y; x++) {
            var ngram = ngrams[x];
            if (this.unsortedWords[ngram]) {
                this.unsortedWords[ngram].weight += weight;
            } else {
                this.unsortedWords[ngram] = {
                    'word': ngram,
                    'weight': weight
                };
            }
        }
    },
    addWordsFromTextNodes: function(node, weight) {
        var nodes = node.childNodes;
        for (var i = 0, j = nodes.length; i < j; i++) {
            if (nodes[i].nodeType == 3) this.addWords(nodes[i].nodeValue, weight);
        }
    },
    testChar: function(c) {
        if (this.latinOnly == true) {
            return ((c == 39) || (c >= 97 && c <= 122) || (c >= 128 && c <= 151) || (c >= 160 && c <= 164) || (c >= 48 && c <= 57) || (c >= 224 && c <= 246) || (c >= 249 && c <= 255) || c == 8211 || c == 45);
        } else {
            return c != 32 && c != 33 && c != 8217 && c != 8592 && c != 34 && c != 35 && c != 36 && c != 37 && c != 38 && c != 40 && c != 41 && c != 42 && c != 43 && c != 44 && c != 45 && c != 46 && c != 47 && c != 58 && c != 59 && c != 60 && c != 61 && c != 62 && c != 63;
        }
    },
    splitWords: function(words) {
        var w = new Array(),
            str = '';
        for (var i = 0, j = words.length; i < j; i++) {
            c = words.charCodeAt(i);
            if (this.testChar(c)) {
                str += words.substring(i, i + 1);
            } else {
                w.push(str);
                str = '';
            }
        }
        if (str.length > 0) w.push(str);
        return (w);
    },
    computeWords: function(elem) {
        if (!elem) elem = window.document;
        this.unsortedWords = {};
        if (elem.is("textarea")) {
            var text = editor.replaceDivToEn(elem.val());
            text = text.replace(/\s\-+/g, ' ').replace(/\-+\s/g, ' ').replaceAll("’", "'").replaceAll("‘", "'").replaceAll("“", '"').replaceAll("”", '"').replaceAll("–", '-').replaceAll("…", '...');
            this.addWords(text, 1);
            return;
        } else if (elem.is("div[contenteditable='true']") || elem.is("div[contenteditable='false']")) {
            var text = elem.html();
            text = text.replace(/<br\s*[\/]?>/gi, " \n").replace(/<div>/gi, " \n").replace(/<\s*[\/]?div>/gi, "").replace(/&nbsp;/gi, " ").replace(/&amp;/gi, "");
            var tmp = document.createElement("DIV");
            text = text.replace(/&lt;/gi, ' <').replace(/&gt;/gi, '>');
            tmp.innerHTML = text;
            text = tmp.textContent || tmp.innerText || "";
            this.addWords(text, 1);
            return;
        }
        this.addWords($('title', elem).text(), 20);
        wordstats = this;
        $('h1', elem).each(function() {
            wordstats.addWordsFromTextNodes($(this).get(0), 15);
        });
        $('h2', elem).each(function() {
            wordstats.addWordsFromTextNodes($(this).get(0), 10);
        });
        $('h3, h4, h5, h6', elem).each(function() {
            wordstats.addWordsFromTextNodes($(this).get(0), 5);
        });
        $('strong, b, em, i', elem).each(function() {
            wordstats.addWordsFromTextNodes($(this).get(0), 3);
        });
        $('p, div, th, td, li, a, span', elem).each(function() {
            wordstats.addWordsFromTextNodes($(this).get(0), 2);
        });
        $('img', elem).each(function() {
            wordstats.addWords($(this).attr('alt'), 1);
            wordstats.addWords($(this).attr('title'), 1);
        });
        this._computed = true;
    },
    computeTopWords: function(count, elem) {
        if (!this._computed) {
            this.computeWords(elem);
        }
        this.topWords = [];
        this.topWeights = [];
        this.sortWords();
        for (var i = 0; i < Math.min(count, this.sortedWords.length); i++) {
            this.topWords.push(this.sortedWords[i].word);
            this.topWeights.push(this.sortedWords[i].weight);
        }
    },
    sortWords: function() {
        this.sortedWords = [];
        for (word in this.unsortedWords) {
            this.sortedWords.push(this.unsortedWords[word]);
        }
        this.sortedWords.sort(function(a, b) {
            if (a.weight < b.weight) {
                return 1
            } else if (a.weight > b.weight) {
                return -1
            } else {
                return 0
            }
        });
    },
    clear: function() {
        this.unsortedWords = this.sortedWords = this.topWords = this.topWeights = null;
        this._computed = false;
    }
};
jQuery.wordStats.stopWords = {
    "1": true,
    "2": true,
    "3": true,
    "4": true,
    "5": true,
    "6": true,
    "7": true,
    "8": true,
    "9": true,
    "a": true,
    "b": true,
    "c": true,
    "d": true,
    "e": true,
    "f": true,
    "g": true,
    "h": true,
    "i": true,
    "j": true,
    "&": true,
    "am": true,
    "an": true,
    "and": true,
    "are": true,
    "aren't": true,
    "as": true,
    "at": true,
    "be": true,
    "but": true,
    "by": true,
    "can": true,
    "cannot": true,
    "cant": true,
    "can't": true,
    "does": true,
    "doesn't": true,
    "doing": true,
    "done": true,
    "don't": true,
    "did": true,
    "didn't": true,
    "do": true,
    "etc": true,
    "ex": true,
    "for": true,
    "from": true,
    "got": true,
    "had": true,
    "hadn't": true,
    "has": true,
    "hasn't": true,
    "have": true,
    "haven't": true,
    "having": true,
    "he": true,
    "he'd": true,
    "he'll": true,
    "her": true,
    "hers": true,
    "herself": true,
    "he's": true,
    "him": true,
    "himself": true,
    "his": true,
    "i'd": true,
    "if": true,
    "i'll": true,
    "i'm": true,
    "in": true,
    "into": true,
    "is": true,
    "isn't": true,
    "it": true,
    "it'd": true,
    "it'll": true,
    "its": true,
    "it's": true,
    "itself": true,
    "i've": true,
    "me": true,
    "mr": true,
    "mrs": true,
    "my": true,
    "myself": true,
    "no": true,
    "not": true,
    "of": true,
    "off": true,
    "oh": true,
    "ok": true,
    "okay": true,
    "on": true,
    "or": true,
    "our": true,
    "ours": true,
    "ourselves": true,
    "out": true,
    "per": true,
    "said": true,
    "she": true,
    "she'd": true,
    "she'll": true,
    "she's": true,
    "so": true,
    "than": true,
    "that": true,
    "that'll": true,
    "thats": true,
    "that's": true,
    "that've": true,
    "the": true,
    "their": true,
    "theirs": true,
    "them": true,
    "themselves": true,
    "then": true,
    "there": true,
    "there'd": true,
    "there'll": true,
    "there's": true,
    "these": true,
    "they": true,
    "they'd": true,
    "they'll": true,
    "they're": true,
    "they've": true,
    "this": true,
    "those": true,
    "to": true,
    "too": true,
    "up": true,
    "us": true,
    "use": true,
    "used": true,
    "uses": true,
    "was": true,
    "wasn't": true,
    "way": true,
    "we": true,
    "we'd": true,
    "well": true,
    "we'll": true,
    "went": true,
    "were": true,
    "we're": true,
    "weren't": true,
    "we've": true,
    "what": true,
    "what's": true,
    "where": true,
    "where's": true,
    "which": true,
    "who": true,
    "who'd": true,
    "who'll": true,
    "who's": true,
    "whose": true,
    "why": true,
    "will": true,
    "with": true,
    "won't": true,
    "would": true,
    "wouldn't": true,
    "yes": true,
    "yet": true,
    "you": true,
    "you'd": true,
    "you'll": true,
    "your": true,
    "you're": true,
    "yours": true,
    "yourself": true,
    "yourselves": true,
    "you've": true,
    'liam': true,
    'noah': true,
    'ethan': true,
    'mason': true,
    'lucas': true,
    'logan': true,
    'oliver': true,
    'jackson': true,
    'aiden': true,
    'jacob': true,
    'elijah': true,
    'james': true,
    'benjamin': true,
    'alexander': true,
    'jack': true,
    'luke': true,
    'carter': true,
    'william': true,
    'michael': true,
    'daniel': true,
    'owen': true,
    'gabriel': true,
    'henry': true,
    'matthew': true,
    'wyatt': true,
    'jayden': true,
    'nathan': true,
    'isaac': true,
    'caleb': true,
    'ryan': true,
    'sebastian': true,
    'andrew': true,
    'david': true,
    'dylan': true,
    'connor': true,
    'samuel': true,
    'jaxon': true,
    'eli': true,
    'grayson': true,
    'joshua': true,
    'hunter': true,
    'landon': true,
    'levi': true,
    'joseph': true,
    'anthony': true,
    'julian': true,
    'max': true,
    'john': true,
    'adam': true,
    'cameron': true,
    'gavin': true,
    'christian': true,
    'evan': true,
    'isaiah': true,
    'leo': true,
    'lincoln': true,
    'nolan': true,
    'thomas': true,
    'hudson': true,
    'dominic': true,
    'brayden': true,
    'christopher': true,
    'colton': true,
    'parker': true,
    'austin': true,
    'aaron': true,
    'nicholas': true,
    'muhammad': true,
    'adrian': true,
    'tyler': true,
    'cooper': true,
    'josiah': true,
    'chase': true,
    'jonathan': true,
    'jace': true,
    'asher': true,
    'jeremiah': true,
    'jordan': true,
    'ian': true,
    'jaxson': true,
    'alex': true,
    'easton': true,
    'zachary': true,
    'ezra': true,
    'carson': true,
    'miles': true,
    'blake': true,
    'xavier': true,
    'declan': true,
    'cole': true,
    'tristan': true,
    'nathaniel': true,
    'ayden': true,
    'micah': true,
    'ryder': true,
    'brody': true,
    'harrison': true,
    'jason': true,
    'camden': true,
    'elias': true,
    'roman': true,
    'mateo': true,
    'greyson': true,
    'luca': true,
    'kai': true,
    'kayden': true,
    'vincent': true,
    'robert': true,
    'bentley': true,
    'bryce': true,
    'jude': true,
    'brandon': true,
    'jonah': true,
    'emmett': true,
    'everett': true,
    'wesley': true,
    'weston': true,
    'silas': true,
    'jake': true,
    'finn': true,
    'ben': true,
    'charles': true,
    'jameson': true,
    'santiago': true,
    'leonardo': true,
    'george': true,
    'theodore': true,
    'kaiden': true,
    'bennett': true,
    'xander': true,
    'maddox': true,
    'riley': true,
    'damian': true,
    'colin': true,
    'maxwell': true,
    'brantley': true,
    'marcus': true,
    'sam': true,
    'jax': true,
    'graham': true,
    'aidan': true,
    'ashton': true,
    'braxton': true,
    'theo': true,
    'jayce': true,
    'abel': true,
    'caden': true,
    'bryson': true,
    'kingston': true,
    'bradley': true,
    'calvin': true,
    'kyle': true,
    'ryker': true,
    'kaden': true,
    'nicolas': true,
    'patrick': true,
    'kaleb': true,
    'malachi': true,
    'angel': true,
    'preston': true,
    'dean': true,
    'eric': true,
    'miguel': true,
    'antonio': true,
    'giovanni': true,
    'conner': true,
    'avery': true,
    'elliott': true,
    'ezekiel': true,
    'justin': true,
    'kevin': true,
    'sean': true,
    'grant': true,
    'omar': true,
    'aj ': true,
    'ali': true,
    'brady': true,
    'ivan': true,
    'axel': true,
    'juan': true,
    'elliot': true,
    'matteo': true,
    'diego': true,
    'maverick': true,
    'lorenzo': true,
    'arthur': true,
    'cayden': true,
    'joel': true,
    'enzo': true,
    'rowan': true,
    'jose': true,
    'luis': true,
    'tucker': true,
    'paul': true,
    'jaden': true,
    'jase': true,
    'oscar': true,
    'beau': true,
    'beckett': true,
    'zane': true,
    'myles': true,
    'august': true,
    'karter': true,
    'timothy': true,
    'jasper': true,
    'felix': true,
    'jesse': true,
    'rylan': true,
    'tanner': true,
    'lukas': true,
    'simon': true,
    'mark': true,
    'maximus': true,
    'richard': true,
    'judah': true,
    'edward': true,
    'amir': true,
    'carlos': true,
    'victor': true,
    'cash': true,
    'peter': true,
    'river': true,
    'zander': true,
    'zion': true,
    'emmanuel': true,
    'griffin': true,
    'leon': true,
    'joey': true,
    'jeremy': true,
    'reid': true,
    'zayden': true,
    'corbin': true,
    'rafael': true,
    'brooks': true,
    'alejandro': true,
    'archer': true,
    'seth': true,
    'caiden': true,
    'milo': true,
    'drew': true,
    'gage': true,
    'paxton': true,
    'dante': true,
    'garrett': true,
    'spencer': true,
    'brian': true,
    'ahmad': true,
    'damien': true,
    'derek': true,
    'mohammed': true,
    'emma': true,
    'olivia': true,
    'sophia': true,
    'ava': true,
    'mia': true,
    'isabella': true,
    'charlotte': true,
    'amelia': true,
    'harper': true,
    'madison': true,
    'emily': true,
    'abigail': true,
    'lily': true,
    'ella': true,
    'sofia': true,
    'chloe': true,
    'evelyn': true,
    'aria': true,
    'aubrey': true,
    'scarlett': true,
    'ellie': true,
    'zoey': true,
    'hannah': true,
    'zoe': true,
    'grace': true,
    'addison': true,
    'elizabeth': true,
    'audrey': true,
    'mila': true,
    'nora': true,
    'layla': true,
    'victoria': true,
    'natalie': true,
    'lillian': true,
    'lucy': true,
    'penelope': true,
    'brooklyn': true,
    'claire': true,
    'savannah': true,
    'violet': true,
    'anna': true,
    'stella': true,
    'leah': true,
    'maya': true,
    'alice': true,
    'skylar': true,
    'samantha': true,
    'maria': true,
    'eva': true,
    'sarah': true,
    'sophie': true,
    'hailey': true,
    'kennedy': true,
    'julia': true,
    'sadie': true,
    'hazel': true,
    'madelyn': true,
    'paisley': true,
    'mackenzie': true,
    'eleanor': true,
    'aaliyah': true,
    'gabriella': true,
    'caroline': true,
    'kylie': true,
    'peyton': true,
    'piper': true,
    'ariana': true,
    'bella': true,
    'kaylee': true,
    'arianna': true,
    'cora': true,
    'clara': true,
    'taylor': true,
    'isabelle': true,
    'camila': true,
    'autumn': true,
    'quinn': true,
    'alyssa': true,
    'annabelle': true,
    'lydia': true,
    'emilia': true,
    'isla': true,
    'alexa': true,
    'allison': true,
    'aurora': true,
    'naomi': true,
    'ruby': true,
    'valentina': true,
    'elena': true,
    'alexis': true,
    'gianna': true,
    'madeline': true,
    'luna': true,
    'aubree': true,
    'lilly': true,
    'eliana': true,
    'hadley': true,
    'sydney': true,
    'reagan': true,
    'vivian': true,
    'serenity': true,
    'bailey': true,
    'rylee': true,
    'kayla': true,
    'faith': true,
    'alexandra': true,
    'willow': true,
    'isabel': true,
    'lyla': true,
    'liliana': true,
    'brielle': true,
    'morgan': true,
    'ivy': true,
    'kinsley': true,
    'nevaeh': true,
    'molly': true,
    'jade': true,
    'sara': true,
    'london': true,
    'adalyn': true,
    'lauren': true,
    'natalia': true,
    'kate': true,
    'paige': true,
    'brooke': true,
    'emery': true,
    'delilah': true,
    'ana': true,
    'adeline': true,
    'khloe': true,
    'melody': true,
    'jasmine': true,
    'arya': true,
    'gracie': true,
    'everly': true,
    'jordyn': true,
    'eden': true,
    'adalynn': true,
    'charlie': true,
    'norah': true,
    'athena': true,
    'melanie': true,
    'maggie': true,
    'elise': true,
    'mya': true,
    'reese': true,
    'laila': true,
    'jocelyn': true,
    'abby': true,
    'eliza': true,
    'katherine': true,
    'josephine': true,
    'kendall': true,
    'sienna': true,
    'rose': true,
    'mary': true,
    'payton': true,
    'brianna': true,
    'lola': true,
    'makayla': true,
    'andrea': true,
    'mckenzie': true,
    'callie': true,
    'ariel': true,
    'alaina': true,
    'lila': true,
    'juliana': true,
    'gabrielle': true,
    'hayden': true,
    'emerson': true,
    'tessa': true,
    'adelyn': true,
    'arabella': true,
    'nicole': true,
    'evie': true,
    'alana': true,
    'cecilia': true,
    'genevieve': true,
    'trinity': true,
    'alina': true,
    'nur': true,
    'nina': true,
    'laura': true,
    'lucia': true,
    'genesis': true,
    'leilani': true,
    'presley': true,
    'kaitlyn': true,
    'teagan': true,
    'leila': true,
    'finley': true,
    'juliette': true,
    'alexandria': true,
    'summer': true,
    'aliyah': true,
    'josie': true,
    'keira': true,
    'ryleigh': true,
    'fiona': true,
    'julianna': true,
    'alayna': true,
    'mariah': true,
    'marley': true,
    'anastasia': true,
    'brooklynn': true,
    'helena': true,
    'iris': true,
    'adriana': true,
    'makenzie': true,
    'lexi': true,
    'amaya': true,
    'valerie': true,
    'londyn': true,
    'eloise': true,
    'talia': true,
    'rebecca': true,
    'georgia': true,
    'vivienne': true,
    'olive': true,
    'rachel': true,
    'delaney': true,
    'kinley': true,
    'mikayla': true,
    'katelyn': true,
    'nova': true,
    'allie': true,
    'daisy': true,
    'evangeline': true,
    'harmony': true,
    'zara': true,
    'lana': true,
    'ayla': true,
    'camille': true,
    'lara': true,
    'sawyer': true,
    'lena': true,
    'mckenna': true,
    'katie': true,
    'kenzie': true,
    'raelynn': true,
    'alivia': true,
    'gabriela': true,
    'maryam': true,
    'anaya': true,
    'brynn': true,
    'noelle': true,
    'phoebe': true,
    'angelina': true,
    'gia': true,
    'erin': true
};
jQuery.wordStats.whiteList = {
    'U.S.A.': true,
    'U.S.': true
};;
jQuery.extend({
    highlight: function(node, re, nodeName, className) {
        if (node.nodeType === 3) {
            var match = node.data.match(re);
            if (match) {
                var highlight = document.createElement(nodeName || 'span');
                highlight.className = className || 'highlight';
                var wordNode = node.splitText(match.index);
                wordNode.splitText(match[0].length);
                var wordClone = wordNode.cloneNode(true);
                highlight.appendChild(wordClone);
                wordNode.parentNode.replaceChild(highlight, wordNode);
                return 1;
            }
        } else if ((node.nodeType === 1 && node.childNodes) && !/(script|style)/i.test(node.tagName) && !(node.tagName === nodeName.toUpperCase() && node.className === className)) {
            for (var i = 0; i < node.childNodes.length; i++) {
                i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
            }
        }
        return 0;
    }
});
jQuery.fn.unhighlight = function(options) {
    var settings = {
        className: 'highlight',
        element: 'span'
    };
    jQuery.extend(settings, options);
    return this.find(settings.element + "." + settings.className).each(function() {
        var parent = this.parentNode;
        parent.replaceChild(this.firstChild, this);
        parent.normalize();
    }).end();
};
jQuery.fn.highlight = function(words, options) {
    var settings = {
        className: 'highlight',
        element: 'span',
        caseSensitive: false,
        wordsOnly: false,
        includePlurals: false
    };
    jQuery.extend(settings, options);
    if (words.constructor === String) {
        if (settings.includePlurals) {
            words = [words, words + 's'];
        } else {
            words = [words];
        }
    }
    words = jQuery.grep(words, function(word, i) {
        return word != '';
    });
    words = jQuery.map(words, function(word, i) {
        return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    });
    if (words.length == 0) {
        return this;
    };
    var flag = settings.caseSensitive ? "" : "i";
    var pattern = "(" + words.join("|") + ")";
    if (settings.wordsOnly) {
        pattern = "\\b" + pattern + "\\b";
    }
    var re = new RegExp(pattern, flag);
    return this.each(function() {
        jQuery.highlight(this, re, settings.element, settings.className);
    });
};;
(function($) {
    var textarea, staticOffset;
    var iLastMousePos = 0;
    var iMin = 32;
    var grip;
    $.fn.TextAreaResizer = function(options) {
        return this.each(function() {
            textarea = $(this).addClass('processed'), staticOffset = null;
            $(this).wrap('<div class="resizable-textarea"><span></span></div>').parent().append($('<div class="grippie"></div>').bind("mousedown", {
                el: this
            }, startDrag));
            var grippie = $('div.grippie', $(this).parent())[0];
            grippie.style.marginRight = (grippie.offsetWidth - $(this)[0].offsetWidth) + 'px'
        })

        function startDrag(e) {
            textarea = $(e.data.el);
            textarea.blur();
            iLastMousePos = mousePosition(e).y;
            staticOffset = textarea.height() - iLastMousePos;
            textarea.css('opacity', 0.25);
            $(document).mousemove(performDrag).mouseup(endDrag);
            return false
        }

        function performDrag(e) {
            var iThisMousePos = mousePosition(e).y;
            var iMousePos = staticOffset + iThisMousePos;
            if (iLastMousePos >= (iThisMousePos)) {
                iMousePos -= 5
            }
            iLastMousePos = iThisMousePos;
            iMousePos = Math.max(iMin, iMousePos);
            textarea.height(iMousePos + 'px');
            if (iMousePos < iMin) {
                endDrag(e)
            }
            return false
        }

        function endDrag(e) {
            $(document).unbind('mousemove', performDrag).unbind('mouseup', endDrag);
            textarea.css('opacity', 1);
            textarea.focus();
            options.onResize(e, textarea.height());
            textarea = null;
            staticOffset = null;
            iLastMousePos = 0
        }

        function mousePosition(e) {
            return {
                x: e.clientX + document.documentElement.scrollLeft,
                y: e.clientY + document.documentElement.scrollTop
            }
        }
    };
})(jQuery);;
/*!
 * jQuery.selection - jQuery Plugin
 *
 * Copyright (c) 2010-2014 IWASAKI Koji (@madapaja).
 * http://blog.madapaja.net/
 * Under The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function($, win, doc) {
    var _getCaretInfo = function(element) {
        var res = {
            text: '',
            start: 0,
            end: 0
        };
        if (!element.value) {
            return res;
        }
        try {
            if (win.getSelection) {
                res.start = element.selectionStart;
                res.end = element.selectionEnd;
                res.text = element.value.slice(res.start, res.end);
            } else if (doc.selection) {
                element.focus();
                var range = doc.selection.createRange(),
                    range2 = doc.body.createTextRange();
                res.text = range.text;
                try {
                    range2.moveToElementText(element);
                    range2.setEndPoint('StartToStart', range);
                } catch (e) {
                    range2 = element.createTextRange();
                    range2.setEndPoint('StartToStart', range);
                }
                res.start = element.value.length - range2.text.length;
                res.end = res.start + range.text.length;
            }
        } catch (e) {}
        return res;
    };
    var _CaretOperation = {
        getPos: function(element) {
            var tmp = _getCaretInfo(element);
            return {
                start: tmp.start,
                end: tmp.end
            };
        },
        setPos: function(element, toRange, caret) {
            caret = this._caretMode(caret);
            if (caret === 'start') {
                toRange.end = toRange.start;
            } else if (caret === 'end') {
                toRange.start = toRange.end;
            }
            element.focus();
            try {
                if (element.createTextRange) {
                    var range = element.createTextRange();
                    if (win.navigator.userAgent.toLowerCase().indexOf("msie") >= 0) {
                        toRange.start = element.value.substr(0, toRange.start).replace(/\r/g, '').length;
                        toRange.end = element.value.substr(0, toRange.end).replace(/\r/g, '').length;
                    }
                    range.collapse(true);
                    range.moveStart('character', toRange.start);
                    range.moveEnd('character', toRange.end - toRange.start);
                    range.select();
                } else if (element.setSelectionRange) {
                    element.setSelectionRange(toRange.start, toRange.end);
                }
            } catch (e) {}
        },
        getText: function(element) {
            return _getCaretInfo(element).text;
        },
        _caretMode: function(caret) {
            caret = caret || "keep";
            if (caret === false) {
                caret = 'end';
            }
            switch (caret) {
                case 'keep':
                case 'start':
                case 'end':
                    break;
                default:
                    caret = 'keep';
            }
            return caret;
        },
        replace: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {
                    start: tmp.start,
                    end: tmp.start + text.length
                };
            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.end);
            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },
        insertBefore: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {
                    start: tmp.start + text.length,
                    end: tmp.end + text.length
                };
            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.start);
            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },
        insertAfter: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {
                    start: tmp.start,
                    end: tmp.end
                };
            element.value = orig.substr(0, tmp.end) + text + orig.substr(tmp.end);
            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        }
    };
    $.extend({
        selection: function(mode) {
            var getText = ((mode || 'text').toLowerCase() === 'text');
            try {
                if (win.getSelection) {
                    if (getText) {
                        return win.getSelection().toString();
                    } else {
                        var sel = win.getSelection(),
                            range;
                        if (sel.getRangeAt) {
                            range = sel.getRangeAt(0);
                        } else {
                            range = doc.createRange();
                            range.setStart(sel.anchorNode, sel.anchorOffset);
                            range.setEnd(sel.focusNode, sel.focusOffset);
                        }
                        return $('<div></div>').append(range.cloneContents()).html();
                    }
                } else if (doc.selection) {
                    if (getText) {
                        return doc.selection.createRange().text;
                    } else {
                        return doc.selection.createRange().htmlText;
                    }
                }
            } catch (e) {}
            return '';
        }
    });
    $.fn.extend({
        selection: function(mode, opts) {
            opts = opts || {};
            switch (mode) {
                case 'getPos':
                    return _CaretOperation.getPos(this[0]);
                case 'setPos':
                    return this.each(function() {
                        _CaretOperation.setPos(this, opts);
                    });
                case 'replace':
                    return this.each(function() {
                        _CaretOperation.replace(this, opts.text, opts.caret);
                    });
                case 'insert':
                    return this.each(function() {
                        if (opts.mode === 'before') {
                            _CaretOperation.insertBefore(this, opts.text, opts.caret);
                        } else {
                            _CaretOperation.insertAfter(this, opts.text, opts.caret);
                        }
                    });
                case 'get':
                default:
                    return _CaretOperation.getText(this[0]);
            }
            return this;
        }
    });
})(jQuery, window, window.document);;
var EXPORTED_SYMBOLS = ['AtDCore'];

function AtDCore() {
    this.ignore_types = ['Bias Language', 'Cliches', 'Complex Expression', 'Diacritical Marks', 'Double Negatives', 'Hidden Verbs', 'Jargon Language', 'Passive voice', 'Phrases to Avoid', 'Redundant Expression'];
    this.ignore_strings = {};
    this.i18n = {};
};
AtDCore.prototype.getLang = function(key, defaultk) {
    if (this.i18n[key] == undefined)
        return defaultk;
    return this.i18n[key];
};
AtDCore.prototype.addI18n = function(localizations) {
    this.i18n = localizations;
};
AtDCore.prototype.setIgnoreStrings = function(string) {
    var parent = this;
    this.map(string.split(/,\s*/g), function(string) {
        parent.ignore_strings[string] = 1;
    });
};
AtDCore.prototype.showTypes = function(string) {
    var show_types = string.split(/,\s*/g);
    var types = {};
    types["Double Negatives"] = 1;
    types["Hidden Verbs"] = 1;
    types["Passive voice"] = 1;
    types["Bias Language"] = 1;
    types["Cliches"] = 1;
    types["Complex Expression"] = 1;
    types["Diacritical Marks"] = 1;
    types["Jargon Language"] = 1;
    types["Phrases to Avoid"] = 1;
    types["Redundant Expression"] = 1;
    var ignore_types = [];
    this.map(show_types, function(string) {
        types[string] = undefined;
    });
    this.map(this.ignore_types, function(string) {
        if (types[string] != undefined)
            ignore_types.push(string);
    });
    this.ignore_types = ignore_types;
};
AtDCore.prototype.makeError = function(error_s, tokens, type, seps, pre) {
    var struct = new Object();
    struct.type = type;
    struct.string = error_s;
    struct.tokens = tokens;
    if (new RegExp("\\b" + error_s + "\\b").test(error_s)) {
        struct.regexp = new RegExp("(?!" + error_s + "<)\\b" + error_s.replace(/\s+/g, seps) + "\\b");
    } else if (new RegExp(error_s + "\\b").test(error_s)) {
        struct.regexp = new RegExp("(?!" + error_s + "<)" + error_s.replace(/\s+/g, seps) + "\\b");
    } else if (new RegExp("\\b" + error_s).test(error_s)) {
        struct.regexp = new RegExp("(?!" + error_s + "<)\\b" + error_s.replace(/\s+/g, seps));
    } else {
        struct.regexp = new RegExp("(?!" + error_s + "<)" + error_s.replace(/\s+/g, seps));
    }
    struct.used = false;
    return struct;
};
AtDCore.prototype.addToErrorStructure = function(errors, list, type, seps) {
    var parent = this;
    this.map(list, function(error) {
        var tokens = error["word"].split(/\s+/);
        var pre = error["pre"];
        var first = tokens[0];
        if (errors['__' + first] == undefined) {
            errors['__' + first] = new Object();
            errors['__' + first].pretoks = {};
            errors['__' + first].defaults = new Array();
        }
        if (pre == "") {
            errors['__' + first].defaults.push(parent.makeError(error["word"], tokens, type, seps, pre));
        } else {
            if (errors['__' + first].pretoks['__' + pre] == undefined)
                errors['__' + first].pretoks['__' + pre] = new Array();
            errors['__' + first].pretoks['__' + pre].push(parent.makeError(error["word"], tokens, type, seps, pre));
        }
    });
};
AtDCore.prototype.buildErrorStructure = function(spellingList, enrichmentList, grammarList) {
    var seps = this._getSeparators();
    var errors = {};
    this.addToErrorStructure(errors, spellingList, "hiddenSpellError", seps);
    this.addToErrorStructure(errors, grammarList, "hiddenGrammarError", seps);
    this.addToErrorStructure(errors, enrichmentList, "hiddenSuggestion", seps);
    return errors;
};
AtDCore.prototype._getSeparators = function() {
    var re = '',
        i;
    var str = '"s!#$%&()*+,./:;<=>?@[\]^_{|}';
    for (i = 0; i < str.length; i++)
        re += '\\' + str.charAt(i);
    return "(?:(?:[\xa0" + re + "])|(?:\\-\\-))+";
};
AtDCore.prototype.processXML = function(responseXML) {
    var types = {};
    this.map(this.ignore_types, function(type) {
        types[type] = 1;
    });
    this.suggestions = [];
    var errors = responseXML.getElementsByTagName('error');
    var grammarErrors = [];
    var spellingErrors = [];
    var enrichment = [];
    for (var i = 0; i < errors.length; i++) {
        if (errors[i].getElementsByTagName('string').item(0).firstChild != null) {
            var errorString = errors[i].getElementsByTagName('string').item(0).firstChild.data;
            var errorType = errors[i].getElementsByTagName('type').item(0).firstChild.data;
            var errorDescription = errors[i].getElementsByTagName('description').item(0).firstChild.data;
            var errorContext;
            if (errors[i].getElementsByTagName('precontext').item(0).firstChild != null)
                errorContext = errors[i].getElementsByTagName('precontext').item(0).firstChild.data;
            else
                errorContext = "";
            if (this.ignore_strings[errorString] == undefined) {
                var suggestion = {};
                suggestion["description"] = errorDescription;
                suggestion["suggestions"] = [];
                suggestion["matcher"] = new RegExp('^' + errorString.replace(/\s+/, this._getSeparators()) + '$');
                suggestion["context"] = errorContext;
                suggestion["string"] = errorString;
                suggestion["type"] = errorType;
                this.suggestions.push(suggestion);
                if (errors[i].getElementsByTagName('suggestions').item(0) != undefined) {
                    var suggestions = errors[i].getElementsByTagName('suggestions').item(0).getElementsByTagName('option');
                    for (var j = 0; j < suggestions.length; j++)
                        suggestion["suggestions"].push(suggestions[j].firstChild.data);
                }
                if (errors[i].getElementsByTagName('url').item(0) != undefined) {
                    var errorUrl = errors[i].getElementsByTagName('url').item(0).firstChild.data;
                    suggestion["moreinfo"] = errorUrl + '&theme=tinymce';
                }
                if (types[errorDescription] == undefined) {
                    if (errorType == "suggestion")
                        enrichment.push({
                            word: errorString,
                            pre: errorContext
                        });
                    if (errorType == "grammar")
                        grammarErrors.push({
                            word: errorString,
                            pre: errorContext
                        });
                }
                if (errorType == "spelling" || errorDescription == "Homophone")
                    spellingErrors.push({
                        word: errorString,
                        pre: errorContext
                    });
                if (errorDescription == 'Cliches')
                    suggestion["description"] = 'Clich&eacute;s';
                if (errorDescription == "Spelling")
                    suggestion["description"] = this.getLang('menu_title_spelling', 'Spelling');
                if (errorDescription == "Repeated Word")
                    suggestion["description"] = this.getLang('menu_title_repeated_word', 'Repeated Word');
                if (errorDescription == "Did you mean...")
                    suggestion["description"] = this.getLang('menu_title_confused_word', 'Did you mean...');
            }
        }
    }
    var errorStruct;
    var ecount = spellingErrors.length + grammarErrors.length + enrichment.length;
    if (ecount > 0)
        errorStruct = this.buildErrorStructure(spellingErrors, enrichment, grammarErrors);
    else
        errorStruct = undefined;
    return {
        errors: errorStruct,
        count: ecount,
        suggestions: this.suggestions
    };
};
AtDCore.prototype.findSuggestion = function(element) {
    var text = element.innerHTML;
    var context = (this.getAttrib(element, 'pre') + "").replace(/[\\,!\\?\\."\s]/g, '');
    if (this.getAttrib(element, 'pre') == undefined) {
        alert(element.innerHTML);
    }
    var errorDescription = undefined;
    var len = this.suggestions.length;
    for (var i = 0; i < len; i++) {
        var key = this.suggestions[i]["string"];
        if ((context == "" || context == this.suggestions[i]["context"]) && this.suggestions[i]["matcher"].test(text)) {
            errorDescription = this.suggestions[i];
            break;
        }
    }
    return errorDescription;
};

function TokenIterator(tokens) {
    this.tokens = tokens;
    this.index = 0;
    this.count = 0;
    this.last = 0;
};
TokenIterator.prototype.next = function() {
    var current = this.tokens[this.index];
    this.count = this.last;
    this.last += current.length + 1;
    this.index++;
    if (current != "") {
        if (current[0] == "'")
            current = current.substring(1, current.length);
        if (current[current.length - 1] == "'")
            current = current.substring(0, current.length - 1);
    }
    return current;
};
TokenIterator.prototype.hasNext = function() {
    return this.index < this.tokens.length;
};
TokenIterator.prototype.hasNextN = function(n) {
    return (this.index + n) < this.tokens.length;
};
TokenIterator.prototype.skip = function(m, n) {
    this.index += m;
    this.last += n;
    if (this.index < this.tokens.length)
        this.count = this.last - this.tokens[this.index].length;
};
TokenIterator.prototype.getCount = function() {
    return this.count;
};
TokenIterator.prototype.peek = function(n) {
    var peepers = new Array();
    var end = this.index + n;
    for (var x = this.index; x < end; x++)
        peepers.push(this.tokens[x]);
    return peepers;
};
AtDCore.prototype.markMyWords = function(container_nodes, errors) {
    var seps = new RegExp(this._getSeparators());
    var nl = new Array();
    var ecount = 0;
    var parent = this;
    this._walk(container_nodes, function(n) {
        if (n.nodeType == 3 && !parent.isMarkedNode(n))
            nl.push(n);
    });
    var iterator;
    this.map(nl, function(n) {
        var v;
        if (n.nodeType == 3) {
            v = n.nodeValue;
            var tokens = n.nodeValue.split(seps);
            var previous = "";
            var doReplaces = [];
            iterator = new TokenIterator(tokens);
            while (iterator.hasNext()) {
                var token = iterator.next();
                var current = errors['__' + token];
                var defaults;
                if (current != undefined && current.pretoks != undefined) {
                    defaults = current.defaults;
                    current = current.pretoks['__' + previous];
                    var done = false;
                    var prev, curr;
                    prev = v.substr(0, iterator.getCount());
                    curr = v.substr(prev.length, v.length);
                    var checkErrors = function(error) {
                        if (error != undefined && !error.used && foundStrings['__' + error.string] == undefined && error.regexp.test(curr)) {
                            var oldlen = curr.length;
                            foundStrings['__' + error.string] = 1;
                            doReplaces.push([error.regexp, '<span class="' + error.type + '" pre="' + previous + '">$&</span>']);
                            error.used = true;
                            done = true;
                        }
                    };
                    var foundStrings = {};
                    if (current != undefined) {
                        previous = previous + ' ';
                        parent.map(current, checkErrors);
                    }
                    if (!done) {
                        previous = '';
                        parent.map(defaults, checkErrors);
                    }
                }
                previous = token;
            }
            if (doReplaces.length > 0) {
                newNode = n;
                for (var x = 0; x < doReplaces.length; x++) {
                    var regexp = doReplaces[x][0],
                        result = doReplaces[x][1];
                    var bringTheHurt = function(node) {
                        if (node.nodeType == 3) {
                            ecount++;
                            if (parent.isIE() && node.nodeValue.length > 0 && node.nodeValue.substr(0, 1) == ' ')
                                return parent.create('<span class="mceItemHidden">&nbsp;</span>' + node.nodeValue.substr(1, node.nodeValue.length - 1).replace(regexp, result), false);
                            else
                                return parent.create(node.nodeValue.replace(regexp, result), false);
                        } else {
                            var contents = parent.contents(node);
                            for (var y = 0; y < contents.length; y++) {
                                if (contents[y].nodeType == 3 && regexp.test(contents[y].nodeValue)) {
                                    var nnode;
                                    if (parent.isIE() && contents[y].nodeValue.length > 0 && contents[y].nodeValue.substr(0, 1) == ' ')
                                        nnode = parent.create('<span class="mceItemHidden">&nbsp;</span>' + contents[y].nodeValue.substr(1, contents[y].nodeValue.length - 1).replace(regexp, result), true);
                                    else
                                        nnode = parent.create(contents[y].nodeValue.replace(regexp, result), true);
                                    parent.replaceWith(contents[y], nnode);
                                    parent.removeParent(nnode);
                                    ecount++;
                                    return node;
                                }
                            }
                            return node;
                        }
                    };
                    newNode = bringTheHurt(newNode);
                }
                parent.replaceWith(n, newNode);
            }
        }
    });
    return ecount;
};
AtDCore.prototype._walk = function(elements, f) {
    var i;
    for (i = 0; i < elements.length; i++) {
        f.call(f, elements[i]);
        this._walk(this.contents(elements[i]), f);
    }
};
AtDCore.prototype.removeWords = function(node, w) {
    var count = 0;
    var parent = this;
    this.map(this.findSpans(node).reverse(), function(n) {
        if (n && (parent.isMarkedNode(n) || parent.hasClass(n, 'mceItemHidden') || parent.isEmptySpan(n))) {
            if (n.innerHTML == '&nbsp;') {
                var nnode = document.createTextNode(' ');
                parent.replaceWith(n, nnode);
            } else if (!w || n.innerHTML == w) {
                parent.removeParent(n);
                count++;
            }
        }
    });
    return count;
};
AtDCore.prototype.isEmptySpan = function(node) {
    return (this.getAttrib(node, 'class') == "" && this.getAttrib(node, 'style') == "" && this.getAttrib(node, 'id') == "" && !this.hasClass(node, 'Apple-style-span') && this.getAttrib(node, 'mce_name') == "");
};
AtDCore.prototype.isMarkedNode = function(node) {
    return (this.hasClass(node, 'hiddenGrammarError') || this.hasClass(node, 'hiddenSpellError') || this.hasClass(node, 'hiddenSuggestion'));
};
AtDCore.prototype.applySuggestion = function(element, suggestion) {
    if (suggestion == '(omit)') {
        this.remove(element);
    } else {
        var node = this.create(suggestion);
        this.replaceWith(element, node);
        this.removeParent(node);
    }
};
AtDCore.prototype.hasErrorMessage = function(xmlr) {
    return (xmlr != undefined && xmlr.getElementsByTagName('message').item(0) != null);
};
AtDCore.prototype.getErrorMessage = function(xmlr) {
    return xmlr.getElementsByTagName('message').item(0);
};
AtDCore.prototype.isIE = function() {
    return navigator.appName == 'Microsoft Internet Explorer';
};
var AtD = {
    rpc: '',
    rpc_css: 'http://www.polishmywriting.com/atd-jquery/server/proxycss.php?data=',
    rpc_css_lang: 'en',
    api_key: '',
    i18n: {},
    listener: {}
};
AtD.getLang = function(key, defaultk) {
    if (AtD.i18n[key] == undefined)
        return defaultk;
    return AtD.i18n[key];
};
AtD.addI18n = function(localizations) {
    AtD.i18n = localizations;
    AtD.core.addI18n(localizations);
};
AtD.setIgnoreStrings = function(string) {
    AtD.core.setIgnoreStrings(string);
};
AtD.showTypes = function(string) {
    AtD.core.showTypes(string);
};
AtD.checkCrossAJAX = function(container_id, callback_f) {
    if (typeof AtD_proofread_click_count != "undefined")
        AtD_proofread_click_count++;
    AtD.callback_f = callback_f;
    AtD.remove(container_id);
    var container = jQuery('#' + container_id);
    var html = container.html();
    text = jQuery.trim(container.html());
    text = encodeURIComponent(text.replace(/\%/g, '%25'));
    if ((text.length > 2000 && navigator.appName == 'Microsoft Internet Explorer') || text.length > 7800) {
        if (callback_f != undefined && callback_f.error != undefined)
            callback_f.error("Maximum text length for this browser exceeded");
        return;
    }
    CSSHttpRequest.get(AtD.rpc_css + text + "&lang=" + AtD.rpc_css_lang + "&nocache=" + (new Date().getTime()), function(response) {
        var xml;
        if (navigator.appName == 'Microsoft Internet Explorer') {
            xml = new ActiveXObject("Microsoft.XMLDOM");
            xml.async = false;
            xml.loadXML(response);
        } else {
            xml = (new DOMParser()).parseFromString(response, 'text/xml');
        }
        if (AtD.core.hasErrorMessage(xml)) {
            if (AtD.callback_f != undefined && AtD.callback_f.error != undefined)
                AtD.callback_f.error(AtD.core.getErrorMessage(xml));
            return;
        }
        AtD.container = container_id;
        var count = AtD.processXML(container_id, xml);
        if (AtD.callback_f != undefined && AtD.callback_f.ready != undefined)
            AtD.callback_f.ready(count);
        if (count == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
            AtD.callback_f.success(count);
        AtD.counter = count;
        AtD.count = count;
    });
};
AtD.check = function(container_id, callback_f) {
    if (typeof AtD_proofread_click_count != "undefined")
        AtD_proofread_click_count++;
    AtD.callback_f = callback_f;
    AtD.remove(container_id);
    var container = jQuery('#' + container_id);
    var html = container.html();
    text = jQuery.trim(container.html());
    text = encodeURIComponent(text);
    var ie = (function() {
        var undef, v = 3,
            div = document.createElement('div'),
            all = div.getElementsByTagName('i');
        while (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->', all[0]);
        return v > 4 ? v : undef;
    }());
    jQuery.ajax({
        type: "POST",
        url: AtD.rpc + '/checkDocument',
        data: 'key=' + AtD.api_key + '&data=' + text,
        format: 'raw',
        dataType: (ie) ? "text" : "xml",
        error: function(XHR, status, error) {
            if (AtD.callback_f != undefined && AtD.callback_f.error != undefined)
                AtD.callback_f.error(status + ": " + error);
        },
        success: function(data) {
            var xml;
            if (typeof data == "string") {
                xml = new ActiveXObject("Microsoft.XMLDOM");
                xml.async = false;
                xml.loadXML(data);
            } else {
                xml = data;
            }
            if (AtD.core.hasErrorMessage(xml)) {
                if (AtD.callback_f != undefined && AtD.callback_f.error != undefined)
                    AtD.callback_f.error(AtD.core.getErrorMessage(xml));
                return;
            }
            AtD.container = container_id;
            var count = AtD.processXML(container_id, xml);
            if (AtD.callback_f != undefined && AtD.callback_f.ready != undefined)
                AtD.callback_f.ready(count);
            if (count == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
                AtD.callback_f.success(count);
            AtD.counter = count;
            AtD.count = count;
        }
    });
};
AtD.remove = function(container_id) {
    AtD._removeWords(container_id, null);
};
AtD.clickListener = function(event) {
    if (AtD.core.isMarkedNode(event.target))
        AtD.suggest(event.target);
};
AtD.processXML = function(container_id, responseXML) {
    var results = AtD.core.processXML(responseXML);
    if (results.count > 0)
        results.count = AtD.core.markMyWords(jQuery('#' + container_id).contents(), results.errors);
    jQuery('#' + container_id).unbind('click', AtD.clickListener);
    jQuery('#' + container_id).click(AtD.clickListener);
    return results.count;
};
AtD.useSuggestion = function(word) {
    this.core.applySuggestion(AtD.errorElement, word);
    AtD.counter--;
    if (AtD.counter == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
        AtD.callback_f.success(AtD.count);
};
AtD.editSelection = function() {
    var parent = AtD.errorElement.parent();
    if (AtD.callback_f != undefined && AtD.callback_f.editSelection != undefined)
        AtD.callback_f.editSelection(AtD.errorElement);
    if (AtD.errorElement.parent() != parent) {
        AtD.counter--;
        if (AtD.counter == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
            AtD.callback_f.success(AtD.count);
    }
};
AtD.ignoreSuggestion = function() {
    AtD.core.removeParent(AtD.errorElement);
    AtD.counter--;
    if (AtD.counter == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
        AtD.callback_f.success(AtD.count);
};
AtD.ignoreAll = function(container_id) {
    var target = AtD.errorElement.text();
    var removed = AtD._removeWords(container_id, target);
    AtD.counter -= removed;
    if (AtD.counter == 0 && AtD.callback_f != undefined && AtD.callback_f.success != undefined)
        AtD.callback_f.success(AtD.count);
    if (AtD.callback_f != undefined && AtD.callback_f.ignore != undefined) {
        AtD.callback_f.ignore(target);
        AtD.core.setIgnoreStrings(target);
    }
};
AtD.explainError = function() {
    if (AtD.callback_f != undefined && AtD.callback_f.explain != undefined)
        AtD.callback_f.explain(AtD.explainURL);
};
AtD.suggest = function(element) {
    if (jQuery('#suggestmenu').length == 0) {
        var suggest = jQuery('<div id="suggestmenu"></div>');
        suggest.prependTo('body');
    } else {
        var suggest = jQuery('#suggestmenu');
        suggest.hide();
    }
    errorDescription = AtD.core.findSuggestion(element);
    AtD.errorElement = jQuery(element);
    suggest.empty();
    if (errorDescription == undefined) {
        suggest.append('<strong>' + AtD.getLang('menu_title_no_suggestions', 'No suggestions') + '</strong>');
    } else if (errorDescription["suggestions"].length == 0) {
        suggest.append('<strong>' + errorDescription['description'] + '</strong>');
    } else {
        suggest.append('<strong>' + errorDescription['description'] + '</strong>');
        for (var i = 0; i < errorDescription["suggestions"].length; i++) {
            (function(sugg) {
                suggest.append('<a href="javascript:AtD.useSuggestion(\'' + sugg.replace(/'/, '\\\'') + '\')">' + sugg + '</a>');
            })(errorDescription["suggestions"][i]);
        }
    }
    if (AtD.callback_f != undefined && AtD.callback_f.explain != undefined && errorDescription['moreinfo'] != undefined) {
        suggest.append('<a href="javascript:AtD.explainError()" class="spell_sep_top">' + AtD.getLang('menu_option_explain', 'Explain...') + '</a>');
        AtD.explainURL = errorDescription['moreinfo'];
    }
    suggest.append('<a href="javascript:AtD.ignoreSuggestion()" class="spell_sep_top">' + AtD.getLang('menu_option_ignore_once', 'Ignore suggestion') + '</a>');
    if (AtD.callback_f != undefined && AtD.callback_f.editSelection != undefined) {
        if (AtD.callback_f != undefined && AtD.callback_f.ignore != undefined)
            suggest.append('<a href="javascript:AtD.ignoreAll(\'' + AtD.container + '\')">' + AtD.getLang('menu_option_ignore_always', 'Ignore always') + '</a>');
        else
            suggest.append('<a href="javascript:AtD.ignoreAll(\'' + AtD.container + '\')">' + AtD.getLang('menu_option_ignore_all', 'Ignore all') + '</a>');
        suggest.append('<a href="javascript:AtD.editSelection(\'' + AtD.container + '\')" class="spell_sep_bottom spell_sep_top">' + AtD.getLang('menu_option_edit_selection', 'Edit Selection...') + '</a>');
    } else {
        if (AtD.callback_f != undefined && AtD.callback_f.ignore != undefined)
            suggest.append('<a href="javascript:AtD.ignoreAll(\'' + AtD.container + '\')" class="spell_sep_bottom">' + AtD.getLang('menu_option_ignore_always', 'Ignore always') + '</a>');
        else
            suggest.append('<a href="javascript:AtD.ignoreAll(\'' + AtD.container + '\')" class="spell_sep_bottom">' + AtD.getLang('menu_option_ignore_all', 'Ignore all') + '</a>');
    }
    var pos = jQuery(element).offset();
    var width = jQuery(element).width();
    jQuery(suggest).css({
        left: (pos.left + width) + 'px',
        top: pos.top + 'px'
    });
    jQuery(suggest).fadeIn(200);
    AtD.suggestShow = true;
    setTimeout(function() {
        jQuery("body").bind("click", function() {
            if (!AtD.suggestShow)
                jQuery('#suggestmenu').fadeOut(200);
        });
    }, 1);
    setTimeout(function() {
        AtD.suggestShow = false;
    }, 2);
};
AtD._removeWords = function(container_id, w) {
    return this.core.removeWords(jQuery('#' + container_id), w);
};
AtD.initCoreModule = function() {
    var core = new AtDCore();
    core.hasClass = function(node, className) {
        return jQuery(node).hasClass(className);
    };
    core.map = jQuery.map;
    core.contents = function(node) {
        return jQuery(node).contents();
    };
    core.replaceWith = function(old_node, new_node) {
        return jQuery(old_node).replaceWith(new_node);
    };
    core.findSpans = function(parent) {
        return jQuery.makeArray(parent.find('span'));
    };
    core.create = function(node_html, isTextNode) {
        return jQuery('<span class="mceItemHidden">' + node_html + '</span>');
    };
    core.remove = function(node) {
        return jQuery(node).remove();
    };
    core.removeParent = function(node) {
        if (jQuery(node).unwrap)
            return jQuery(node).contents().unwrap();
        else
            return jQuery(node).replaceWith(jQuery(node).html());
    };
    core.getAttrib = function(node, name) {
        return jQuery(node).attr(name);
    };
    return core;
};
AtD.core = AtD.initCoreModule();;
(function() {
    var chr = window.CSSHttpRequest = {};
    chr.id = 0;
    chr.requests = {};
    chr.MATCH_ORDINAL = /#c(\d+)/;
    chr.MATCH_URL = /url\("?data\:[^,]*,([^")]+)"?\)/;
    chr.get = function(url, callback) {
        var id = ++chr.id;
        var iframe = document.createElement("iframe");
        iframe.style.position = "absolute";
        iframe.style.left = iframe.style.top = "-1000px";
        iframe.style.width = iframe.style.height = 0;
        document.documentElement.appendChild(iframe);
        var r = chr.requests[id] = {
            id: id,
            iframe: iframe,
            document: iframe.contentDocument || iframe.contentWindow.document,
            callback: callback
        };
        r.document.open("text/html", false);
        r.document.write("<html><head>");
        r.document.write("<link rel='stylesheet' type='text/css' media='print, csshttprequest' href='" + chr.escapeHTML(url) + "' />");
        r.document.write("</head><body>");
        r.document.write("<script type='text/javascript'>");
        r.document.write("(function(){var w = window; var p = w.parent; p.CSSHttpRequest.sandbox(w); w.onload = function(){p.CSSHttpRequest.callback('" + id + "');};})();");
        r.document.write("</script>");
        r.document.write("</body></html>");
        r.document.close();
    };
    chr.sandbox = function(w) {};
    chr.callback = function(id) {
        var r = chr.requests[id];
        var data = chr.parse(r);
        r.callback(data);
        window.setTimeout(function() {
            var r = chr.requests[id];
            try {
                r.iframe.parentElement.removeChild(r.iframe);
            } catch (e) {};
            delete chr.requests[id];
        }, 0);
    };
    chr.parse = function(r) {
        var data = [];
        try {
            var rules = r.document.styleSheets[0].cssRules || r.document.styleSheets[0].rules;
            for (var i = 0; i < rules.length; i++) {
                try {
                    var r = rules.item ? rules.item(i) : rules[i];
                    var ord = r.selectorText.match(chr.MATCH_ORDINAL)[1];
                    var val = r.style.backgroundImage.match(chr.MATCH_URL)[1];
                    data[ord] = val;
                } catch (e) {}
            }
        } catch (e) {
            r.document.getElementsByTagName("link")[0].setAttribute("media", "screen");
            var x = r.document.createElement("div");
            x.innerHTML = "foo";
            r.document.body.appendChild(x);
            var ord = 0;
            try {
                while (1) {
                    x.id = "c" + ord;
                    var style = r.document.defaultView.getComputedStyle(x, null);
                    var bg = style["background-image"] || style.backgroundImage || style.getPropertyValue("background-image");
                    var val = bg.match(chr.MATCH_URL)[1];
                    data[ord] = val;
                    ord++;
                }
            } catch (e) {}
        }
        return decodeURIComponent(data.join(""));
    };
    chr.escapeHTML = function(s) {
        return s.replace(/([<>&""''])/g, function(m, c) {
            switch (c) {
                case "<":
                    return "&lt;";
                case ">":
                    return "&gt;";
                case "&":
                    return "&amp;";
                case '"':
                    return "&quot;";
                case "'":
                    return "&apos;";
            }
            return c;
        });
    };
})();;;
(function($, window, undefined) {
    'use strict';
    var $event = $.event,
        $special, resizeTimeout;
    $special = $event.special.debouncedresize = {
        setup: function() {
            $(this).on("resize", $special.handler);
        },
        teardown: function() {
            $(this).off("resize", $special.handler);
        },
        handler: function(event, execAsap) {
            var context = this,
                args = arguments,
                dispatch = function() {
                    event.type = "debouncedresize";
                    $event.dispatch.apply(context, args);
                };
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            execAsap ? dispatch() : resizeTimeout = setTimeout(dispatch, $special.threshold);
        },
        threshold: 50
    };
    var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    $.fn.imagesLoaded = function(callback) {
        var $this = this,
            deferred = $.isFunction($.Deferred) ? $.Deferred() : 0,
            hasNotify = $.isFunction(deferred.notify),
            $images = $this.find('img').add($this.filter('img')),
            loaded = [],
            proper = [],
            broken = [];
        if ($.isPlainObject(callback)) {
            $.each(callback, function(key, value) {
                if (key === 'callback') {
                    callback = value;
                } else if (deferred) {
                    deferred[key](value);
                }
            });
        }

        function doneLoading() {
            var $proper = $(proper),
                $broken = $(broken);
            if (deferred) {
                if (broken.length) {
                    deferred.reject($images, $proper, $broken);
                } else {
                    deferred.resolve($images);
                }
            }
            if ($.isFunction(callback)) {
                callback.call($this, $images, $proper, $broken);
            }
        }

        function imgLoaded(img, isBroken) {
            if (img.src === BLANK || $.inArray(img, loaded) !== -1) {
                return;
            }
            loaded.push(img);
            if (isBroken) {
                broken.push(img);
            } else {
                proper.push(img);
            }
            $.data(img, 'imagesLoaded', {
                isBroken: isBroken,
                src: img.src
            });
            if (hasNotify) {
                deferred.notifyWith($(img), [isBroken, $images, $(proper), $(broken)]);
            }
            if ($images.length === loaded.length) {
                setTimeout(doneLoading);
                $images.unbind('.imagesLoaded');
            }
        }
        if (!$images.length) {
            doneLoading();
        } else {
            $images.bind('load.imagesLoaded error.imagesLoaded', function(event) {
                imgLoaded(event.target, event.type === 'error');
            }).each(function(i, el) {
                var src = el.src;
                var cached = $.data(el, 'imagesLoaded');
                if (cached && cached.src === src) {
                    imgLoaded(el, cached.isBroken);
                    return;
                }
                if (el.complete && el.naturalWidth !== undefined) {
                    imgLoaded(el, el.naturalWidth === 0 || el.naturalHeight === 0);
                    return;
                }
                if (el.readyState || el.complete) {
                    el.src = BLANK;
                    el.src = src;
                }
            });
        }
        return deferred ? deferred.promise($this) : $this;
    };
    var $window = $(window),
        Modernizr = window.Modernizr;
    $.Slicebox = function(options, element) {
        this.$el = $(element);
        this._init(options);
    };
    $.Slicebox.defaults = {
        orientation: 'v',
        perspective: 1200,
        cuboidsCount: 5,
        cuboidsRandom: false,
        maxCuboidsCount: 5,
        disperseFactor: 0,
        colorHiddenSides: '#222',
        sequentialFactor: 150,
        speed: 600,
        easing: 'ease',
        autoplay: false,
        interval: 3000,
        fallbackFadeSpeed: 300,
        onBeforeChange: function(position) {
            return false;
        },
        onAfterChange: function(position) {
            return false;
        },
        onReady: function() {
            return false;
        }
    };
    $.Slicebox.prototype = {
        _init: function(options) {
            this.options = $.extend(true, {}, $.Slicebox.defaults, options);
            this._validate();
            this.$items = this.$el.children('li');
            this.itemsCount = this.$items.length;
            if (this.itemsCount === 0) {
                return false;
            };
            this.support = Modernizr.csstransitions && Modernizr.csstransforms3d;
            this.current = this.options.current ? this.options.current : 0;
            this.isAnimating = false;
            this.isReady = false;
            var self = this;
            this.$el.imagesLoaded(function() {
                var $current = self.$items.eq(self.current).css('display', 'block').addClass('sb-current');
                var i = new Image();
                i.src = $current.find('img').attr('src');
                self.realWidth = i.width;
                self._setSize();
                self._setStyle();
                self._initEvents();
                self.options.onReady();
                self.isReady = true;
                if (self.options.autoplay) {
                    self._startSlideshow();
                }
            });
        },
        _validate: function(options) {
            if (this.options.cuboidsCount < 0) {
                this.options.cuboidsCount = 1;
            } else if (this.options.cuboidsCount > 15) {
                this.options.cuboidsCount = 15;
            } else if (this.options.cuboidsCount % 2 === 0) {
                ++this.options.cuboidsCount;
            }
            if (this.options.maxCuboidsCount < 0) {
                this.options.maxCuboidsCount = 1;
            } else if (this.options.maxCuboidsCount > 15) {
                this.options.maxCuboidsCount = 15;
            } else if (this.options.maxCuboidsCount % 2 === 0) {
                ++this.options.maxCuboidsCount;
            }
            if (this.options.disperseFactor < 0) {
                this.options.disperseFactor = 0;
            }
            if (this.options.orientation !== 'v' && this.options.orientation !== 'h' && this.options.orientation !== 'r') {
                this.options.orientation = 'v';
            }
        },
        _setSize: function() {
            var $visible = this.$items.eq(this.current).find('img');
            this.size = {
                width: $visible.width(),
                height: $visible.height()
            };
        },
        _setStyle: function() {
            this.$el.css({
                'max-width': this.realWidth
            });
        },
        _initEvents: function() {
            var self = this;
            $window.on('debouncedresize.slicebox', function(event) {
                self._setSize();
            });
        },
        _startSlideshow: function() {
            var self = this;
            this.slideshow = setTimeout(function() {
                self._navigate('next');
                if (self.options.autoplay) {
                    self._startSlideshow();
                }
            }, this.options.interval);
        },
        _stopSlideshow: function() {
            if (this.options.autoplay) {
                clearTimeout(this.slideshow);
                this.isPlaying = false;
                this.options.autoplay = false;
            }
        },
        _navigate: function(dir, pos) {
            if (this.isAnimating || !this.isReady || this.itemsCount < 2) {
                return false;
            }
            this.isAnimating = true;
            this.prev = this.current;
            if (pos !== undefined) {
                this.current = pos;
            } else if (dir === 'next') {
                this.current = this.current < this.itemsCount - 1 ? this.current + 1 : 0;
            } else if (dir === 'prev') {
                this.current = this.current > 0 ? this.current - 1 : this.itemsCount - 1;
            }
            this.options.onBeforeChange(this.current);
            if (!this.support) {
                this._fade(dir);
            } else {
                this._layout(dir);
                this._rotate();
            }
        },
        _fade: function(dir) {
            var self = this,
                $visible = this.$items.eq(this.prev),
                h = $visible.find('img').height();
            this.$el.css('height', h);
            this.$items.css('position', 'absolute');
            this.$items.eq(this.current).fadeIn(this.options.fallbackFadeSpeed, function() {
                $(this).css('display', 'block').addClass('sb-current');
                self.$el.css('height', 'auto');
                self.$items.css('position', 'relative');
                self.isAnimating = false;
            });
            self.$items.eq(self.prev).removeClass('sb-current').fadeOut(this.options.fallbackFadeSpeed);
        },
        _layout: function(dir) {
            var orientation = this.options.orientation;
            if (orientation === 'r') {
                orientation = Math.floor(Math.random() * 2) === 0 ? 'v' : 'h';
            }
            if (this.options.cuboidsRandom) {
                this.options.cuboidsCount = Math.floor(Math.random() * this.options.maxCuboidsCount + 1);
            }
            this._validate();
            var boxStyle = {
                    'width': this.size.width,
                    'height': this.size.height,
                    'perspective': this.options.perspective + 'px'
                },
                config = $.extend(this.options, {
                    size: this.size,
                    items: this.$items,
                    direction: dir,
                    prev: this.prev,
                    current: this.current,
                    o: orientation
                }),
                self = this;
            this.$box = $('<div>').addClass('sb-perspective').css(boxStyle).appendTo(this.$el);
            this.cuboids = [];
            this.$el.css('overflow', 'visible');
            for (var i = 0; i < this.options.cuboidsCount; ++i) {
                var cuboid = new $.Cuboid(config, i);
                this.$box.append(cuboid.getEl());
                this.cuboids.push(cuboid);
            }
        },
        _rotate: function() {
            this.$items.eq(this.prev).removeClass('sb-current').hide();
            for (var i = 0; i < this.options.cuboidsCount; ++i) {
                var cuboid = this.cuboids[i],
                    self = this;
                cuboid.rotate(function(pos) {
                    if (pos === self.options.cuboidsCount - 1) {
                        self.$el.css('overflow', 'hidden');
                        self.isAnimating = false;
                        self.$box.remove();
                        var $current = self.$items.eq(self.current);
                        $current.css('display', 'block');
                        setTimeout(function() {
                            $current.addClass('sb-current');
                        }, 0);
                        self.options.onAfterChange(self.current);
                    }
                });
            }
        },
        _destroy: function(callback) {
            this.$el.off('.slicebox').removeData('slicebox');
            $window.off('.slicebox');
            callback.call();
        },
        add: function($items, callback) {
            this.$items = this.$items.add($items);
            this.itemsCount = this.$items.length;
            if (callback) {
                callback.call($items);
            }
        },
        next: function() {
            this._stopSlideshow();
            this._navigate('next');
        },
        previous: function() {
            this._stopSlideshow();
            this._navigate('prev');
        },
        jump: function(pos) {
            pos -= 1;
            if (pos === this.current || pos >= this.itemsCount || pos < 0) {
                return false;
            }
            this._stopSlideshow();
            this._navigate(pos > this.current ? 'next' : 'prev', pos);
        },
        play: function() {
            if (!this.isPlaying) {
                this.isPlaying = true;
                this._navigate('next');
                this.options.autoplay = true;
                this._startSlideshow();
            }
        },
        pause: function() {
            if (this.isPlaying) {
                this._stopSlideshow();
            }
        },
        isActive: function() {
            return this.isAnimating;
        },
        destroy: function(callback) {
            this._destroy(callback);
        }
    };
    $.Cuboid = function(config, pos) {
        this.config = config;
        this.pos = pos;
        this.side = 1;
        this._setSize();
        this._configureStyles();
    };
    $.Cuboid.prototype = {
        _setSize: function() {
            this.size = {
                width: this.config.o === 'v' ? Math.floor(this.config.size.width / this.config.cuboidsCount) : this.config.size.width,
                height: this.config.o === 'v' ? this.config.size.height : Math.floor(this.config.size.height / this.config.cuboidsCount)
            };
            this.extra = this.config.o === 'v' ? this.config.size.width - (this.size.width * this.config.cuboidsCount) : this.config.size.height - (this.size.height * this.config.cuboidsCount);
        },
        _configureStyles: function() {
            var middlepos = Math.ceil(this.config.cuboidsCount / 2),
                positionStyle = this.pos < middlepos ? {
                    zIndex: (this.pos + 1) * 100,
                    left: (this.config.o === 'v') ? this.size.width * this.pos : 0,
                    top: (this.config.o === 'v') ? 0 : this.size.height * this.pos
                } : {
                    zIndex: (this.config.cuboidsCount - this.pos) * 100,
                    left: (this.config.o === 'v') ? this.size.width * this.pos : 0,
                    top: (this.config.o === 'v') ? 0 : this.size.height * this.pos
                };
            this.disperseFactor = this.config.disperseFactor * ((this.pos + 1) - middlepos);
            this.style = $.extend({
                '-webkit-transition': '-webkit-transform ' + this.config.speed + 'ms ' + this.config.easing,
                '-moz-transition': '-moz-transform ' + this.config.speed + 'ms ' + this.config.easing,
                '-o-transition': '-o-transform ' + this.config.speed + 'ms ' + this.config.easing,
                '-ms-transition': '-ms-transform ' + this.config.speed + 'ms ' + this.config.easing,
                'transition': 'transform ' + this.config.speed + 'ms ' + this.config.easing
            }, positionStyle, this.size);
            this.animationStyles = {
                side1: (this.config.o === 'v') ? {
                    'transform': 'translate3d( 0, 0, -' + (this.size.height / 2) + 'px )'
                } : {
                    'transform': 'translate3d( 0, 0, -' + (this.size.width / 2) + 'px )'
                },
                side2: (this.config.o === 'v') ? {
                    'transform': 'translate3d( 0, 0, -' + (this.size.height / 2) + 'px ) rotate3d( 1, 0, 0, -90deg )'
                } : {
                    'transform': 'translate3d( 0, 0, -' + (this.size.width / 2) + 'px ) rotate3d( 0, 1, 0, -90deg )'
                },
                side3: (this.config.o === 'v') ? {
                    'transform': 'translate3d( 0, 0, -' + (this.size.height / 2) + 'px ) rotate3d( 1, 0, 0, -180deg )'
                } : {
                    'transform': 'translate3d( 0, 0, -' + (this.size.width / 2) + 'px ) rotate3d( 0, 1, 0, -180deg )'
                },
                side4: (this.config.o === 'v') ? {
                    'transform': 'translate3d( 0, 0, -' + (this.size.height / 2) + 'px ) rotate3d( 1, 0, 0, -270deg )'
                } : {
                    'transform': 'translate3d( 0, 0, -' + (this.size.width / 2) + 'px ) rotate3d( 0, 1, 0, -270deg )'
                }
            };
            var measure = (this.config.o === 'v') ? this.size.height : this.size.width;
            this.sidesStyles = {
                frontSideStyle: {
                    width: (this.config.o === 'v') ? this.size.width + this.extra : this.size.width,
                    height: (this.config.o === 'v') ? this.size.height : this.size.height + this.extra,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 0, 1, 0, 0deg ) translate3d( 0, 0, ' + (measure / 2) + 'px )'
                },
                backSideStyle: {
                    width: this.size.width,
                    height: this.size.height,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 0, 1, 0, 180deg ) translate3d( 0, 0, ' + (measure / 2) + 'px ) rotateZ( 180deg )'
                },
                rightSideStyle: {
                    width: measure,
                    height: (this.config.o === 'v') ? this.size.height : this.size.height + this.extra,
                    left: (this.config.o === 'v') ? this.size.width / 2 - this.size.height / 2 : 0,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 0, 1, 0, 90deg ) translate3d( 0, 0, ' + (this.size.width / 2) + 'px )'
                },
                leftSideStyle: {
                    width: measure,
                    height: (this.config.o === 'v') ? this.size.height : this.size.height + this.extra,
                    left: (this.config.o === 'v') ? this.size.width / 2 - this.size.height / 2 : 0,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 0, 1, 0, -90deg ) translate3d( 0, 0, ' + (this.size.width / 2) + 'px )'
                },
                topSideStyle: {
                    width: (this.config.o === 'v') ? this.size.width + this.extra : this.size.width,
                    height: measure,
                    top: (this.config.o === 'v') ? 0 : this.size.height / 2 - this.size.width / 2,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 1, 0, 0, 90deg ) translate3d( 0, 0, ' + (this.size.height / 2) + 'px )'
                },
                bottomSideStyle: {
                    width: (this.config.o === 'v') ? this.size.width + this.extra : this.size.width,
                    height: measure,
                    top: (this.config.o === 'v') ? 0 : this.size.height / 2 - this.size.width / 2,
                    backgroundColor: this.config.colorHiddenSides,
                    transform: 'rotate3d( 1, 0, 0, -90deg ) translate3d( 0, 0, ' + (this.size.height / 2) + 'px )'
                }
            };
        },
        getEl: function() {
            this.$el = $('<div/>').css(this.style).css(this.animationStyles.side1).append($('<div/>').addClass('sb-side').css(this.sidesStyles.frontSideStyle)).append($('<div/>').addClass('sb-side').css(this.sidesStyles.backSideStyle)).append($('<div/>').addClass('sb-side').css(this.sidesStyles.rightSideStyle)).append($('<div/>').addClass('sb-side').css(this.sidesStyles.leftSideStyle)).append($('<div/>').addClass('sb-side').css(this.sidesStyles.topSideStyle)).append($('<div/>').addClass('sb-side').css(this.sidesStyles.bottomSideStyle));
            this._showImage(this.config.prev);
            return this.$el;
        },
        _showImage: function(imgPos) {
            var sideIdx, $item = this.config.items.eq(imgPos),
                imgParam = {
                    'background-size': this.config.size.width + 'px ' + this.config.size.height + 'px'
                };
            imgParam.backgroundImage = 'url(' + $item.find('img').attr('src') + ')';
            switch (this.side) {
                case 1:
                    sideIdx = 0;
                    break;
                case 2:
                    sideIdx = (this.config.o === 'v') ? 4 : 2;
                    break;
                case 3:
                    sideIdx = 1;
                    break;
                case 4:
                    sideIdx = (this.config.o === 'v') ? 5 : 3;
                    break;
            };
            imgParam.backgroundPosition = (this.config.o === 'v') ? -(this.pos * this.size.width) + 'px 0px' : '0px -' + (this.pos * this.size.height) + 'px';
            this.$el.children().eq(sideIdx).css(imgParam);
        },
        rotate: function(callback) {
            var self = this,
                animationStyle;
            setTimeout(function() {
                if (self.config.direction === 'next') {
                    switch (self.side) {
                        case 1:
                            animationStyle = self.animationStyles.side2;
                            self.side = 2;
                            break;
                        case 2:
                            animationStyle = self.animationStyles.side3;
                            self.side = 3;
                            break;
                        case 3:
                            animationStyle = self.animationStyles.side4;
                            self.side = 4;
                            break;
                        case 4:
                            animationStyle = self.animationStyles.side1;
                            self.side = 1;
                            break;
                    };
                } else {
                    switch (self.side) {
                        case 1:
                            animationStyle = self.animationStyles.side4;
                            self.side = 4;
                            break;
                        case 2:
                            animationStyle = self.animationStyles.side1;
                            self.side = 1;
                            break;
                        case 3:
                            animationStyle = self.animationStyles.side2;
                            self.side = 2;
                            break;
                        case 4:
                            animationStyle = self.animationStyles.side3;
                            self.side = 3;
                            break;
                    };
                }
                self._showImage(self.config.current);
                var animateOut = {},
                    animateIn = {};
                if (self.config.o === 'v') {
                    animateOut.left = '+=' + self.disperseFactor + 'px';
                    animateIn.left = '-=' + self.disperseFactor + 'px';
                } else if (self.config.o === 'h') {
                    animateOut.top = '+=' + self.disperseFactor + 'px';
                    animateIn.top = '-=' + self.disperseFactor + 'px';
                }
                self.$el.css(animationStyle).animate(animateOut, self.config.speed / 2).animate(animateIn, self.config.speed / 2, function() {
                    if (callback) {
                        callback.call(self, self.pos);
                    }
                });
            }, this.config.sequentialFactor * this.pos + 30);
        }
    };
    var logError = function(message) {
        if (window.console) {
            window.console.error(message);
        }
    };
    $.fn.slicebox = function(options) {
        var self = $.data(this, 'slicebox');
        if (typeof options === 'string') {
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                if (!self) {
                    logError("cannot call methods on slicebox prior to initialization; " + "attempted to call method '" + options + "'");
                    return;
                }
                if (!$.isFunction(self[options]) || options.charAt(0) === "_") {
                    logError("no such method '" + options + "' for slicebox self");
                    return;
                }
                self[options].apply(self, args);
            });
        } else {
            this.each(function() {
                if (self) {
                    self._init();
                } else {
                    self = $.data(this, 'slicebox', new $.Slicebox(options, this));
                }
            });
        }
        return self;
    };
})(jQuery, window);;
(function() {
    var slice = [].slice;
    (function($, window) {
        "use strict";
        var BootstrapSwitch;
        BootstrapSwitch = (function() {
            function BootstrapSwitch(element, options) {
                if (options == null) {
                    options = {};
                }
                this.$element = $(element);
                this.options = $.extend({}, $.fn.bootstrapSwitch.defaults, {
                    state: this.$element.is(":checked"),
                    size: this.$element.data("size"),
                    animate: this.$element.data("animate"),
                    disabled: this.$element.is(":disabled"),
                    readonly: this.$element.is("[readonly]"),
                    indeterminate: this.$element.data("indeterminate"),
                    inverse: this.$element.data("inverse"),
                    radioAllOff: this.$element.data("radio-all-off"),
                    onColor: this.$element.data("on-color"),
                    offColor: this.$element.data("off-color"),
                    onText: this.$element.data("on-text"),
                    offText: this.$element.data("off-text"),
                    labelText: this.$element.data("label-text"),
                    handleWidth: this.$element.data("handle-width"),
                    labelWidth: this.$element.data("label-width"),
                    baseClass: this.$element.data("base-class"),
                    wrapperClass: this.$element.data("wrapper-class")
                }, options);
                this.prevOptions = {};
                this.$wrapper = $("<div>", {
                    "class": (function(_this) {
                        return function() {
                            var classes;
                            classes = ["" + _this.options.baseClass].concat(_this._getClasses(_this.options.wrapperClass));
                            classes.push(_this.options.state ? _this.options.baseClass + "-on" : _this.options.baseClass + "-off");
                            if (_this.options.size != null) {
                                classes.push(_this.options.baseClass + "-" + _this.options.size);
                            }
                            if (_this.options.disabled) {
                                classes.push(_this.options.baseClass + "-disabled");
                            }
                            if (_this.options.readonly) {
                                classes.push(_this.options.baseClass + "-readonly");
                            }
                            if (_this.options.indeterminate) {
                                classes.push(_this.options.baseClass + "-indeterminate");
                            }
                            if (_this.options.inverse) {
                                classes.push(_this.options.baseClass + "-inverse");
                            }
                            if (_this.$element.attr("id")) {
                                classes.push(_this.options.baseClass + "-id-" + (_this.$element.attr("id")));
                            }
                            return classes.join(" ");
                        };
                    })(this)()
                });
                this.$container = $("<div>", {
                    "class": this.options.baseClass + "-container"
                });
                this.$on = $("<span>", {
                    html: this.options.onText,
                    "class": this.options.baseClass + "-handle-on " + this.options.baseClass + "-" + this.options.onColor
                });
                this.$off = $("<span>", {
                    html: this.options.offText,
                    "class": this.options.baseClass + "-handle-off " + this.options.baseClass + "-" + this.options.offColor
                });
                this.$label = $("<span>", {
                    html: this.options.labelText,
                    "class": this.options.baseClass + "-label"
                });
                this.$element.on("init.bootstrapSwitch", (function(_this) {
                    return function() {
                        return _this.options.onInit.apply(element, arguments);
                    };
                })(this));
                this.$element.on("switchChange.bootstrapSwitch", (function(_this) {
                    return function(e) {
                        if (false === _this.options.onSwitchChange.apply(element, arguments)) {
                            if (_this.$element.is(":radio")) {
                                return $("[name='" + (_this.$element.attr('name')) + "']").trigger("previousState.bootstrapSwitch", true);
                            } else {
                                return _this.$element.trigger("previousState.bootstrapSwitch", true);
                            }
                        }
                    };
                })(this));
                this.$container = this.$element.wrap(this.$container).parent();
                this.$wrapper = this.$container.wrap(this.$wrapper).parent();
                this.$element.before(this.options.inverse ? this.$off : this.$on).before(this.$label).before(this.options.inverse ? this.$on : this.$off);
                if (this.options.indeterminate) {
                    this.$element.prop("indeterminate", true);
                }
                this._init();
                this._elementHandlers();
                this._handleHandlers();
                this._labelHandlers();
                this._formHandler();
                this._externalLabelHandler();
                this.$element.trigger("init.bootstrapSwitch", this.options.state);
            }
            BootstrapSwitch.prototype._constructor = BootstrapSwitch;
            BootstrapSwitch.prototype.setPrevOptions = function() {
                return this.prevOptions = $.extend(true, {}, this.options);
            };
            BootstrapSwitch.prototype.state = function(value, skip) {
                if (typeof value === "undefined") {
                    return this.options.state;
                }
                if (this.options.disabled || this.options.readonly) {
                    return this.$element;
                }
                if (this.options.state && !this.options.radioAllOff && this.$element.is(":radio")) {
                    return this.$element;
                }
                if (this.$element.is(":radio")) {
                    $("[name='" + (this.$element.attr('name')) + "']").trigger("setPreviousOptions.bootstrapSwitch");
                } else {
                    this.$element.trigger("setPreviousOptions.bootstrapSwitch");
                }
                if (this.options.indeterminate) {
                    this.indeterminate(false);
                }
                value = !!value;
                this.$element.prop("checked", value).trigger("change.bootstrapSwitch", skip);
                return this.$element;
            };
            BootstrapSwitch.prototype.toggleState = function(skip) {
                if (this.options.disabled || this.options.readonly) {
                    return this.$element;
                }
                if (this.options.indeterminate) {
                    this.indeterminate(false);
                    return this.state(true);
                } else {
                    return this.$element.prop("checked", !this.options.state).trigger("change.bootstrapSwitch", skip);
                }
            };
            BootstrapSwitch.prototype.size = function(value) {
                if (typeof value === "undefined") {
                    return this.options.size;
                }
                if (this.options.size != null) {
                    this.$wrapper.removeClass(this.options.baseClass + "-" + this.options.size);
                }
                if (value) {
                    this.$wrapper.addClass(this.options.baseClass + "-" + value);
                }
                this._width();
                this._containerPosition();
                this.options.size = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.animate = function(value) {
                if (typeof value === "undefined") {
                    return this.options.animate;
                }
                value = !!value;
                if (value === this.options.animate) {
                    return this.$element;
                }
                return this.toggleAnimate();
            };
            BootstrapSwitch.prototype.toggleAnimate = function() {
                this.options.animate = !this.options.animate;
                this.$wrapper.toggleClass(this.options.baseClass + "-animate");
                return this.$element;
            };
            BootstrapSwitch.prototype.disabled = function(value) {
                if (typeof value === "undefined") {
                    return this.options.disabled;
                }
                value = !!value;
                if (value === this.options.disabled) {
                    return this.$element;
                }
                return this.toggleDisabled();
            };
            BootstrapSwitch.prototype.toggleDisabled = function() {
                this.options.disabled = !this.options.disabled;
                this.$element.prop("disabled", this.options.disabled);
                this.$wrapper.toggleClass(this.options.baseClass + "-disabled");
                return this.$element;
            };
            BootstrapSwitch.prototype.readonly = function(value) {
                if (typeof value === "undefined") {
                    return this.options.readonly;
                }
                value = !!value;
                if (value === this.options.readonly) {
                    return this.$element;
                }
                return this.toggleReadonly();
            };
            BootstrapSwitch.prototype.toggleReadonly = function() {
                this.options.readonly = !this.options.readonly;
                this.$element.prop("readonly", this.options.readonly);
                this.$wrapper.toggleClass(this.options.baseClass + "-readonly");
                return this.$element;
            };
            BootstrapSwitch.prototype.indeterminate = function(value) {
                if (typeof value === "undefined") {
                    return this.options.indeterminate;
                }
                value = !!value;
                if (value === this.options.indeterminate) {
                    return this.$element;
                }
                return this.toggleIndeterminate();
            };
            BootstrapSwitch.prototype.toggleIndeterminate = function() {
                this.options.indeterminate = !this.options.indeterminate;
                this.$element.prop("indeterminate", this.options.indeterminate);
                this.$wrapper.toggleClass(this.options.baseClass + "-indeterminate");
                this._containerPosition();
                return this.$element;
            };
            BootstrapSwitch.prototype.inverse = function(value) {
                if (typeof value === "undefined") {
                    return this.options.inverse;
                }
                value = !!value;
                if (value === this.options.inverse) {
                    return this.$element;
                }
                return this.toggleInverse();
            };
            BootstrapSwitch.prototype.toggleInverse = function() {
                var $off, $on;
                this.$wrapper.toggleClass(this.options.baseClass + "-inverse");
                $on = this.$on.clone(true);
                $off = this.$off.clone(true);
                this.$on.replaceWith($off);
                this.$off.replaceWith($on);
                this.$on = $off;
                this.$off = $on;
                this.options.inverse = !this.options.inverse;
                return this.$element;
            };
            BootstrapSwitch.prototype.onColor = function(value) {
                var color;
                color = this.options.onColor;
                if (typeof value === "undefined") {
                    return color;
                }
                if (color != null) {
                    this.$on.removeClass(this.options.baseClass + "-" + color);
                }
                this.$on.addClass(this.options.baseClass + "-" + value);
                this.options.onColor = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.offColor = function(value) {
                var color;
                color = this.options.offColor;
                if (typeof value === "undefined") {
                    return color;
                }
                if (color != null) {
                    this.$off.removeClass(this.options.baseClass + "-" + color);
                }
                this.$off.addClass(this.options.baseClass + "-" + value);
                this.options.offColor = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.onText = function(value) {
                if (typeof value === "undefined") {
                    return this.options.onText;
                }
                this.$on.html(value);
                this._width();
                this._containerPosition();
                this.options.onText = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.offText = function(value) {
                if (typeof value === "undefined") {
                    return this.options.offText;
                }
                this.$off.html(value);
                this._width();
                this._containerPosition();
                this.options.offText = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.labelText = function(value) {
                if (typeof value === "undefined") {
                    return this.options.labelText;
                }
                this.$label.html(value);
                this._width();
                this.options.labelText = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.handleWidth = function(value) {
                if (typeof value === "undefined") {
                    return this.options.handleWidth;
                }
                this.options.handleWidth = value;
                this._width();
                this._containerPosition();
                return this.$element;
            };
            BootstrapSwitch.prototype.labelWidth = function(value) {
                if (typeof value === "undefined") {
                    return this.options.labelWidth;
                }
                this.options.labelWidth = value;
                this._width();
                this._containerPosition();
                return this.$element;
            };
            BootstrapSwitch.prototype.baseClass = function(value) {
                return this.options.baseClass;
            };
            BootstrapSwitch.prototype.wrapperClass = function(value) {
                if (typeof value === "undefined") {
                    return this.options.wrapperClass;
                }
                if (!value) {
                    value = $.fn.bootstrapSwitch.defaults.wrapperClass;
                }
                this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(" "));
                this.$wrapper.addClass(this._getClasses(value).join(" "));
                this.options.wrapperClass = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.radioAllOff = function(value) {
                if (typeof value === "undefined") {
                    return this.options.radioAllOff;
                }
                value = !!value;
                if (value === this.options.radioAllOff) {
                    return this.$element;
                }
                this.options.radioAllOff = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.onInit = function(value) {
                if (typeof value === "undefined") {
                    return this.options.onInit;
                }
                if (!value) {
                    value = $.fn.bootstrapSwitch.defaults.onInit;
                }
                this.options.onInit = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.onSwitchChange = function(value) {
                if (typeof value === "undefined") {
                    return this.options.onSwitchChange;
                }
                if (!value) {
                    value = $.fn.bootstrapSwitch.defaults.onSwitchChange;
                }
                this.options.onSwitchChange = value;
                return this.$element;
            };
            BootstrapSwitch.prototype.destroy = function() {
                var $form;
                $form = this.$element.closest("form");
                if ($form.length) {
                    $form.off("reset.bootstrapSwitch").removeData("bootstrap-switch");
                }
                this.$container.children().not(this.$element).remove();
                this.$element.unwrap().unwrap().off(".bootstrapSwitch").removeData("bootstrap-switch");
                return this.$element;
            };
            BootstrapSwitch.prototype._width = function() {
                var $handles, handleWidth;
                $handles = this.$on.add(this.$off);
                $handles.add(this.$label).css("width", "");
                handleWidth = this.options.handleWidth === "auto" ? Math.max(this.$on.width(), this.$off.width()) : this.options.handleWidth;
                $handles.width(handleWidth);
                this.$label.width((function(_this) {
                    return function(index, width) {
                        if (_this.options.labelWidth !== "auto") {
                            return _this.options.labelWidth;
                        }
                        if (width < handleWidth) {
                            return handleWidth;
                        } else {
                            return width;
                        }
                    };
                })(this));
                this._handleWidth = this.$on.outerWidth();
                this._labelWidth = this.$label.outerWidth();
                this.$container.width((this._handleWidth * 2) + this._labelWidth + 1);
                return this.$wrapper.width(this._handleWidth + this._labelWidth + 1);
            };
            BootstrapSwitch.prototype._containerPosition = function(state, callback) {
                if (state == null) {
                    state = this.options.state;
                }
                this.$container.css("margin-left", (function(_this) {
                    return function() {
                        var values;
                        values = [0, "-" + _this._handleWidth + "px"];
                        if (_this.options.indeterminate) {
                            return "-" + (_this._handleWidth / 2) + "px";
                        }
                        if (state) {
                            if (_this.options.inverse) {
                                return values[1];
                            } else {
                                return values[0];
                            }
                        } else {
                            if (_this.options.inverse) {
                                return values[0];
                            } else {
                                return values[1];
                            }
                        }
                    };
                })(this));
                if (!callback) {
                    return;
                }
                return setTimeout(function() {
                    return callback();
                }, 50);
            };
            BootstrapSwitch.prototype._init = function() {
                var init, initInterval;
                init = (function(_this) {
                    return function() {
                        _this.setPrevOptions();
                        _this._width();
                        return _this._containerPosition(null, function() {
                            if (_this.options.animate) {
                                return _this.$wrapper.addClass(_this.options.baseClass + "-animate");
                            }
                        });
                    };
                })(this);
                if (this.$wrapper.is(":visible")) {
                    return init();
                }
                return initInterval = window.setInterval((function(_this) {
                    return function() {
                        if (_this.$wrapper.is(":visible")) {
                            init();
                            return window.clearInterval(initInterval);
                        }
                    };
                })(this), 50);
            };
            BootstrapSwitch.prototype._elementHandlers = function() {
                return this.$element.on({
                    "setPreviousOptions.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            return _this.setPrevOptions();
                        };
                    })(this),
                    "previousState.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            _this.options = _this.prevOptions;
                            if (_this.options.indeterminate) {
                                _this.$wrapper.addClass(_this.options.baseClass + "-indeterminate");
                            }
                            return _this.$element.prop("checked", _this.options.state).trigger("change.bootstrapSwitch", true);
                        };
                    })(this),
                    "change.bootstrapSwitch": (function(_this) {
                        return function(e, skip) {
                            var state;
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            state = _this.$element.is(":checked");
                            _this._containerPosition(state);
                            if (state === _this.options.state) {
                                return;
                            }
                            _this.options.state = state;
                            _this.$wrapper.toggleClass(_this.options.baseClass + "-off").toggleClass(_this.options.baseClass + "-on");
                            if (!skip) {
                                if (_this.$element.is(":radio")) {
                                    $("[name='" + (_this.$element.attr('name')) + "']").not(_this.$element).prop("checked", false).trigger("change.bootstrapSwitch", true);
                                }
                                return _this.$element.trigger("switchChange.bootstrapSwitch", [state]);
                            }
                        };
                    })(this),
                    "focus.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            e.preventDefault();
                            return _this.$wrapper.addClass(_this.options.baseClass + "-focused");
                        };
                    })(this),
                    "blur.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            e.preventDefault();
                            return _this.$wrapper.removeClass(_this.options.baseClass + "-focused");
                        };
                    })(this),
                    "keydown.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            if (!e.which || _this.options.disabled || _this.options.readonly) {
                                return;
                            }
                            switch (e.which) {
                                case 37:
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                    return _this.state(false);
                                case 39:
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                    return _this.state(true);
                            }
                        };
                    })(this)
                });
            };
            BootstrapSwitch.prototype._handleHandlers = function() {
                this.$on.on("click.bootstrapSwitch", (function(_this) {
                    return function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        _this.state(false);
                        return _this.$element.trigger("focus.bootstrapSwitch");
                    };
                })(this));
                return this.$off.on("click.bootstrapSwitch", (function(_this) {
                    return function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        _this.state(true);
                        return _this.$element.trigger("focus.bootstrapSwitch");
                    };
                })(this));
            };
            BootstrapSwitch.prototype._labelHandlers = function() {
                return this.$label.on({
                    "click": function(e) {
                        return e.stopPropagation();
                    },
                    "mousedown.bootstrapSwitch touchstart.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            if (_this._dragStart || _this.options.disabled || _this.options.readonly) {
                                return;
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            _this._dragStart = (e.pageX || e.originalEvent.touches[0].pageX) - parseInt(_this.$container.css("margin-left"), 10);
                            if (_this.options.animate) {
                                _this.$wrapper.removeClass(_this.options.baseClass + "-animate");
                            }
                            return _this.$element.trigger("focus.bootstrapSwitch");
                        };
                    })(this),
                    "mousemove.bootstrapSwitch touchmove.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            var difference;
                            if (_this._dragStart == null) {
                                return;
                            }
                            e.preventDefault();
                            difference = (e.pageX || e.originalEvent.touches[0].pageX) - _this._dragStart;
                            if (difference < -_this._handleWidth || difference > 0) {
                                return;
                            }
                            _this._dragEnd = difference;
                            return _this.$container.css("margin-left", _this._dragEnd + "px");
                        };
                    })(this),
                    "mouseup.bootstrapSwitch touchend.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            var state;
                            if (!_this._dragStart) {
                                return;
                            }
                            e.preventDefault();
                            if (_this.options.animate) {
                                _this.$wrapper.addClass(_this.options.baseClass + "-animate");
                            }
                            if (_this._dragEnd) {
                                state = _this._dragEnd > -(_this._handleWidth / 2);
                                _this._dragEnd = false;
                                _this.state(_this.options.inverse ? !state : state);
                            } else {
                                _this.state(!_this.options.state);
                            }
                            return _this._dragStart = false;
                        };
                    })(this),
                    "mouseleave.bootstrapSwitch": (function(_this) {
                        return function(e) {
                            return _this.$label.trigger("mouseup.bootstrapSwitch");
                        };
                    })(this)
                });
            };
            BootstrapSwitch.prototype._externalLabelHandler = function() {
                var $externalLabel;
                $externalLabel = this.$element.closest("label");
                return $externalLabel.on("click", (function(_this) {
                    return function(event) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        if (event.target === $externalLabel[0]) {
                            return _this.toggleState();
                        }
                    };
                })(this));
            };
            BootstrapSwitch.prototype._formHandler = function() {
                var $form;
                $form = this.$element.closest("form");
                if ($form.data("bootstrap-switch")) {
                    return;
                }
                return $form.on("reset.bootstrapSwitch", function() {
                    return window.setTimeout(function() {
                        return $form.find("input").filter(function() {
                            return $(this).data("bootstrap-switch");
                        }).each(function() {
                            return $(this).bootstrapSwitch("state", this.checked);
                        });
                    }, 1);
                }).data("bootstrap-switch", true);
            };
            BootstrapSwitch.prototype._getClasses = function(classes) {
                var c, cls, i, len;
                if (!$.isArray(classes)) {
                    return [this.options.baseClass + "-" + classes];
                }
                cls = [];
                for (i = 0, len = classes.length; i < len; i++) {
                    c = classes[i];
                    cls.push(this.options.baseClass + "-" + c);
                }
                return cls;
            };
            return BootstrapSwitch;
        })();
        $.fn.bootstrapSwitch = function() {
            var args, option, ret;
            option = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            ret = this;
            this.each(function() {
                var $this, data;
                $this = $(this);
                data = $this.data("bootstrap-switch");
                if (!data) {
                    $this.data("bootstrap-switch", data = new BootstrapSwitch(this, option));
                }
                if (typeof option === "string") {
                    return ret = data[option].apply(data, args);
                }
            });
            return ret;
        };
        $.fn.bootstrapSwitch.Constructor = BootstrapSwitch;
        return $.fn.bootstrapSwitch.defaults = {
            state: true,
            size: null,
            animate: true,
            disabled: false,
            readonly: false,
            indeterminate: false,
            inverse: false,
            radioAllOff: false,
            onColor: "primary",
            offColor: "default",
            onText: "ON",
            offText: "OFF",
            labelText: "&nbsp;",
            handleWidth: "auto",
            labelWidth: "auto",
            baseClass: "bootstrap-switch",
            wrapperClass: "wrapper",
            onInit: function() {},
            onSwitchChange: function() {}
        };
    })(window.jQuery, window);
}).call(this);;
/*!
Autosize 3.0.13
license: MIT
http://www.jacklmoore.com/autosize
*/
(function(global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['exports', 'module'], factory);
    } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
        factory(exports, module);
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, mod);
        global.autosize = mod.exports;
    }
})(this, function(exports, module) {
    'use strict';
    var set = typeof Set === 'function' ? new Set() : (function() {
        var list = [];
        return {
            has: function has(key) {
                return Boolean(list.indexOf(key) > -1);
            },
            add: function add(key) {
                list.push(key);
            },
            'delete': function _delete(key) {
                list.splice(list.indexOf(key), 1);
            }
        };
    })();

    function assign(ta) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];
        var _ref$setOverflowX = _ref.setOverflowX;
        var setOverflowX = _ref$setOverflowX === undefined ? true : _ref$setOverflowX;
        var _ref$setOverflowY = _ref.setOverflowY;
        var setOverflowY = _ref$setOverflowY === undefined ? true : _ref$setOverflowY;
        if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || set.has(ta)) return;
        var heightOffset = null;
        var overflowY = null;
        var clientWidth = ta.clientWidth;

        function init() {
            var style = window.getComputedStyle(ta, null);
            overflowY = style.overflowY;
            if (style.resize === 'vertical') {
                ta.style.resize = 'none';
            } else if (style.resize === 'both') {
                ta.style.resize = 'horizontal';
            }
            if (style.boxSizing === 'content-box') {
                heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
            } else {
                heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
            }
            if (isNaN(heightOffset)) {
                heightOffset = 0;
            }
            update();
        }

        function changeOverflow(value) {
            {
                var width = ta.style.width;
                ta.style.width = '0px';
                ta.offsetWidth;
                ta.style.width = width;
            }
            overflowY = value;
            if (setOverflowY) {
                ta.style.overflowY = value;
            }
            resize();
        }

        function resize() {
            var htmlTop = window.pageYOffset;
            var bodyTop = document.body.scrollTop;
            var originalHeight = ta.style.height;
            ta.style.height = 'auto';
            var endHeight = ta.scrollHeight + heightOffset;
            if (ta.scrollHeight === 0) {
                ta.style.height = originalHeight;
                return;
            }
            ta.style.height = endHeight + 'px';
            clientWidth = ta.clientWidth;
            document.documentElement.scrollTop = htmlTop;
            document.body.scrollTop = bodyTop;
        }

        function update() {
            var startHeight = ta.style.height;
            resize();
            var style = window.getComputedStyle(ta, null);
            if (style.height !== ta.style.height) {
                if (overflowY !== 'visible') {
                    changeOverflow('visible');
                }
            } else {
                if (overflowY !== 'hidden') {
                    changeOverflow('hidden');
                }
            }
            if (startHeight !== ta.style.height) {
                var evt = document.createEvent('Event');
                evt.initEvent('autosize:resized', true, false);
                ta.dispatchEvent(evt);
            }
        }
        var pageResize = function pageResize() {
            if (ta.clientWidth !== clientWidth) {
                update();
            }
        };
        var destroy = (function(style) {
            window.removeEventListener('resize', pageResize);
            ta.removeEventListener('input', update);
            ta.removeEventListener('keyup', update);
            ta.removeEventListener('autosize:destroy', destroy);
            set['delete'](ta);
            Object.keys(style).forEach(function(key) {
                ta.style[key] = style[key];
            });
        }).bind(ta, {
            height: ta.style.height,
            resize: ta.style.resize,
            overflowY: ta.style.overflowY,
            overflowX: ta.style.overflowX,
            wordWrap: ta.style.wordWrap
        });
        ta.addEventListener('autosize:destroy', destroy);
        if ('onpropertychange' in ta && 'oninput' in ta) {
            ta.addEventListener('keyup', update);
        }
        window.addEventListener('resize', pageResize);
        ta.addEventListener('input', update);
        ta.addEventListener('autosize:update', update);
        set.add(ta);
        if (setOverflowX) {
            ta.style.overflowX = 'hidden';
            ta.style.wordWrap = 'break-word';
        }
        init();
    }

    function destroy(ta) {
        if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
        var evt = document.createEvent('Event');
        evt.initEvent('autosize:destroy', true, false);
        ta.dispatchEvent(evt);
    }

    function update(ta) {
        if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
        var evt = document.createEvent('Event');
        evt.initEvent('autosize:update', true, false);
        ta.dispatchEvent(evt);
    }
    var autosize = null;
    if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
        autosize = function(el) {
            return el;
        };
        autosize.destroy = function(el) {
            return el;
        };
        autosize.update = function(el) {
            return el;
        };
    } else {
        autosize = function(el, options) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], function(x) {
                    return assign(x, options);
                });
            }
            return el;
        };
        autosize.destroy = function(el) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], destroy);
            }
            return el;
        };
        autosize.update = function(el) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], update);
            }
            return el;
        };
    }
    module.exports = autosize;
});;

function sending() {
    var text = $('#box').val();
    var detailsText = '\n\n';
    if (text.trim()) {
        if ($('#include_details').prop('checked')) {
            for (var key in editor.optionsObject.details) {
                if (editor.optionsObject.details[key]) {
                    if (key === 'character_count_no_spaces') {
                        detailsText += $('#' + key).parent('li').data('title') + ' - ' + editor.count['chars_no_spaces'] + '\n';
                    } else {
                        detailsText += $('#' + key).parent('li').data('title') + ' - ' + editor.count[key] + '\n';
                    }
                }
            }
            text += detailsText;
        }
        $("#save-to-drive-btn").addClass('loading');
        var file = new Blob([text], {
            type: "text/plain;charset=utf-8"
        });
        auth(file);
    } else {
        alert("Text area can't be empty!");
    }
}

function auth(file) {
    var config = {
        'client_id': google_client_id,
        'scope': "https://www.googleapis.com/auth/drive"
    };
    gapi.auth.authorize(config, function() {
        insertFile(file);
    });
}

function getDate() {
    var today = new Date();
    var h = today.getHours();
    var m = today.getMinutes();
    var s = today.getSeconds();
    var dd = today.getDate();
    var mm = today.getMonth() + 1;
    var yyyy = today.getFullYear();
    if (dd < 10) dd = '0' + dd;
    if (mm < 10) mm = '0' + mm;
    return h + ":" + m + ":" + s + " " + mm + '/' + dd + '/' + yyyy;
}

function insertFile(fileData, callback) {
    var timer = null;
    var boundary = '-------314159265358979323846';
    var delimiter = "\r\n--" + boundary + "\r\n";
    var close_delim = "\r\n--" + boundary + "--";
    var reader = new FileReader();
    reader.readAsBinaryString(fileData);
    reader.onload = function(e) {
        var contentType = fileData.type || "application/octet-stream";
        var metadata = {
            'title': $('#file_name').val() + '_' + getDate(),
            'mimeType': contentType
        };
        var base64Data = btoa(reader.result);
        var multipartRequestBody = delimiter + 'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(metadata) +
            delimiter + 'Content-Type: ' + contentType + '\r\n' + 'Content-Transfer-Encoding: base64\r\n' + '\r\n' +
            base64Data +
            close_delim;
        var request = gapi.client.request({
            'path': '/upload/drive/v2/files/',
            'method': 'POST',
            'params': {
                'uploadType': 'multipart'
            },
            'headers': {
                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
            },
            'body': multipartRequestBody
        });
        if (!callback) {
            callback = function(file) {
                var messageBox = $('#message_for_save_to_google_drive');
                if (typeof file.error !== 'undefined') {
                    messageBox.html('<div class="alert alert-danger" style="display: none" id="google_drive_message">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.error + ' </strong>' + editor.selectedLanguage.save_to_drive_error_msg + '</div>');
                } else {
                    messageBox.html('<div class="alert alert-success" style="display: none" id="google_drive_message">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.success + ' </strong><a href="' + file.alternateLink + '" target="_blank">' + editor.selectedLanguage.your_document + '</a> ' + editor.selectedLanguage.has_been_saved_to_Google_Drive + '</div>');
                    $('#google_drive_message').slideDown();
                    setTimeout(function() {
                        $('#google_drive_message').slideUp();
                    }, 10000);
                    $("#save-to-drive-btn").removeClass('loading');
                    $("#save-to-drive-btn").addClass('success');
                    setTimeout(function() {
                        $("#save-to-drive-btn").removeClass('success');
                    }, 3000);
                }
            };
        }
        request.execute(callback);
        setTimeout(function() {
            $("#save-to-drive-btn").removeClass('loading');
        }, 4000);
    };
};

function typingGame() {
    this.navArrows = $('#nav-arrows');
    this.slider = $('body #sb-slider');
    this.shirtText = $("#shirt-text");
    this.validate_rules = {
        "min_length": 2,
        "max_length": false
    };
    this.loadGame = function() {
        var $this = this;
        this.slicebox = this.slider.slicebox({
            orientation: 'r',
            cuboidsRandom: true,
            onReady: function() {
                $this.load(false);
            }
        });
        $("#skip a").on("click", function() {
            $this.next();
            $this.shirtText.removeClass('danger').focus();
        });
        this.shirtText.on("focus", function() {
            $(this).removeClass('danger');
        })
    };
    this.init = function(initSlice) {
        var $this = this;
        if (initSlice) {
            this.loadGame();
            this.initNext();
        } else {
            this.loadImage();
        }
        if ($.cookie('points'))
            $('#points').html($.cookie('points'));
        this.shirtText.focus();
    };
    this.initNext = function() {
        var $this = this;
        this.navArrows.children(':first').on('click', function() {
            if ($this.validate()) {
                $this.next();
                $this.shirtText.removeClass('danger').focus();
            }
            return false;
        });
    };
    this.load = function(status) {
        if (status) {
            $('#playingGame>div:first-child').removeClass('hidden');
            $('#playingGame>div:not(:first-child)').css('opacity', 0).css('z-index', '-10');
        } else {
            $('#playingGame>div:first-child').addClass('hidden');
            $('#playingGame>div:not(:first-child)').css('opacity', 1).css('z-index', '1');
        }
    }
}
typingGame.prototype.next = function() {
    if (this.slider.children('li:last-child').hasClass('sb-current')) {
        this.load(true);
        this.init(false);
    } else {
        this.slicebox.next();
    }
};
typingGame.prototype.validate = function() {
    var txt = $("#shirt-text").val().trim();
    if (txt && txt.length >= this.validate_rules["min_length"] && (this.validate_rules["max_length"] === false || txt.length <= this.validate_rules["max_length"])) {
        this.sendStatistic();
        $("#shirt-text").val('');
        $('#points').html($.cookie('points'));
        return true;
    } else {
        $("#shirt-text").addClass('danger');
        return false
    }
};
typingGame.prototype.sendStatistic = function() {
    var img_data = this.slider.children(".sb-current");
    if ($.cookie('points')) {
        points = parseInt($.cookie('points')) + 1;
    } else {
        points = 1;
    }
    $.cookie('points', points, {
        expires: 365
    });
    $.ajax({
        type: "POST",
        url: "https://teespy.com/app/api/save-shirt-text",
        dataType: "json",
        data: {
            "campaign_id": img_data.attr("data-campaign-id"),
            "front_or_back": img_data.attr("data-front-or-back"),
            "text": $("#shirt-text").val()
        }
    });
};
typingGame.prototype.checkLoadedImages = function(campaignId, position) {
    var imagesList = {};
    if ($.cookie('loadedImages'))
        imagesList = JSON.parse($.cookie('loadedImages'));
    if (!imagesList[position + "_" + campaignId]) {
        imagesList[position + "_" + campaignId] = 1;
        $.cookie('loadedImages', JSON.stringify(imagesList), {
            expires: 365
        });
        return true;
    }
    return false;
};
typingGame.prototype.loadImage = function() {
    var $this = this;
    var slider = this.slider;
    $.ajax({
        type: "GET",
        url: "https://teespy.com/app/api/get-random-shirts",
        dataType: "json",
        async: true
    }).done(function(responseData) {
        slider.html(null);
        $.each(responseData, function(key, data) {
            if ($this.checkLoadedImages(data["campaign_id"], data["front_or_back"])) {
                slider.append('<li data-campaign-id=' + data["campaign_id"] + ' data-front-or-back=' + data["front_or_back"] + '><img src="' + data.image_url + '" alt="shirt image"/></li>');
            }
        });
        $.ajax({
            type: "GET",
            url: "https://teespy.com/app/api/get-random-shirts",
            dataType: "json",
            async: true
        });
        if (slider.children('li').length < 1)
            $this.init(false);
        else
            $this.init(true);
    });
};
var typingGame = new typingGame();;

function DaleChallIndex(text, sentence_count) {
    this.text = text;
    this.sentence_count = sentence_count;
}
DaleChallIndex.prototype.getReadingLevel = function() {
    var readability;
    var index = this.getIndex();
    if (index > 10) {
        readability = editor.selectedLanguage.college_graduate;
    } else if (index > 9) {
        readability = editor.selectedLanguage.college_student;
    } else if (index > 8) {
        readability = editor.selectedLanguage['11_12th_grade'];
    } else if (index > 7) {
        readability = editor.selectedLanguage['9_10th_grade'];
    } else if (index > 6) {
        readability = editor.selectedLanguage['7_8th_grade'];
    } else if (index > 5) {
        readability = editor.selectedLanguage['5_6th_grade'];
    } else {
        readability = editor.selectedLanguage['<_4th_grade'];
    }
    return readability;
};
DaleChallIndex.prototype.getIndex = function() {
    var difficult_words = this.getDifficultWords();
    var word_list = this.getWordList(),
        dale_chall_index;
    if (word_list.length != 0) {
        dale_chall_index = 0.1579 * (100.0 * difficult_words.length / word_list.length) + 0.0496 * (word_list.length / this.sentence_count);
        if (difficult_words.length / word_list.length > 0.05)
            dale_chall_index += 3.6365;
        dale_chall_index = Math.round(dale_chall_index * 10) / 10;
        percentage_difficult_words = Math.round(100 * difficult_words.length / word_list.length);
    } else {
        dale_chall_index = 0;
    }
    return dale_chall_index;
};
DaleChallIndex.prototype.getWordList = function() {
    var words = this.text.replace(/[0-9]/g, '');
    words = words.replace(/'|-/g, '');
    words = words.toLowerCase();
    return words.split(/[\s\W\n]+/);
};
DaleChallIndex.prototype.getDifficultWords = function() {
    var difficult_words = [];
    var word_list = this.getWordList();
    for (var i = 0; i < word_list.length; i++) {
        if (!(word_list[i] in editor.simple_words)) {
            difficult_words.push(word_list[i]);
        } else {}
    }
    return difficult_words;
};;

function SetGoal() {
    this.goalLengthAvailableTypes = {
        min: "Minimum Goal",
        max: "Maximum Goal"
    };
    this.checkTypeAccessibility = function(arr) {
        this.error = false;
        if (arr) {
            this.goalTypeText = arr[1];
            switch (arr[1]) {
                case 'Words':
                    arr[1] = 'word_count';
                    break;
                case 'Characters':
                    arr[1] = 'character_count';
                    break;
                case 'Sentences':
                    arr[1] = 'sentence_count';
                    break;
                case 'Paragraphs':
                    arr[1] = 'paragraph_count';
                    break;
                case 'Pages':
                    arr[1] = 'avg_page_by_word';
                    break;
                case 'Reading Time':
                    arr[1] = 'reading_time';
                    break;
                case 'Speaking Time':
                    arr[1] = 'speaking_time';
                    break;
                case 'Publisher Words':
                    arr[1] = 'words_manuscript';
                    break;
            }
            this.qty = parseInt(arr[0]);
            this.goalType = arr[1];
            this.goalLengthType = arr[2];
        } else {
            this.goalType = $("#goalType").val();
            this.goalTypeText = $("#goalType option:selected").text();
            this.qty = $("#goalQty").val();
            this.goalLengthType = $("#goalLengthType").val();
        }
        if (Math.floor(this.qty) != this.qty || !$.isNumeric(this.qty)) {
            this.error = editor.selectedLanguage.please_set_valid_quantity_for_the_goal;
            this.showError();
        }
        if (!editor.optionsObject.details[this.goalType]) {
            this.error = editor.selectedLanguage.you_need_to_check + '" ' + this.goalTypeText + ' "' + editor.selectedLanguage.type_from_options_details_tab;
            this.showError();
        }
        if (!this.goalLengthAvailableTypes[this.goalLengthType]) {
            this.error = editor.selectedLanguage.you_need_to_choose_minimum_or_maximum_goal_type;
            this.showError();
        }
        return this.error ? false : true;
    };
    this.showError = function() {
        var errorTxt = '<div class="alert alert-warning fade in">' +
            '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">×</a>' +
            '<strong>' + editor.selectedLanguage.warning + '</strong> ' + this.error +
            '</div>';
        $('.errorMsgBox').append(errorTxt);
    }
}
SetGoal.prototype.allowedChars = function(e, $this) {
    if ($.inArray(e.keyCode, [46, 8]) !== -1 || (e.keyCode == 65 && e.ctrlKey === true) || (e.keyCode == 67 && e.ctrlKey === true) || (e.keyCode == 88 && e.ctrlKey === true) || (e.keyCode >= 35 && e.keyCode <= 39)) {
        return;
    }
    if (($this.val().length == 0 && e.keyCode === 96) || ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105))) {
        e.preventDefault();
    }
};
SetGoal.prototype.set = function(arr) {
    var savedObject = {
        'buttons': {}
    };
    if (!this.checkTypeAccessibility(arr))
        return false;
    this.goal = {
        "qty": this.qty,
        "type": this.goalType,
        "length": this.goalLengthType
    };
    if (arr) {
        switch (arr[1]) {
            case 'Words':
                arr[1] = 'word_count';
                break;
            case 'Characters':
                arr[1] = 'character_count';
                break;
            case 'Sentences':
                arr[1] = 'sentence_count';
                break;
            case 'Paragraphs':
                arr[1] = 'paragraph_count';
                break;
            case 'Pages':
                arr[1] = 'avg_page_by_word';
                break;
            case 'Reading Time':
                arr[1] = 'reading_time';
                break;
            case 'Speaking Time':
                arr[1] = 'speaking_time';
                break;
            case 'Publisher Words':
                arr[1] = 'words_manuscript';
                break;
        }
        this.goal = {
            'qty': parseInt(arr[0]),
            'type': arr[1],
            'length': arr[2]
        }
    }
    savedObject.buttons = {
        'goalViewBox': this.goal
    };
    editor.changeOption(savedObject);
    this.updateGoalBox();
    $('#set-goal-modal').modal('hide');
    return true;
};
SetGoal.prototype.updateGoalBox = function() {
    if (editor.optionsObject.buttons['goalViewBox']) {
        var cookieGoal = editor.optionsObject.buttons['goalViewBox'];
        this.goalBox = $("#goalViewBox");
        if (this.goalBox.hasClass('hidden'))
            this.goalBox.removeClass('hidden');
        var goalTypeText = $("#goalType option[value='" + cookieGoal.type + "']").data('value');
        var written_count;
        if (cookieGoal.type === 'reading_time' || cookieGoal.type === 'speaking_time') {
            if (editor.count[cookieGoal.type].indexOf(editor.selectedLanguage.sec) > -1) {
                written_count = Math.round((editor.count[cookieGoal.type].replace(editor.selectedLanguage.sec, '').trim() / 60) * 100) / 100;
            } else if (editor.count[cookieGoal.type].indexOf(editor.selectedLanguage.mins) > -1) {
                written_count = editor.count[cookieGoal.type].replace(editor.selectedLanguage.mins, '').trim();
            } else if (editor.count[cookieGoal.type].indexOf('hrs') > -1) {
                written_count = editor.count[cookieGoal.type].replace(editor.selectedLanguage.hrs, '').trim() * 60;
            }
        } else {
            written_count = editor.count[cookieGoal.type];
        }
        var goal_text = goalTypeText.toLowerCase().replace(' ', '_') + '_for_goal_progress_bar';
        $('.progress #percent_text, .progress #percent_text1, .progress-bar div').text(editor.commaSeparateNumber([written_count]) + ' / ' + editor.commaSeparateNumber([cookieGoal.qty]) + " " + editor.selectedLanguage[goal_text]);
        $('#goalViewBox input[name="goal_type"]').val(goalTypeText);
        $('#goalViewBox input[name="goal_count"]').val(cookieGoal.qty);
        $('#goalViewBox input[name="written_count"]').val(written_count);
        $('#goalViewBox input[name="goal_length_type"]').val(cookieGoal.length);
        var percent = (100 * (written_count)) / (cookieGoal.qty);
        if (percent <= 100) {
            $("#goal-progress-bar, #goal-progress-bar1").css("width", percent + "%");
        } else {
            $("#goal-progress-bar, #goal-progress-bar1").css("width", "100%");
        }
        if (written_count >= cookieGoal.qty) {
            $('#share-item-goal-link').show();
            this.goalBox.css('width', '233px');
            if (!this.goalBox.hasClass('riche')) {
                this.goalBox.addClass('riche');
                if (cookieGoal.length == 'max')
                    this.goalBox.addClass('maximum');
            } else {
                if (cookieGoal.length == 'min')
                    this.goalBox.removeClass('maximum');
                else if (!this.goalBox.hasClass('maximum'))
                    this.goalBox.addClass('maximum');
            }
        } else {
            $('#share-item-goal-link').hide();
            if (this.goalBox.hasClass('riche'))
                this.goalBox.removeClass('riche');
            this.goalBox.css('width', '212px');
            if (this.goalBox.hasClass('maximum'))
                this.goalBox.removeClass('maximum');
        }
    }
};
SetGoal.prototype.setDefaultValues = function() {
    if (editor.optionsObject.buttons['goalViewBox']) {
        $("#goalQty").val('');
        $("#goalType option[value='word_count']").attr('selected', 'selected');
        $("#goalLengthType option[value='min']").attr('selected', 'selected');
    }
};
SetGoal.prototype.disableGoal = function(arr) {
    if (arr) {
        var dataObject = {
            'goal_count': arr[0],
            'goal_type': arr[1],
            'goal_length_type': arr[2]
        };
        $.ajax({
            type: "POST",
            url: "site/disable-goal",
            data: dataObject
        });
    }
    var savedObject = {
        'buttons': {}
    };
    $("#goalViewBox").addClass("hidden");
    $('#goal-btn').removeClass('active');
    $("#goalType option[value='character_count']").attr('selected', 'selected');
    $("#goalQty").val(null);
    savedObject.buttons = {
        'goalViewBox': false
    };
    editor.changeOption(savedObject);
};
var goal = new SetGoal();;
'use strict';

function Translate() {}
Translate.prototype.setWcLanguage = function() {
    $.getJSON("./json/" + editor.optionsObject.wcLanguage + ".json", function(json) {
        editor.selectedLanguage = json.data;
        editor.wordCountInternational();
        editor.wordsPerMinuteForReading();
        editor.wordsPerMinuteForSpeaking();
        editor.showActivities();
        jQuery.ajax({
            type: "POST",
            url: "./site/get-revisions"
        }).done(function(msg2) {
            $('#revisions_ul').empty().append(msg2);
            $('[data-tr-detail="revision"]').each(function(s_key, s_value) {
                $(s_value).text(editor.translateDate($(s_value).text()));
            });
        });
        $.each(editor.selectedLanguage, function(key, value) {
            var trTag = $('[data-tr-detail="' + key + '"]');
            var text = '';
            if (key === 'words_characters') {
                if (editor.count['word_count'] !== 1) {
                    text = editor.count['word_count'] + ' ' + editor.selectedLanguage['words'];
                } else {
                    text = editor.count['word_count'] + ' ' + editor.selectedLanguage['word'];
                }
                if (editor.count['character_count'] !== 1) {
                    text += ' ' + editor.count['character_count'] + ' ' + editor.selectedLanguage['characters'];
                } else {
                    text += ' ' + editor.count['character_count'] + ' ' + editor.selectedLanguage['character'];
                }
                trTag.text(text);
            } else if (key === 'start_typing_or_copy_and_paste_your_document_here' || key === 'quantity' || key === 'leave_your_notes' || key === 'email' || key === 'password' || key === 're_enter_password' || key === 're_enter_email') {
                trTag.attr('placeholder', value);
            } else if ((key === 'hide_details_panel' && editor.optionsObject.detailsContainer) || (key === 'show_details_panel' && !editor.optionsObject.detailsContainer)) {
                $('.hide_button').attr('title', value);
            } else if (key === 'read_about_what_this_means') {
                trTag.attr('data-original-title', value);
            } else if (key === 'embed_this' || key === 'share_this' || key === 'disable_goal') {
                trTag.attr('title', value);
            } else if (key === 'text_for_details_sharing') {
                trTag.text(value + ' ' + abs_path + ' #wordcount @wordcounter_net')
            } else if (key === 'my_saved_draft') {
                trTag.val(value);
            } else if (key === "date_format1" || key === "date_format2" || key === "date_format3" || key === "date_format4" || key === "date_format5" || key === "date_format6" || key === "date_format7" || key === "date_format8" || key === "date_format9" || key === "date_format10" || key === "with_a_leading_zero" || key === "24_hour_with_a_leading_zero" || key === "24_hour") {
                trTag.text(editor.translateDate($('[data-tr-detail-hidden="' + key + '"]').text()));
            } else {
                trTag.text(value);
            }
        });
    });
};
var translate = new Translate();;
var apiParams = {
    aff_id: 1122,
    offer_id: 237,
    source: 'wc',
    aff_sub: 'wccheck',
    utm_content: 'wc'
};

function Editor() {
    'use strict';
    this.box = $("#box");
    this.node_for_box = document.getElementById("box");
    this.count_for_selection = [];
    this.count = [];
    this.count['word_count'] = 0;
    this.count['character_count'] = 0;
    this.count['sentence_count'] = 0;
    this.count['paragraph_count'] = 0;
    this.count['avg_page_by_word'] = 0;
    this.searchedString = '';
    this.replacementString = '';
    this.replacementPos = 0;
    this.firstText = '';
    this.secondText = '';
    this.wholeWords = '';
    this.selectedLanguage = {};
    this.uniqueWords = [];
    this.lastFocus = '';
    this.body = $("body");
    this.thesaurus_word = [];
    this.highlighted_word_array = [];
    this.cookieOptionsObject = {};
    this.fileContent = {
        content: '',
        error: ''
    };
    this.word_exceptions = {
        'geographic': 4,
        'geographics': 4
    };
    this.addingStopWords = {};
    this.voices = null;
    this.langs = [
        ['Afrikaans', ['af-ZA']],
        ['Bahasa Indonesia', ['id-ID']],
        ['Bahasa Melayu', ['ms-MY']],
        ['Català', ['ca-ES']],
        ['Čeština', ['cs-CZ']],
        ['Dansk', ['da-DK']],
        ['Deutsch', ['de-DE']],
        ['English', ['en-AU', 'Australia'],
            ['en-CA', 'Canada'],
            ['en-IN', 'India'],
            ['en-NZ', 'New Zealand'],
            ['en-ZA', 'South Africa'],
            ['en-GB', 'United Kingdom'],
            ['en-US', 'United States']
        ],
        ['Español', ['es-AR', 'Argentina'],
            ['es-BO', 'Bolivia'],
            ['es-CL', 'Chile'],
            ['es-CO', 'Colombia'],
            ['es-CR', 'Costa Rica'],
            ['es-EC', 'Ecuador'],
            ['es-SV', 'El Salvador'],
            ['es-ES', 'España'],
            ['es-US', 'Estados Unidos'],
            ['es-GT', 'Guatemala'],
            ['es-HN', 'Honduras'],
            ['es-MX', 'México'],
            ['es-NI', 'Nicaragua'],
            ['es-PA', 'Panamá'],
            ['es-PY', 'Paraguay'],
            ['es-PE', 'Perú'],
            ['es-PR', 'Puerto Rico'],
            ['es-DO', 'República Dominicana'],
            ['es-UY', 'Uruguay'],
            ['es-VE', 'Venezuela']
        ],
        ['Euskara', ['eu-ES']],
        ['Filipino', ['fil-PH']],
        ['Français', ['fr-FR']],
        ['Galego', ['gl-ES']],
        ['Hrvatski', ['hr_HR']],
        ['IsiZulu', ['zu-ZA']],
        ['Íslenska', ['is-IS']],
        ['Italiano', ['it-IT', 'Italia'],
            ['it-CH', 'Svizzera']
        ],
        ['Lietuvių', ['lt-LT']],
        ['Magyar', ['hu-HU']],
        ['Nederlands', ['nl-NL']],
        ['Norsk bokmål', ['nb-NO']],
        ['Polski', ['pl-PL']],
        ['Português', ['pt-BR', 'Brasil'],
            ['pt-PT', 'Portugal']
        ],
        ['Română', ['ro-RO']],
        ['Slovenščina', ['sl-SI']],
        ['Slovenčina', ['sk-SK']],
        ['Suomi', ['fi-FI']],
        ['Svenska', ['sv-SE']],
        ['Tiếng Việt', ['vi-VN']],
        ['Türkçe', ['tr-TR']],
        ['Ελληνικά', ['el-GR']],
        ['български', ['bg-BG']],
        ['Pусский', ['ru-RU']],
        ['Српски', ['sr-RS']],
        ['Українська', ['uk-UA']],
        ['한국어', ['ko-KR']],
        ['中文', ['cmn-Hans-CN', '普通话 (中国大陆)'],
            ['cmn-Hans-HK', '普通话 (香港)'],
            ['cmn-Hant-TW', '中文 (台灣)'],
            ['yue-Hant-HK', '粵語 (香港)']
        ],
        ['日本語', ['ja-JP']],
        ['हिन्दी', ['hi-IN']],
        ['ภาษาไทย', ['th-TH']]
    ];
    this.recording = false;
    this.optionsObject = {
        "font": "Arial",
        "detailsContainer": true,
        "keywordDensityPanel": true,
        "keywordDensityAccordion": true,
        "activityPanel": true,
        "activityAccordion": true,
        "activityAmount": 5,
        "activityType": 'daily',
        "detailsPanel": true,
        "detailsPanelAccordion": true,
        "keywordDensityAmount": '10',
        "keywordDensityWordsCommon": false,
        "keywordDensityConsecutive": '1',
        "readRate": '1',
        "readPitch": '1',
        "readVoices": '0',
        "selectLanguage": '7',
        'selectDialect': 'en-US',
        'wordsPerMinuteForReading': '275',
        'wordsPerMinuteForSpeaking': '180',
        'lettersPerMinuteForHandWriting': '68',
        "version": "advanced",
        "theme": "default",
        'dateFormat': 'd/m/Y',
        'timeFormat': 'h:i A',
        "wcLanguage": "english",
        "boxHeight": {
            "box_height": false,
            "boxAutoSize": true
        },
        "details": {
            "word_count": true,
            "unique_word_count": false,
            "character_count": true,
            "character_count_no_spaces": false,
            "sentence_count": true,
            "longest_sentence_words": false,
            "shortest_sentence_words": false,
            "avg_sentence_words": false,
            "avg_sentence_chars": false,
            "avg_word_length": false,
            "avg_page_by_word": false,
            "count_words_syllables": false,
            "paragraph_count": true,
            "lines_count": false,
            "words_manuscript": false,
            "reading_level": true,
            "reading_time": true,
            "speaking_time": true,
            "hand_writing_time": false
        },
        "buttons": {
            "spell-btn": true,
            "case-btn": true,
            "text-to-speech-btn": false,
            "speech-btn": false,
            "goal-btn": true,
            "goalViewBox": false,
            "clear-btn": true,
            "undo-btn": true,
            "redo-btn": true,
            "save-btn": true,
            "save-to-drive-btn": false,
            "speed-btn": false,
            "copy": false,
            "print-btn": false,
            "upload-btn": false,
            "download-btn": false,
            "revisions-btn": true,
            "options-btn": true,
            "more-btn": true,
            "thesaurus-btn": true,
            "clean-text-btn": false,
            "activity-btn": true,
            "find-and-replace-btn": false
        }
    };
    this.basicVersionOptions = {
        "detailsContainer": false,
        "keywordDensityPanel": false,
        "keywordDensityAccordion": false,
        "activityPanel": false,
        "activityAccordion": false,
        "activityAmount": 5,
        "activityType": 'daily',
        "detailsPanel": false,
        "detailsPanelAccordion": false,
        "keywordDensityAmount": '10',
        "keywordDensityWordsCommon": false,
        "keywordDensityConsecutive": '1',
        "version": "basic",
        "details": {
            "word_count": true,
            "unique_word_count": false,
            "character_count": true,
            "character_count_no_spaces": false,
            "sentence_count": false,
            "longest_sentence_words": false,
            "shortest_sentence_words": false,
            "avg_sentence_words": false,
            "avg_sentence_chars": false,
            "avg_word_length": false,
            "avg_page_by_word": false,
            "count_words_syllables": false,
            "lines_count": false,
            "words_manuscript": false,
            "paragraph_count": false,
            "reading_level": false,
            "reading_time": false,
            "speaking_time": false,
            "hand_writing_time": false
        },
        "buttons": {
            "spell-btn": false,
            "case-btn": false,
            "text-to-speech-btn": false,
            "speech-btn": false,
            "goal-btn": false,
            "goalViewBox": false,
            "clear-btn": false,
            "undo-btn": false,
            "redo-btn": false,
            "save-btn": false,
            "save-to-drive-btn": false,
            "speed-btn": false,
            "copy": false,
            "print-btn": false,
            "upload-btn": false,
            "download-btn": false,
            "revisions-btn": false,
            "options-btn": false,
            "more-btn": false,
            "thesaurus-btn": false,
            "clean-text-btn": false,
            "activity-btn": false,
            "find-and-replace-btn": false
        }
    };
    this.advancedVersionOptions = {
        "detailsContainer": true,
        "keywordDensityPanel": true,
        "keywordDensityAccordion": true,
        "activityPanel": true,
        "activityAccordion": true,
        "activityAmount": 5,
        "activityType": 'daily',
        "detailsPanel": true,
        "detailsPanelAccordion": true,
        "keywordDensityAmount": '10',
        "keywordDensityWordsCommon": false,
        "keywordDensityConsecutive": '1',
        "version": "advanced",
        "details": {
            "word_count": true,
            "unique_word_count": false,
            "character_count": true,
            "character_count_no_spaces": false,
            "sentence_count": true,
            "longest_sentence_words": false,
            "shortest_sentence_words": false,
            "avg_sentence_words": false,
            "avg_sentence_chars": false,
            "avg_word_length": false,
            "avg_page_by_word": false,
            "count_words_syllables": false,
            "lines_count": false,
            "words_manuscript": false,
            "paragraph_count": true,
            "reading_level": true,
            "reading_time": true,
            "speaking_time": true,
            "hand_writing_time": false
        },
        "buttons": {
            "spell-btn": true,
            "case-btn": true,
            "text-to-speech-btn": false,
            "speech-btn": false,
            "goal-btn": true,
            "goalViewBox": false,
            "clear-btn": true,
            "undo-btn": true,
            "redo-btn": true,
            "save-btn": true,
            "save-to-drive-btn": false,
            "speed-btn": false,
            "copy": false,
            "print-btn": false,
            "upload-btn": false,
            "download-btn": false,
            "revisions-btn": true,
            "options-btn": true,
            "more-btn": true,
            "thesaurus-btn": true,
            "clean-text-btn": false,
            "activity-btn": true,
            "find-and-replace-btn": false
        }
    };
    this.simple_words = {};
}
Editor.prototype.getCaretCharacterOffsetWithin = function(element) {
    var caretOffset = 0;
    var doc = element.ownerDocument || element.document;
    var win = doc.defaultView || doc.parentWindow;
    var sel;
    if (typeof win.getSelection != "undefined") {
        sel = win.getSelection();
        if (sel.rangeCount > 0) {
            var range = win.getSelection().getRangeAt(0);
            var preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
    } else if ((sel = doc.selection) && sel.type != "Control") {
        var textRange = sel.createRange();
        var preCaretTextRange = doc.body.createTextRange();
        preCaretTextRange.moveToElementText(element);
        preCaretTextRange.setEndPoint("EndToEnd", textRange);
        caretOffset = preCaretTextRange.text.length;
    }
    return caretOffset;
};
Editor.prototype.getCursorPositionInTextarea = function(el) {
    var pos = 0;
    if ('selectionStart' in el) {
        pos = el.selectionStart;
    } else if ('selection' in document) {
        el.focus();
        var Sel = document.selection.createRange();
        var SelLength = document.selection.createRange().text.length;
        Sel.moveStart('character', -el.value.length);
        pos = Sel.text.length - SelLength;
    }
    return pos;
};
Editor.prototype.throttle = function(f, delay) {
    var timer = null;
    return function() {
        var context = this,
            args = arguments;
        clearTimeout(timer);
        timer = window.setTimeout(function() {
            f.apply(context, args);
        }, delay || 300);
    };
};
Editor.prototype.init = function() {
    this.addSimpleWords();
    if (typeof variable_for_index_page != 'undefined') {
        if ('webkitSpeechRecognition' in window) {
            this.speechRecog = new webkitSpeechRecognition();
            this.speechRecog.continuous = true;
            this.speechRecog.interimResults = true;
        } else {
            $("#btn-speech-btn").parent().css({
                'opacity': '0.5',
                'pointer-events': 'none'
            });
            $("#btn-speech-btn").parent().parent().attr('title', 'Requires chrome browser');
            $('label[for="btn-speech-btn"], a[href="#collapseForSpeech"]').css('pointer-events', 'none');
            $('#talk_to_type_requires').append('<br /><small style="color:red">Requires Chrome</small>');
        }
        var savedObject = {
            'boxHeight': {}
        };
        var $this = this;
        if ($.cookie('optionsObject')) {
            this.cookieOptionsObject = JSON.parse($.cookie('optionsObject'));
            $.getJSON("./json/" + this.cookieOptionsObject.wcLanguage + ".json", function(json) {
                editor.selectedLanguage = json.data;
                editor.changeOption(editor.cookieOptionsObject);
            });
        } else {
            $.cookie('optionsObject', JSON.stringify(this.optionsObject), {
                expires: 365
            });
            $.getJSON("./json/" + this.optionsObject.wcLanguage + ".json", function(json) {
                editor.selectedLanguage = json.data;
                editor.setEditorOptions();
            });
        }
        if (!('WebkitAppearance' in document.documentElement.style)) {
            var savedObjectURC = {
                buttons: {
                    'undo-btn': false,
                    'redo-btn': false,
                    'clear-btn': false
                }
            };
            this.changeOption(savedObjectURC);
            $("#btn-undo-btn, #btn-redo-btn, #btn-clear-btn").parent().parent().parent().parent().attr('title', 'Requires webkit browser');
            $("#btn-undo-btn, #btn-redo-btn, #btn-clear-btn").parent().parent().parent().css({
                'opacity': '0.5',
                'pointer-events': 'none'
            });
            $('label[for="btn-undo-btn"], label[for="btn-redo-btn"], label[for="btn-clear-btn"]').css('pointer-events', 'none');
            $('#clear_requires, #undo_requires, #redo_requires').append('<br /><small style="color:red">Requires Chrome or Safari</small>');
        }
        $(window).on("load", function() {
            $this.wordCountInternational();
            $this.keywordDensity();
            if (localStorage.getItem('goal_submit')) {
                if (user_id_for_goal !== undefined) {
                    $('#set-goal-modal').modal('toggle');
                    editor.getUserGoals(user_id_for_goal);
                    if (!editor.optionsObject.buttons.goalViewBox) {
                        $.ajax({
                            type: "GET",
                            url: "site/unset-goal",
                            success: function(data) {
                                if (data.response == 1) {}
                            }
                        });
                    }
                }
                localStorage.removeItem('goal_submit');
            }
            if (user_id_for_goal === undefined) {
                $('#goal-btn').removeClass('active');
            }
        });
        if ($.cookie('text')) {
            $.cookie('text', null, {
                path: '/'
            });
        }
        if (localStorage.getItem('text') && window.location.href == abs_path) {
            this.box.val(localStorage.getItem('text'));
        }
        $("#details .task-list-item input[type='checkbox']").bootstrapSwitch();
        $("#buttons .task-list-item input[type='checkbox']").bootstrapSwitch();
        this.box.keydown($this.throttle(function() {
            $this.wordCountInternational();
            $this.keywordDensity();
        })).keypress($this.throttle(function(e) {
            $this.wordCountInternational();
            $this.keywordDensity();
        })).focus($this.throttle(function(e) {
            $this.wordCountInternational();
            $this.keywordDensity();
            if (window.location.href == abs_path) {
                setTimeout(function() {
                    localStorage.setItem('text', $this.box.val());
                }, 100);
            }
            setTimeout(function() {
                if ($this.optionsObject.boxHeight['boxAutoSize']) {
                    autosize($this.box);
                } else {
                    autosize.destroy($this.box);
                    $this.box.height($this.optionsObject.boxHeight['box_height']);
                    $this.box.css('overflow-y', 'auto');
                }
            }, 10);
        })).keyup($this.throttle(function(e) {
            $this.wordCountInternational();
            $this.keywordDensity();
            if ($this.optionsObject.boxHeight['boxAutoSize']) {
                autosize($this.box);
            } else {
                autosize.destroy($this.box);
                $this.box.height($this.optionsObject.boxHeight['box_height']);
                $this.box.css('overflow-y', 'auto');
            }
            if (window.location.href == abs_path) {
                localStorage.setItem('text', $this.box.val());
            }
        })).mouseup(function(e) {
            $this.wordCountInternational();
            $this.keywordDensity();
        }).load(function() {
            $this.wordCountInternational();
            $this.keywordDensity();
        });
        $('body').mousedown(function(e) {
            var cursorPosition = editor.getCursorPositionInTextarea(editor.node_for_box);
            if (!$(e.target).is('#box') && !$(e.target).is('#case-btn') && !$(e.target).parent().is('#case-btn') && !$(e.target).is('#thesaurus-btn') && !$(e.target).parent().is('#thesaurus-btn') && !$(e.target).is('#lower-case-link') && !$(e.target).is('#upper-case-link') && !$(e.target).is('#title-case-link') && !$(e.target).is('#sentence-case-link') && !$(e.target).is('#text-to-speech-btn') && !$(e.target).parent().is('#text-to-speech-btn') && !$(e.target).is('#r-play-link') && !$(e.target).parent().is('#r-play-link') && !$(e.target).is('#r-pause-link') && !$(e.target).parent().is('#r-pause-link') && !$(e.target).is('#r-stop-link') && !$(e.target).parent().is('#r-stop-link') && !$(e.target).is('#speech-btn') && !$(e.target).parent().is('#speech-btn') && !$(e.target).parent().parent().is('#thesaurus_synonyms') && !$(e.target).parent().is('#thesaurus_synonyms') && !$(e.target).is('#kwd-accordion a') && !$(e.target).is('#kwd-accordion a span')) {
                if ($('#box-readonly').css('display') == 'none') {
                    $this.keywordDensity();
                }
                if ($('#form').css('display') != 'none') {
                    editor.node_for_box.setSelectionRange(cursorPosition, cursorPosition);
                }
            }
        });
        $('#box:not(.processed)').TextAreaResizer({
            onResize: function(e, height) {
                autosize.destroy($this.box);
                $this.box.css('min-height', '0');
                savedObject.boxHeight = {
                    'box_height': height,
                    'boxAutoSize': false
                };
                $this.changeOption(savedObject);
            }
        });
        if (this.optionsObject.boxHeight['boxAutoSize']) {
            this.box.css('overflow', 'hidden');
            this.box.css('height', 'auto');
            this.box.height(this.box[0].scrollHeight);
            this.box.css('min-height', '250px');
        } else {
            this.box.css('overflow-y', 'auto');
            this.box.css('min-height', '0');
            if (this.optionsObject.boxHeight['box_height']) {
                this.box.height(this.optionsObject.boxHeight['box_height']);
            } else {
                this.box.height(250);
                this.optionsObject.boxHeight['box_height'] = this.box.height();
            }
        }
        $('#collapseForRead.collapse, #collapseForSpeech.collapse, #collapseForReadingTime.collapse, #collapseForSpeakingTime.collapse').collapse('hide');
        $('[data-toggle="tooltip"]').tooltip();
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = function() {
                $this.voices = speechSynthesis.getVoices();
                if (!$this.voices.length) return;
                for (var i = 0; i < $this.voices.length; i++) {
                    if (i == $this.optionsObject.readVoices) {
                        $("#read_voices").append("<option selected='selected' value=\"" + i + "\">" + $this.voices[i].name + "</option>");
                    } else {
                        $("#read_voices").append("<option value=\"" + i + "\">" + $this.voices[i].name + "</option>");
                    }
                }
            };
        } else {
            $("#btn-text-to-speech-btn").parent().css({
                'opacity': '0.5',
                'pointer-events': 'none'
            });
            $("#btn-text-to-speech-btn").parent().parent().attr('title', 'Requires chrome browser');
            $("a[href='#collapseForRead'], label[for='btn-text-to-speech-btn']").css('pointer-events', 'none');
            $('#proof_read_requires').append('<br /><small style="color:red">Requires Chrome</small>');
        }
        this.readTimer();
        this.changeDetails();
        this.changeButtonDetails();
        this.setLanguageForSpeech();
        if (user_id_for_goal) {
            this.showActivities();
        }
        $(document).ready(function() {
            editor.uploadFile();
            $('[data-toggle="popover"]').popover();
            clicks = [];
            $('body').on('click', function(e) {
                i = 0;
                target = $(e.target);
                while (target.attr('id') === undefined && i < 10) {
                    i++;
                    target = target.parent();
                }
                clicks.push(target.attr('id'));
            });
            keypresses = 0;
            $('body').on('keypress', function(e) {
                keypresses++;
            });
            jQuery.browser = {};
            (function() {
                jQuery.browser.msie = false;
                jQuery.browser.version = 0;
                if (navigator.userAgent.match(/MSIE ([0-9]+)\./)) {
                    jQuery.browser.msie = true;
                    jQuery.browser.version = RegExp.$1;
                }
            })();
            $this.box.bind('paste', function(e) {
                setTimeout(function() {
                    $this.keywordDensity();
                    $this.wordCountInternational();
                    if (window.location.href == abs_path) {
                        localStorage.setItem('text', $this.box.val());
                    }
                }, 4);
            });
            $("button").not('#revisions-btn, #options-btn, button[data-dismiss=modal]').click(function(e) {
                if ($this.lastFocus) {
                    setTimeout(function() {
                        $this.lastFocus.focus();
                        $this.wordCountInternational();
                        $this.keywordDensity();
                    }, 10);
                }
                return (true);
            });
            $this.body.mouseup(function(e) {
                $this.thesaurusEnableOrDisable();
                $this.wordCountInternational();
                if (!$(e.target).is('#kwd-accordion a') && !$(e.target).is('#kwd-accordion a span')) {
                    if ($('#box-readonly').css('display') == 'none') {
                        $this.keywordDensity();
                    }
                }
            }).keyup(function() {
                $this.thesaurusEnableOrDisable();
            });
            $this.box.blur(function() {
                $this.lastFocus = this;
            });
            var blog_entry_alert = $('#blog_entry_alert');
            blog_entry_alert.bind('closed.bs.alert', function() {
                $.cookie('blog_entry', 'hide', {
                    expires: 7
                });
            });
            if ($.cookie('blog_entry') != 'hide') {
                blog_entry_alert.show();
            }
            $('html').on('mouseup', 'grammarly-card', function() {
                setTimeout(function() {
                    $this.wordCountInternational();
                    $this.keywordDensity();
                }, 100);
            });
        });
        $(window).resize(function() {
            var selected_text = $this.box.selection();
            var text = $this.box.val();
            if (selected_text !== '') {
                $('#for_counting_lines').val(selected_text);
                if ($this.optionsObject.details['lines_count'])
                    $this.countLines(selected_text, true);
                if ($this.optionsObject.details['words_manuscript'])
                    $this.countWordsManuscript(selected_text, true);
                $this.displayTextBoxes(true);
            } else {
                $('#for_counting_lines').val(text);
                if ($this.optionsObject.details['lines_count'])
                    $this.countLines(text, false);
                if ($this.optionsObject.details['words_manuscript'])
                    $this.countWordsManuscript(text, false);
                $this.displayTextBoxes(false);
            }
        });
    }
    if (localStorage.getItem('addingStopWords')) {
        this.addingStopWords = JSON.parse(localStorage.getItem('addingStopWords'));
        var count = 0;
        for (var key in this.addingStopWords) {
            $.wordStats.stopWords[key] = true;
            count++;
        }
        $('#count_of_adding_words').text(count);
        if (count === 0) {
            $('#reset_ignored_words').attr('disabled', 'disabled');
        }
    } else {
        $('#count_of_adding_words').text('0');
        $('#reset_ignored_words').attr('disabled', 'disabled');
    }
    if (typeof BindSubmit == 'function') BindSubmit();
};
String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};
Editor.prototype.uploadFile = function() {
    $('#file-uploader').uploadFile({
        url: 'site/upload-file',
        dragDrop: false,
        fileName: "uploading_file",
        multiple: false,
        allowedTypes: "txt,pdf,odt,doc,docx",
        onSelect: function(files) {
            $('.ajax-file-upload-container').empty();
        },
        onSuccess: function(files, data, xhr) {
            if (typeof data == 'string') {
                data = JSON.parse(data);
            }
            if (data.success) {
                editor.fileContent.content = data.fileContent;
                editor.fileContent.error = false;
            } else {
                editor.fileContent.content = false;
                editor.fileContent.error = data.error;
            }
            editor.setFileContent();
        }
    });
};
Editor.prototype.setFileContent = function() {
    $('#fill_content').attr('disabled', 'disabled');
    if (this.fileContent.error) {
        $(".error_for_uploading_file").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Warning!</strong> ' + this.fileContent.error + '</div>');
        $(".error_for_uploading_file").slideDown();
        setTimeout(function() {
            $(".error_for_uploading_file").slideUp();
        }, 6000);
    } else {
        $('#upload-file-modal').modal('hide');
        if ('WebkitAppearance' in document.documentElement.style) {
            this.box.focus();
            document.execCommand('selectAll', false, null);
            document.execCommand("insertHTML", false, this.fileContent.content);
        } else {
            this.box.val(this.fileContent.content);
        }
    }
};
Editor.prototype.downloadText = function(ev, option) {
    ev = ev || window.event;
    ev.preventDefault();
    var textToWrite = '';
    if (option === 'txt' || option === 'doc') {
        textToWrite = this.node_for_box.value;
        textToWrite = textToWrite.replace(/~~~/gi, '').replace(/\n/g, "\r\n");
        var textFileAsBlob = new Blob([textToWrite], {
            type: 'text/plain'
        });
        var fileNameToSaveAs = "myWrittenText." + option;
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "My Hidden Link";
        window.URL = window.URL || window.webkitURL;
        downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
        downloadLink.onclick = this.destroyClickedElement;
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
    } else if (option === 'pdf') {
        textToWrite = editor.box.val().replace(/~~~/gi, '');
        var doc = new jsPDF('p', 'in', 'letter'),
            size = 14,
            font = ['Helvetica', ''],
            lines, margin = 0.5,
            verticalOffset = margin;
        doc.setDrawColor(255, 255, 255).setLineWidth(1 / 72).line(margin, margin, margin, 11 - margin).line(8.5 - margin, margin, 8.5 - margin, 11 - margin);
        lines = doc.setFont(font[0], font[1]).setFontSize(size).splitTextToSize(textToWrite, 7.5);
        doc.text(0.5, verticalOffset + size / 72, lines);
        doc.save('myWrittenText.pdf');
    }
};
Editor.prototype.destroyClickedElement = function(event) {
    document.body.removeChild(event.target);
};
Editor.prototype.setRecordInputs = function() {
    $('#characters_record_input').val(this.count['character_count']);
    $('#words_record_input').val(this.count['word_count']);
    $('#notes').val('');
};
Editor.prototype.showExistingRecords = function() {
    $.ajax({
        type: "POST",
        url: "site/get-records",
        data: {
            date_format: editor.optionsObject.dateFormat,
            time_format: editor.optionsObject.timeFormat
        },
        success: function(data) {
            $('#existing_records').empty();
            var word_count_with_commas, character_count_with_commas, date;
            if (data.success == true) {
                if (data.user_records) {
                    data.user_records.forEach(function(record, index) {
                        word_count_with_commas = editor.commaSeparateNumber([record.words]);
                        character_count_with_commas = editor.commaSeparateNumber([record.characters]);
                        date = record.updated_at;
                        $('#existing_records').append('<div class="col-xs-12 user_record records_for_logged_in_user" id="record_' + record.id + '">' + '<div class="col-xs-7 col-sm-8" style="padding: 0">' + '<div class="col-xs-2 col-sm-1" style="padding: 5px 5px 0 5px; font-weight: bold">' + (index + 1) + '.' + '</div>' + '<div class="col-xs-9 col-sm-10" style="padding: 5px 0 0 0; font-style: italic; font-weight: bold">' + editor.translateDate(date) + '</div>' + '<div class="col-xs-12" style="padding: 0;">' + '<div class="col-xs-2 col-sm-1" style="padding: 5px 5px 0 5px;">' + '</div>' + '<div class="col-xs-9 col-sm-10" style="padding: 0">' + word_count_with_commas + ' ' + editor.selectedLanguage.words + ', ' + character_count_with_commas + ' ' + editor.selectedLanguage.characters + ' ' + '</div>' + '</div>' + '</div>' + '<div class="col-xs-5 col-sm-4" style="margin-top: 9px; padding: 0">' + '<button type="button" class="btn btn-danger btn-xs" style="float:right;margin-right:10px;" onclick="editor.deleteRecord(' + record.id + ')">' + editor.selectedLanguage.delete + '</button>' + '<button type="button" class="btn btn-info btn-xs" style="float:right; margin-right:7%;" onclick="$(\'#record_slide_toggle_' + record.id + '\').slideToggle();">' + editor.selectedLanguage.edit + '</button>' + '</div>' + '</div>' + '<div class="col-xs-12" style="margin: 10px 0; display: none;" id="record_slide_toggle_' + record.id + '">' + '<div class="col-xs-12 well">' + '<div class="col-xs-5">' + '<label for="words_' + record.id + '">' + editor.selectedLanguage.words_label + '</label>' + '<input id="words_' + record.id + '" type="number" min="0" value="' + record.words + '" class="form-control input-sm">' + '</div>' + '<div class="col-xs-5">' + '<label for="characters_' + record.id + '">' + editor.selectedLanguage.characters_label + '</label>' + '<input id="characters_' + record.id + '" type="number" min="0" value="' + record.characters + '" class="form-control input-sm">' + '</div>' + '<div class="col-xs-12" style="margin-bottom: 5px"></div>' + '<div class="col-xs-10">' + '<label for="notes_' + record.id + '">' + editor.selectedLanguage.notes + '</label>' + '<input id="notes_' + record.id + '" type="text" maxlength="255" value="' + record.notes + '" class="form-control input-sm">' + '</div>' + '<div class="col-xs-2">' + '<button style="position: absolute; top: -6px;" class="btn btn-success" onclick="editor.editRecord(' + record.id + ');">' + editor.selectedLanguage.save_modal_btn + '</button>' + '</div>' + '</div>' + '</div>');
                    });
                }
            } else if (data.success == 'empty') {
                $('#existing_records').append('<div class="col-md-12 user_goal" id="" style="text-align: center;">' +
                    editor.selectedLanguage.above_you_can_save_your_first_record + '</div>');
            }
        }
    });
};
Editor.prototype.saveRecord = function() {
    $.ajax({
        type: "POST",
        url: "site/save-record",
        data: {
            word_count: $('#words_record_input').val(),
            characters_count: $('#characters_record_input').val(),
            notes: $('#notes').val()
        },
        success: function(data) {
            var error_box = $(".error_for_save_word_count");
            if (data) {
                editor.showExistingRecords();
                error_box.html('<div class="alert alert-success" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_record_was_saved_successfully + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
                editor.showActivities();
                editor.setRecordInputs();
            } else {
                error_box.html('<div class="alert alert-warning" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.an_error_occurred_during_saving_your_record + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.editRecord = function(id) {
    $.ajax({
        type: "POST",
        url: "site/edit-record",
        data: {
            id: id,
            words_count: $('#words_' + id).val(),
            characters_count: $('#characters_' + id).val(),
            notes: $('#notes_' + id).val()
        },
        success: function(data) {
            var error_box = $(".error_for_save_word_count");
            if (data) {
                editor.showExistingRecords();
                error_box.html('<div class="alert alert-success" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_record_was_edited_successfully + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
                $('#record_slide_toggle_' + id).slideUp();
                editor.showActivities();
            } else {
                error_box.html('<div class="alert alert-warning" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.an_error_occurred_during_editing_your_record + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.deleteRecord = function(id) {
    var dataObject = {
        'id': id
    };
    $.ajax({
        type: "POST",
        url: "site/delete-record",
        data: dataObject,
        success: function(data) {
            var error_box = $(".error_for_save_word_count");
            if (data.success) {
                $('#record_' + id).fadeOut(500);
                setTimeout(function() {
                    editor.showExistingRecords();
                    if ($('#existing_records').children().length == 0) {
                        $('#existing_records').append('<div class="col-md-12 user_record" id="" style="text-align: center;">' +
                            editor.selectedLanguage.above_you_can_save_your_first_record + '</div>');
                    }
                }, 450);
                error_box.html('<div class="alert alert-success">' +
                    '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">&times;</a>' +
                    '<strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_record_was_deleted_successfully +
                    '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
                editor.showActivities();
            } else {
                error_box.html('<div  class="alert alert-warning">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.message] + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    $(".error_for_save_word_count").slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.translateDate = function(date) {
    var translatingDate = date;
    if (translatingDate.indexOf("24-hour with a leading zero") > -1) {
        translatingDate = translatingDate.replace('24-hour with a leading zero', editor.selectedLanguage['24_hour_with_a_leading_zero']);
    } else if (translatingDate.indexOf("with a leading zero") > -1) {
        translatingDate = translatingDate.replace('with a leading zero', editor.selectedLanguage.with_a_leading_zero);
    } else if (translatingDate.indexOf("24 hour") > -1) {
        translatingDate = translatingDate.replace('24 hour', editor.selectedLanguage['24_hour']);
    }
    if (translatingDate.indexOf("Monday") > -1) {
        translatingDate = translatingDate.replace('Monday', editor.selectedLanguage.Monday);
    } else if (translatingDate.indexOf("Mon") > -1) {
        translatingDate = translatingDate.replace('Mon', editor.selectedLanguage.Mon);
    } else if (translatingDate.indexOf("Tuesday") > -1) {
        translatingDate = translatingDate.replace('Tuesday', editor.selectedLanguage.Tuesday);
    } else if (translatingDate.indexOf("Tue") > -1) {
        translatingDate = translatingDate.replace('Tue', editor.selectedLanguage.Tue);
    } else if (translatingDate.indexOf("Wednesday") > -1) {
        translatingDate = translatingDate.replace('Wednesday', editor.selectedLanguage.Wednesday);
    } else if (translatingDate.indexOf("Wed") > -1) {
        translatingDate = translatingDate.replace('Wed', editor.selectedLanguage.Wed);
    } else if (translatingDate.indexOf("Thursday") > -1) {
        translatingDate = translatingDate.replace('Thursday', editor.selectedLanguage.Thursday);
    } else if (translatingDate.indexOf("Thu") > -1) {
        translatingDate = translatingDate.replace('Thu', editor.selectedLanguage.Thu);
    } else if (translatingDate.indexOf("Friday") > -1) {
        translatingDate = translatingDate.replace('Friday', editor.selectedLanguage.Friday);
    } else if (translatingDate.indexOf("Fri") > -1) {
        translatingDate = translatingDate.replace('Fri', editor.selectedLanguage.Fri);
    } else if (translatingDate.indexOf("Saturday") > -1) {
        translatingDate = translatingDate.replace('Saturday', editor.selectedLanguage.Saturday);
    } else if (translatingDate.indexOf("Sat") > -1) {
        translatingDate = translatingDate.replace('Sat', editor.selectedLanguage.Sat);
    } else if (translatingDate.indexOf("Sunday") > -1) {
        translatingDate = translatingDate.replace('Sunday', editor.selectedLanguage.Sunday);
    } else if (translatingDate.indexOf("Sun") > -1) {
        translatingDate = translatingDate.replace('Sun', editor.selectedLanguage.Sun);
    }
    if (translatingDate.indexOf("th") > -1) {
        translatingDate = translatingDate.replace('th', editor.selectedLanguage.th);
    }
    if (translatingDate.indexOf("of ") > -1) {
        translatingDate = translatingDate.replace('of ', editor.selectedLanguage.of);
    }
    if (translatingDate.indexOf("January") > -1) {
        translatingDate = translatingDate.replace('January', editor.selectedLanguage.January);
    } else if (translatingDate.indexOf("Jan") > -1) {
        translatingDate = translatingDate.replace('Jan', editor.selectedLanguage.Jan);
    } else if (translatingDate.indexOf("February") > -1) {
        translatingDate = translatingDate.replace('February', editor.selectedLanguage.February);
    } else if (translatingDate.indexOf("Feb") > -1) {
        translatingDate = translatingDate.replace('Feb', editor.selectedLanguage.Feb);
    } else if (translatingDate.indexOf("March") > -1) {
        translatingDate = translatingDate.replace('March', editor.selectedLanguage.March);
    } else if (translatingDate.indexOf("Mar") > -1) {
        translatingDate = translatingDate.replace('Mar', editor.selectedLanguage.Mar);
    } else if (translatingDate.indexOf("April") > -1) {
        translatingDate = translatingDate.replace('April', editor.selectedLanguage.April);
    } else if (translatingDate.indexOf("Apr") > -1) {
        translatingDate = translatingDate.replace('Apr', editor.selectedLanguage.Apr);
    } else if (translatingDate.indexOf("May") > -1) {
        translatingDate = translatingDate.replace('May', editor.selectedLanguage.May);
    } else if (translatingDate.indexOf("June") > -1) {
        translatingDate = translatingDate.replace('June', editor.selectedLanguage.June);
    } else if (translatingDate.indexOf("Jun") > -1) {
        translatingDate = translatingDate.replace('Jun', editor.selectedLanguage.Jun);
    } else if (translatingDate.indexOf("July") > -1) {
        translatingDate = translatingDate.replace('July', editor.selectedLanguage.July);
    } else if (translatingDate.indexOf("Jul") > -1) {
        translatingDate = translatingDate.replace('Jul', editor.selectedLanguage.Jul);
    } else if (translatingDate.indexOf("August") > -1) {
        translatingDate = translatingDate.replace('August', editor.selectedLanguage.August);
    } else if (translatingDate.indexOf("Aug") > -1) {
        translatingDate = translatingDate.replace('Aug', editor.selectedLanguage.Aug);
    } else if (translatingDate.indexOf("September") > -1) {
        translatingDate = translatingDate.replace('September', editor.selectedLanguage.September);
    } else if (translatingDate.indexOf("Sep") > -1) {
        translatingDate = translatingDate.replace('Sep', editor.selectedLanguage.Sep);
    } else if (translatingDate.indexOf("October") > -1) {
        translatingDate = translatingDate.replace('October', editor.selectedLanguage.October);
    } else if (translatingDate.indexOf("Oct") > -1) {
        translatingDate = translatingDate.replace('Oct', editor.selectedLanguage.Oct);
    } else if (translatingDate.indexOf("November") > -1) {
        translatingDate = translatingDate.replace('November', editor.selectedLanguage.November);
    } else if (translatingDate.indexOf("Nov") > -1) {
        translatingDate = translatingDate.replace('Nov', editor.selectedLanguage.Nov);
    } else if (translatingDate.indexOf("December") > -1) {
        translatingDate = translatingDate.replace('December', editor.selectedLanguage.December);
    } else if (translatingDate.indexOf("Dec") > -1) {
        translatingDate = translatingDate.replace('Dec', editor.selectedLanguage.Dec);
    }
    return translatingDate;
};
Editor.prototype.showActivities = function() {
    $.ajax({
        type: "POST",
        url: "site/show-activities",
        data: {
            activityAmount: editor.optionsObject.activityAmount,
            activityType: editor.optionsObject.activityType,
            date_format: editor.optionsObject.dateFormat
        },
        success: function(data) {
            var activities_accordion = $('#for-activity-results');
            activities_accordion.empty();
            var empty_result = $('#for-empty-result');
            if (data.success) {
                empty_result.hide();
                var activities = data.activitiesArr;
                var date = '';
                for (var i = 0; i < activities.length; i++) {
                    if (activities[i].date === 'Today' || activities[i].date === 'Yesterday') {
                        date = editor.selectedLanguage[activities[i].date];
                    } else {
                        date = editor.translateDate(activities[i].date);
                    }
                    activities_accordion.append('<li class="list-group-item">' + '<p style="margin: 0"><strong>' + date + '</strong></p>' + '<p style="margin: 0"><i data-tr-detail="Words">' + editor.selectedLanguage["Words"] + '</i>: ' + activities[i].total_words + ', <i data-tr-detail="Characters"> ' + editor.selectedLanguage["Characters"] + '</i>: ' + activities[i].total_characters + '</p>' + '</li>');
                }
            } else {
                empty_result.show();
            }
        }
    });
};
Editor.prototype.showExistingDocuments = function() {
    $.ajax({
        type: "POST",
        url: "site/get-documents",
        data: {
            date_format: editor.optionsObject.dateFormat,
            time_format: editor.optionsObject.timeFormat
        },
        success: function(data) {
            $('#existing_documents').empty();
            var date, document_name, document_url;
            if (data.success == true) {
                if (data.user_documents) {
                    data.user_documents.forEach(function(document, index) {
                        date = document.updated_at;
                        document_name = document.document_name;
                        document_url = document.url ? (abs_path + document.url) : "";
                        $('#existing_documents').append('<div class="col-xs-12 user_record" id="document_' + document.id + '">' + '<div class="col-xs-5" style="padding: 0">' + '<div class="col-xs-2 col-sm-1" style="padding: 5px 5px 0 5px; font-weight: bold">' + (index + 1) + '.' + '</div>' + '<div class="col-xs-9 col-sm-10" style="padding: 5px 0 0 0; font-style: italic; font-weight: bold">' + editor.translateDate(date) + '</div>' + '<div class="col-xs-12" style="padding: 0;">' + '<div class="col-xs-2 col-sm-1" style="padding: 5px 5px 0 5px;">' + '</div>' + '<div class="col-xs-9 col-sm-10" style="padding: 0">' + document_name + '</div>' + '</div>' + '</div>' + '<div class="col-xs-7" style="margin-top: 9px; padding: 0">' + '<button type="button" class="btn btn-info btn-xs" style="float:right;margin-right:1%;" onclick="editor.getDocumentUrl(' + document.id + '); if($(this).hasClass(\'collapsed\')) $(\'#copy_link_for_document' + document.id + '\').text(\'(' + editor.selectedLanguage.copy + ')\');" data-toggle="collapse" href="#collapseForDocument' + document.id + '" aria-expanded="false" aria-controls="collapseForDocument' + document.id + '">' + editor.selectedLanguage.get_public_link + '</button>' + '<button type="button" class="btn btn-danger btn-xs" style="float:right;margin-right:1%;" onclick="editor.deleteDocument(' + document.id + ')">' + editor.selectedLanguage.delete + '</button>' + '<button type="button" class="btn btn-success btn-xs" style="float:right; margin-right:1%;" onclick="editor.loadDocument(' + document.id + ')">' + editor.selectedLanguage.load + '</button>' + '</div>' + '<div class="col-xs-12 collapse collapsesForDocuments" id="collapseForDocument' + document.id + '">' + '<div class="col-sm-6 col-xs-9" style="padding: 0;">' + '<input type="text" class="form-control input-sm" id="public_url_of_document' + document.id + '" value="' + document_url + '" readonly>' + '</div>' + '<div class="col-sm-6 col-xs-3" style="padding-top: 4px; padding-left: 5px;">' + '<a href="#" id="copy_link_for_document' + document.id + '" onclick="editor.copyDocumentUrl(event, this, ' + document.id + ')">(' + editor.selectedLanguage.copy + ')</a>' + '</div>' + '</div>' + '</div>');
                    });
                }
            } else if (data.success == 'empty') {
                $('#existing_documents').append('<div class="col-md-12 user_goal" id="" style="text-align: center;">' +
                    editor.selectedLanguage.above_you_can_save_your_first_document + '</div>');
            }
        }
    });
};
Editor.prototype.getDocumentUrl = function(id) {
    if ($('#public_url_of_document' + id).val() == '') {
        $.ajax({
            type: "POST",
            url: "site/get-document-url",
            data: {
                'id': id
            },
            success: function(data) {
                if (data.success) {
                    $('#public_url_of_document' + id).val(abs_path + data.url);
                }
            }
        });
    }
};
Editor.prototype.copyDocumentUrl = function(ev, obj, id) {
    ev.preventDefault();
    $(obj).text('(' + editor.selectedLanguage.copied + ')');
    $('#public_url_of_document' + id).focus();
    document.execCommand('SelectAll');
    document.execCommand("Copy", false, null);
};
Editor.prototype.saveDocument = function() {
    var error_box = $(".error_for_save_document");
    var error_message = '';
    if (!editor.box.val()) {
        error_message = editor.selectedLanguage.documents_content_cant_be_blank;
    } else if (!$('#document_name').val()) {
        error_message = editor.selectedLanguage.documents_name_cant_be_blank;
    }
    if (error_message) {
        error_box.html('<div class="alert alert-warning" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + error_message + '</div>');
        error_box.slideDown();
        setTimeout(function() {
            error_box.slideUp();
        }, 6000);
        return;
    }
    $.ajax({
        type: "POST",
        url: "site/save-document",
        data: {
            document_name: $('#document_name').val(),
            document_content: editor.box.val()
        },
        success: function(data) {
            if (data.success) {
                editor.showExistingDocuments();
                $('#document_name').val('');
                error_box.html('<div class="alert alert-success" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_document_was_saved_successfully + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    error_box.slideUp();
                }, 6000);
                editor.showActivities();
                editor.setRecordInputs();
            } else {
                error_box.html('<div class="alert alert-warning" style="text-align: center">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage[data.type] + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    error_box.slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.deleteDocument = function(id) {
    var dataObject = {
        'id': id
    };
    $.ajax({
        type: "POST",
        url: "site/delete-document",
        data: dataObject,
        success: function(data) {
            var error_box = $(".error_for_save_document");
            if (data.success) {
                $('#document_' + id).fadeOut(500);
                setTimeout(function() {
                    editor.showExistingDocuments();
                    if ($('#existing_documents').children().length == 0) {
                        $('#existing_documents').append('<div class="col-md-12 user_record" id="" style="text-align: center;">' +
                            editor.selectedLanguage.above_you_can_save_your_first_document + '</div>');
                    }
                }, 450);
                error_box.html('<div class="alert alert-success">' +
                    '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">&times;</a>' +
                    '<strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_document_was_deleted_successfully +
                    '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    error_box.slideUp();
                }, 6000);
                editor.showActivities();
            } else {
                error_box.html('<div  class="alert alert-warning">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.message] + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    error_box.slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.loadDocument = function(id) {
    var dataObject = {
        'id': id
    };
    $.ajax({
        type: "POST",
        url: "site/load-document",
        data: dataObject,
        success: function(data) {
            var error_box = $(".error_for_save_document");
            var success_box = $('.message_output');
            if (data.success) {
                editor.box.val(data.document_content);
                $('#save-modal').modal('hide');
            } else {
                error_box.html('<div  class="alert alert-warning">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.message] + '</div>');
                error_box.slideDown();
                setTimeout(function() {
                    error_box.slideUp();
                }, 6000);
            }
        }
    });
};
Editor.prototype.chr = function(codePt) {
    if (codePt > 0xFFFF) {
        codePt -= 0x10000;
        return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));
    }
    return String.fromCharCode(codePt);
};
Editor.prototype.cleanText = function() {
    var text = this.box.val();
    if ($('#chk_email_fix').prop('checked')) {
        text = text.replace(/\n{3,}/gi, "\n\n");
        text = text.replace(/ {2,}/gi, " ");
        text = text.replace(/\t/gi, " ");
        text = text.replace(/\n /gi, " ").replace(/\n,/gi, ",").replace(/\n\./gi, ".").replace(/\n!/gi, "!").replace(/\n\?/gi, "?").replace(/\n:/gi, ":").replace(/\n;/gi, ";");
    }
    if ($('#chk_mwd_fix').prop('checked')) {
        text = text.replace(/\xe2\x80\x98/gi, "'").replace(/\xe2\x80\x99/gi, "'").replace(/\xe2\x80\x9c/gi, '"').replace(/\xe2\x80\x9d/gi, '"').replace(/\xe2\x80\x93/gi, '-').replace(/\xe2\x80\x94/gi, '--').replace(/\xe2\x80\xa6/gi, '...');
        text = text.replaceAll(this.chr(145), "'").replaceAll(this.chr(146), "'").replaceAll(this.chr(147), '"').replaceAll(this.chr(148), '"').replaceAll(this.chr(150), '-').replaceAll(this.chr(151), '--').replaceAll(this.chr(133), '...');
    }
    if ($('#chk_multiple_new_lines_fix').prop('checked')) {
        text = text.replace(/\n{3,}/gi, "\n\n");
    }
    setTimeout(function() {
        editor.box.focus();
        document.execCommand('selectAll', false, null);
        document.execCommand("insertHTML", false, text);
    }, 500);
};
Editor.prototype.details = function() {
    var no_switch_details_count = 0;
    $.each(this.optionsObject['details'], function(index, value) {
        $("#chk_" + index).bootstrapSwitch('state', value);
        if (value) {
            $("#" + index).closest("li").show();
            $("#" + index + "_small").closest("li").show();
        } else {
            no_switch_details_count++;
            $("#" + index).closest("li").hide();
            $("#" + index + "_small").closest("li").hide();
        }
    });
    $('#no_switch_details').text(no_switch_details_count);
};
Editor.prototype.buttons = function() {
    var no_switch_buttons_count = 0;
    $.each(this.optionsObject['buttons'], function(index, value) {
        $("#btn-" + index).bootstrapSwitch('state', value);
        if (value) {
            $("#" + index).show();
            switch (index) {
                case "goal-btn":
                    if (editor.optionsObject.buttons['goalViewBox']) {
                        $("#goalViewBox").show();
                        $('#' + index).addClass('active');
                    } else {
                        $("#goalViewBox").hide();
                        $('#' + index).removeClass('active');
                    }
                    break;
                case "speed-btn":
                    if (editor.optionsObject.buttons['copy']) {
                        $("#copy").show();
                        $('#' + index).addClass('active');
                    }
                    break;
            }
            if (index == 'case-btn') {}
        } else {
            if (index != 'goalViewBox' && index != 'copy')
                no_switch_buttons_count++;
            $("#" + index).hide();
            if (index == "goal-btn") {
                $("#goalViewBox").addClass('hidden');
                $('#' + index).removeClass('active');
            }
        }
    });
    $('#no_switch_buttons').text(no_switch_buttons_count);
};
Editor.prototype.version = function() {
    if (this.optionsObject['version'] == 'basic') {
        $('#version-btn-label').text(editor.selectedLanguage['go_advanced']);
        $('#version-btn-label').attr('data-tr-detail', 'go_advanced');
        $('#version-btn').data('type', 'advanced');
        $('#version-btn').addClass('advanced');
        $('#details_container').hide();
        $('#editor_container').addClass('col-md-12 full_width').removeClass('col-md-9');
        $('#version-btn').attr('onclick', 'editor.changeOption(editor.advancedVersionOptions); editor.setLanguageForSpeech(); editor.wordCountInternational(); editor.keywordDensity();');
    } else if (this.optionsObject['version'] == 'advanced') {
        $('#version-btn-label').text(editor.selectedLanguage['go_basic']);
        $('#version-btn-label').attr('data-tr-detail', 'go_basic');
        $('#version-btn').data('type', 'basic');
        $('#version-btn').removeClass('advanced');
        $('#details_container').show();
        $('#editor_container').addClass('col-md-9').removeClass('col-md-12 full_width');
        $('#version-btn').attr('onclick', 'editor.changeOption(editor.basicVersionOptions); editor.setLanguageForSpeech();');
        if (user_id_for_goal !== undefined) {
            $.ajax({
                url: 'site/set-goal',
                type: "POST",
                data: {
                    'set_goal': true
                },
                success: function(data) {
                    if (data.success == 'true') {
                        goal.set([data.goal_count, data.goal_type, data.goal_length_type]);
                    } else if (data.success == 'no_set_goal') {}
                }
            });
        }
    }
};
Editor.prototype.detailsContainer = function() {
    if (this.optionsObject.detailsContainer) {
        $('.hide_button').attr('data-tr-detail', 'hide');
        $('.hide_button').text(editor.selectedLanguage['hide']);
        $('.fa-caret-right').show();
        $('.fa-caret-left').hide();
        $('.hide_button').attr('title', editor.selectedLanguage['hide_details_panel']);
        if (!this.optionsObject.keywordDensityPanel && !this.optionsObject.detailsPanel && !this.optionsObject.activityPanel) {
            var changeObj = {
                keywordDensityPanel: true,
                detailsPanel: true,
                activityPanel: true
            };
            this.changeOption(changeObj);
        }
        $('#accordion').fadeIn(250);
        $('#editor_container').removeClass('clicked');
        $('#details_container').removeClass('clicked');
    } else {
        $('.hide_button').attr('data-tr-detail', 'show');
        $('.hide_button').text(editor.selectedLanguage['show']);
        $('.fa-caret-right').hide();
        $('.fa-caret-left').show();
        $('.hide_button').attr('title', editor.selectedLanguage['show_details_panel']);
        $('#accordion').fadeOut(150);
        $('#details_container').addClass('clicked');
        $('#editor_container').addClass('clicked');
    }
};
Editor.prototype.detailsPanel = function() {
    if (this.optionsObject['detailsPanel']) {
        $("#show-details").prop("checked", true);
        $('#details .bootstrap-switch, #details a').css({
            'opacity': '1',
            'pointer-events': 'all'
        });
        $('#details_panel, #details_panel1').show();
    } else {
        $("#show-details").prop("checked", false);
        $('#details .bootstrap-switch, #details a').css({
            'opacity': '0.5',
            'pointer-events': 'none'
        });
        $('#details_panel, #details_panel1').hide();
    }
};
Editor.prototype.keywordDensityPanel = function() {
    if (this.optionsObject['keywordDensityPanel']) {
        $("#show-keyword-density").prop("checked", true);
        $("#kwd-density").show();
        $('#keywordDensityAmount').removeAttr('disabled');
        $('#stopWordsCommon').removeAttr('disabled');
        $('#keywordDensityConsecutive').removeAttr('disabled');
        this.keywordDensity();
    } else {
        $("#show-keyword-density").prop("checked", false);
        $("#kwd-density").hide();
        $('#keywordDensityAmount').attr('disabled', 'disabled');
        $('#stopWordsCommon').attr('disabled', 'disabled');
        $('#keywordDensityConsecutive').attr('disabled', 'disabled');
    }
};
Editor.prototype.activityPanel = function() {
    if (this.optionsObject.activityPanel) {
        $("#show-activity").prop("checked", true);
        $("#activities").show();
        $('#activityAmount').removeAttr('disabled');
        $('#activityType').removeAttr('disabled');
        this.keywordDensity();
    } else {
        $("#show-activity").prop("checked", false);
        $("#activities").hide();
        $('#activityAmount').attr('disabled', 'disabled');
        $('#activityType').attr('disabled', 'disabled');
    }
};
Editor.prototype.keywordDensityAccordion = function() {
    if (this.optionsObject.keywordDensityAccordion) {
        $('#kwd-accordion').collapse('show');
    } else {
        $('#kwd-accordion').collapse('hide');
    }
};
Editor.prototype.activityAccordion = function() {
    if (this.optionsObject.activityAccordion) {
        $('#activities-accordion').collapse('show');
    } else {
        $('#activities-accordion').collapse('hide');
    }
};
Editor.prototype.detailsPanelAccordion = function() {
    if (this.optionsObject.detailsPanelAccordion) {
        $('#details-accordion').collapse('show');
    } else {
        $('#details-accordion').collapse('hide');
    }
};
Editor.prototype.keywordDensityAmount = function() {
    $('#keywordDensityAmount').val(this.optionsObject['keywordDensityAmount']);
    this.keywordDensity();
};
Editor.prototype.activityAmount = function() {
    $('#activityAmount').val(this.optionsObject.activityAmount);
    this.keywordDensity();
};
Editor.prototype.activityType = function() {
    $('#activityType').val(this.optionsObject.activityType);
    this.keywordDensity();
};
Editor.prototype.keywordDensityConsecutive = function() {
    var keywordDensityConsecutive = this.optionsObject['keywordDensityConsecutive'];
    $('#keywordDensityConsecutive').val(keywordDensityConsecutive);
    $('.keyword_density_consecutive').removeClass('active_consecutive');
    if (keywordDensityConsecutive <= 3) {
        $('#consecutive-' + keywordDensityConsecutive + '-link').addClass('active_consecutive');
    }
    this.keywordDensity();
};
Editor.prototype.keywordDensityWordsCommon = function() {
    if (this.optionsObject['keywordDensityWordsCommon']) {
        $('#stopWordsCommon').prop('checked', true);
    } else {
        $('#stopWordsCommon').prop('checked', false);
    }
    this.keywordDensity();
};
Editor.prototype.readRate = function() {
    $('#read_rate').val(this.optionsObject['readRate']);
};
Editor.prototype.readPitch = function() {
    $('#read_pitch').val(this.optionsObject['readPitch']);
};
Editor.prototype.readVoices = function() {
    $('#read_voices').val(this.optionsObject['readVoices']);
};
Editor.prototype.selectLanguage = function() {
    $('#select_language').val(this.optionsObject['selectLanguage']);
};
Editor.prototype.selectDialect = function() {
    $('#select_dialect').val(this.optionsObject['selectDialect']);
};
Editor.prototype.wordsPerMinuteForReading = function() {
    $('#words_per_minut_reading').val(this.optionsObject['wordsPerMinuteForReading']);
    $('#reading_time_tooltip').attr('data-original-title', editor.selectedLanguage.based_on_an_average_reading_speed_of + this.optionsObject['wordsPerMinuteForReading'] + editor.selectedLanguage.words_per_minute_for_reading).tooltip('fixTitle');
    var text = this.box.val();
    this.readingTime(text);
    $("#reading_time, #reading_time1").text(this.count['reading_time']);
};
Editor.prototype.wordsPerMinuteForSpeaking = function() {
    $('#words_per_minut_speaking').val(this.optionsObject['wordsPerMinuteForSpeaking']);
    $('#speaking_time_tooltip').attr('data-original-title', editor.selectedLanguage.based_on_an_average_speaking_speed_of + this.optionsObject['wordsPerMinuteForSpeaking'] + editor.selectedLanguage.words_per_minute_for_speaking).tooltip('fixTitle');
    var text = this.box.val();
    this.speakingTime(text);
    $("#speaking_time, #speaking_time1").text(this.count['speaking_time']);
};
Editor.prototype.lettersPerMinuteForHandWriting = function() {
    $('#letters_per_minute').val(this.optionsObject['lettersPerMinuteForHandWriting']);
    $('#hand_writing_time_tooltip').attr('data-original-title', editor.selectedLanguage.based_on_an_average_hand_writing_speed_of + this.optionsObject['lettersPerMinuteForHandWriting'] + editor.selectedLanguage.letters_per_minute).tooltip('fixTitle');
    var text = this.box.val();
    this.handWritingTime(text);
    $("#hand_writing_time, #hand_writing_time1").text(this.count['hand_writing_time']);
};
Editor.prototype.boxHeight = function() {
    if (this.optionsObject.boxHeight['boxAutoSize']) {
        $('#autoResizeTextArea').prop('checked', true);
        this.box.css('overflow', 'hidden');
        this.box.css('height', 'auto');
        this.box.height(this.box[0].scrollHeight);
        this.box.css('min-height', '250px');
    } else {
        this.box.css('overflow-y', 'auto');
        $('#autoResizeTextArea').prop('checked', false);
        this.box.css('min-height', '0');
        if (this.optionsObject.boxHeight['box_height']) {
            this.box.height(this.optionsObject.boxHeight['box_height']);
        } else {
            this.box.height(250);
            this.optionsObject.boxHeight['box_height'] = this.box.height();
        }
    }
};
Editor.prototype.theme = function() {
    this.setTheme(this.optionsObject.theme);
};
Editor.prototype.font = function() {
    this.setBoxFont(this.optionsObject.font);
};
Editor.prototype.dateFormat = function() {
    this.setDateFormat(this.optionsObject.dateFormat);
};
Editor.prototype.timeFormat = function() {
    this.setTimeFormat(this.optionsObject.timeFormat);
};
Editor.prototype.wcLanguage = function() {
    var wcLanguage = this.optionsObject.wcLanguage;
    $("#wc_language_dropdown option[value='" + wcLanguage + "']").attr('selected', 'selected');
    translate.setWcLanguage();
};
Editor.prototype.setEditorOptions = function() {
    this.details();
    this.buttons();
    this.version();
    this.detailsPanel();
    this.detailsPanelAccordion();
    this.keywordDensityPanel();
    this.keywordDensityAccordion();
    this.keywordDensityAmount();
    this.keywordDensityConsecutive();
    this.keywordDensityWordsCommon();
    this.activityPanel();
    this.activityAccordion();
    this.activityAmount();
    this.activityType();
    this.readRate();
    this.readPitch();
    this.readVoices();
    this.selectLanguage();
    this.selectDialect();
    this.wordsPerMinuteForReading();
    this.wordsPerMinuteForSpeaking();
    this.boxHeight();
    this.theme();
    this.font();
    this.dateFormat();
    this.timeFormat();
    this.wcLanguage();
};
Editor.prototype.changeOption = function(changed_object) {
    var function_name, status;
    var $this = this;
    if (typeof changed_object === "object") {
        for (var key in changed_object) {
            if (key in $this.optionsObject) {
                function_name = key;
                if (typeof changed_object[key] === "object") {
                    for (var key1 in changed_object[key]) {
                        if (key1 in $this.optionsObject[key]) {
                            $this.optionsObject[key][key1] = changed_object[key][key1];
                        }
                    }
                } else {
                    $this.optionsObject[key] = changed_object[key];
                }
            }
            window['editor'][function_name]();
        }
        $.cookie('optionsObject', JSON.stringify($this.optionsObject), {
            expires: 365
        });
    } else {
        alert('Parameter should be object');
        return false;
    }
};
Editor.prototype.printTextOfEditor = function() {
    childWindow = window.open('', 'childWindow', 'location=yes, menubar=yes, toolbar=yes');
    childWindow.document.open();
    childWindow.document.write('<html><head></head><body>');
    childWindow.document.write(document.getElementById('box').value.replace(/\n/gi, '<br>'));
    childWindow.document.write('</body></html>');
    childWindow.print();
    childWindow.document.close();
    childWindow.close();
};
Editor.prototype.getTotalWeights = function(arr) {
    var total = 0;
    $.each(arr, function() {
        total += this;
    });
    return total;
};
Editor.prototype.keywordDensity = function() {
    if ($("#show-keyword-density").prop("checked")) {
        var selected_text = this.box.selection();
        var obj = $('#for_keyword_density');
        if (selected_text !== '') {
            obj.val(this.removeUncountablePartsFromText($('#for_counting_lines').val()));
        } else {
            obj.val(this.removeUncountablePartsFromText(this.box.val()));
        }
        var max = 200;
        var wordsToShow = this.optionsObject['keywordDensityAmount'];
        var text_without_space = obj.val().replace(/\s+/g, '');
        text_without_space = text_without_space.replace(/’/g, "'").replace(/“/g, '"').replace(/”/g, '"');
        matches = text_without_space.match(/([^\x00-\x7F\u2013\u2014])+/gi);
        if (matches !== null) {
            var latin_only = false;
        } else {
            var latin_only = true;
        }
        $.wordStats.latinOnly = latin_only;
        $.wordStats.useStopWords = this.optionsObject['keywordDensityWordsCommon'];
        $.wordStats.keywords = this.optionsObject.keywordDensityConsecutive;
        $.wordStats.computeTopWords(max, obj);
        totalWeights = this.getTotalWeights($.wordStats.topWeights);
        density_list = $("#kwd-accordion-data");
        density_list.empty();
        var percentage;
        var text = obj.val();
        var whiteListArr = $.wordStats.whiteList;
        for (var key in $.wordStats.whiteList) {
            if (text.indexOf(key) > -1) {
                $.wordStats.topWords.push(key);
                totalWeight = text.match(new RegExp(key.replace(/\./gi, '\\.'), "g")).length;
                for (var key1 in whiteListArr) {
                    if (key1.indexOf(key) > -1 && key != key1) {
                        if (text.indexOf(key1) > -1) {
                            totalWeight -= text.match(new RegExp(key1.replace(/\./gi, '\\.'), "g")).length;
                        }
                    }
                }
                $.wordStats.topWeights.push(totalWeight);
                totalWeights += totalWeight;
            }
        }
        var topWordsLen = $.wordStats.topWords.length;
        if (topWordsLen > 0) {
            for (var i = 0; i < topWordsLen; i++) {
                if (i == wordsToShow) {
                    break;
                }
                percentage = (100 * ($.wordStats.topWeights[i] / totalWeights)).toFixed(0);
                density_list.append('<a class="list-group-item" href="#" onmouseover="$(this).find(\'.ignore_word\').css(\'visibility\', \'visible\');" onmouseout="$(this).find(\'.ignore_word\').css(\'visibility\', \'hidden\');"><span class="badge"> ' + $.wordStats.topWeights[i] + ' (' + percentage + '%)</span><span class="word">' + $.wordStats.topWords[i] + '</span>&nbsp;<span id="ignore_word_tooltip_' + i + '" class="glyphicon glyphicon-remove ignore_word" style="color: #E21414; font-size: 11px; visibility: hidden; cursor: help" onclick="editor.addWordStoTopWords(this, event);" data-toggle="tooltip" data-placement="right" title="Ignore this word"></span></a>');
                $('#ignore_word_tooltip_' + i).tooltip('fixTitle');
            }
        } else {
            density_list.append('<li class="list-group-item"><p class="message_for_empty_panel">' + editor.selectedLanguage.start_typing_your_document_to_get_a_list_of_most_used_keywords + '</p></li>');
        }
        $.wordStats.clear();
    }
};
Editor.prototype.addWordStoTopWords = function(obj, ev) {
    ev.stopPropagation();
    ev.preventDefault();
    $('#reset_ignored_words').removeAttr('disabled');
    var word = $(obj).prev().text();
    $.wordStats.stopWords[word] = true;
    this.addingStopWords[word] = true;
    var count_of_adding_words = $('#count_of_adding_words');
    count_of_adding_words.text(Number(count_of_adding_words.text()) + 1);
    localStorage.setItem('addingStopWords', JSON.stringify(this.addingStopWords));
    this.keywordDensity();
};
Editor.prototype.resetIgnoredWords = function(ev) {
    ev.preventDefault();
    for (var key in this.addingStopWords) {
        delete $.wordStats.stopWords[key];
    }
    this.addingStopWords = {};
    $('#count_of_adding_words').text(0);
    $('#reset_ignored_words').attr('disabled', 'disabled');
    this.keywordDensity();
    localStorage.setItem('addingStopWords', JSON.stringify(this.addingStopWords));
};
Editor.prototype.displayCount = function(flag) {
    var text_content = "";
    var numbers_with_commas_array = [];
    if (flag) {
        numbers_with_commas_array['character_count'] = this.count_for_selection['character_count'];
        numbers_with_commas_array['word_count'] = this.count_for_selection['word_count'];
        numbers_with_commas_array = this.commaSeparateNumber(numbers_with_commas_array);
    } else {
        numbers_with_commas_array['character_count'] = this.count['character_count'];
        numbers_with_commas_array['word_count'] = this.count['word_count'];
        numbers_with_commas_array = this.commaSeparateNumber(numbers_with_commas_array);
    }
    if (numbers_with_commas_array['word_count'] === 1) {
        wordOrWords = typeof editor.selectedLanguage.word === "undefined" ? " word" : " " + editor.selectedLanguage.word;
    } else {
        wordOrWords = typeof editor.selectedLanguage.words === "undefined" ? " words" : " " + editor.selectedLanguage.words;
    }
    if (numbers_with_commas_array['character_count'] === 1) {
        charOrChars = typeof editor.selectedLanguage.character === "undefined" ? " character" : " " + editor.selectedLanguage.character;
    } else {
        charOrChars = typeof editor.selectedLanguage.characters === "undefined" ? " characters" : " " + editor.selectedLanguage.characters;
    }
    text_content += this.optionsObject.details["word_count"] ? " " + numbers_with_commas_array['word_count'] + wordOrWords : "";
    text_content += this.optionsObject.details["character_count"] ? " " + numbers_with_commas_array['character_count'] + charOrChars : "";
    $(".counted").text(text_content);
    if ((parseInt(this.count['word_count']) >= 10) && (typeof IsGrammarlyEnabled == 'function') && !IsGrammarlyEnabled()) {
        if ($('.grammarly_warning').html() == '') {
            $('.grammarly_warning').html('Your text might contain writing issues - <a rel="nofollow" href="javascript:void;" class="_btncheck" data-target="_blank">Check now</a>');
            BindSubmit();
        }
    } else $('.grammarly_warning').html('');
};
Editor.prototype.commaSeparateNumber = function(arr_of_numbers) {
    var number_with_commas_arr = [];
    for (var key in arr_of_numbers) {
        number_with_commas_arr[key] = arr_of_numbers[key];
    }
    for (var key in number_with_commas_arr) {
        while (/(\d+)(\d{3})/.test(number_with_commas_arr[key].toString())) {
            number_with_commas_arr[key] = number_with_commas_arr[key].toString().replace(/(\d+)(\d{3})/, '$1' + ',' + '$2');
        }
    }
    return number_with_commas_arr;
};
Editor.prototype.displayTextBoxes = function(flag) {
    var number_with_commas_array = [];
    if (flag) {
        number_with_commas_array = this.commaSeparateNumber(this.count_for_selection);
    } else {
        number_with_commas_array = this.commaSeparateNumber(this.count);
    }
    $("#word_count, #word_count1").text(number_with_commas_array['word_count']);
    $("#unique_word_count, #unique_word_count1").text(number_with_commas_array['unique_word_count']);
    $("#character_count, #character_count1").text(number_with_commas_array['character_count']);
    $("#character_count_no_spaces, #character_count_no_spaces1").text(number_with_commas_array['chars_no_spaces']);
    $("#sentence_count, #sentence_count1").text(number_with_commas_array['sentence_count']);
    $("#paragraph_count, #paragraph_count1").text(number_with_commas_array['paragraph_count']);
    $("#avg_sentence_words, #avg_sentence_words1").text(number_with_commas_array['avg_sentence_words']);
    $("#longest_sentence_words, #longest_sentence_words1").text(number_with_commas_array['longest_sentence_words']);
    $("#shortest_sentence_words, #shortest_sentence_words1").text(number_with_commas_array['shortest_sentence_words']);
    $("#avg_sentence_chars, #avg_sentence_chars1").text(number_with_commas_array['avg_sentence_chars']);
    $("#avg_word_length, #avg_word_length1").text(number_with_commas_array['avg_word_length']);
    $("#avg_page_by_word, #avg_page_by_word1").text(number_with_commas_array['avg_page_by_word']);
    $("#count_words_syllables, #count_words_syllables1").text(number_with_commas_array['count_words_syllables']);
    $("#lines_count, #lines_count1").text(number_with_commas_array['lines_count']);
    $("#words_manuscript, #words_manuscript1").text(number_with_commas_array['words_manuscript']);
    $("#reading_level, #reading_level1").text(number_with_commas_array['reading_level']);
    $("#reading_time, #reading_time1").text(number_with_commas_array['reading_time']);
    $("#speaking_time, #speaking_time1").text(number_with_commas_array['speaking_time']);
    $("#hand_writing_time, #hand_writing_time1").text(number_with_commas_array['hand_writing_time']);
};
Editor.prototype.replaceDivToEn = function(html, word) {
    var text = html.replace(/<br\s*[\/]?>/gi, "\n").replace(/<div\s*[\/]?>/gi, "\n").replace(/<\/div>/gi, "").replace(/&nbsp;/gi, " ");
    var tmp = document.createElement("DIV");
    if (word != undefined && word == true) {
        text = text.replace(/&lt;/gi, ' <').replace(/&gt;/gi, '>');
    } else {
        text = text.replace(/&lt;/gi, '<').replace(/&gt;/gi, '>');
    }
    tmp.innerHTML = text;
    text = tmp.textContent || tmp.innerText || "";
    return text;
};
Editor.prototype.wordCountInternational = function() {
    var selected_text = this.box.selection();
    var text = this.box.val();
    if (selected_text !== '') {
        $('#for_counting_lines').val(selected_text);
        this.countAll(this.removeUncountablePartsFromText(selected_text), true);
    } else {
        $('#for_counting_lines').val(text);
        this.countAll(this.removeUncountablePartsFromText(text), false);
    }
};
Editor.prototype.removeUncountablePartsFromText = function(text) {
    var filteredText = text;
    var openIndex = 0,
        closeIndex = 0,
        index = 0;
    while (true) {
        if (filteredText.indexOf('~~~') !== -1) {
            openIndex = filteredText.indexOf('~~~');
            index = openIndex + 3;
            if (filteredText.indexOf('~~~', index) !== -1) {
                closeIndex = filteredText.indexOf('~~~', index) + 3;
                filteredText = filteredText.slice(0, openIndex) + filteredText.slice(closeIndex);
            } else {
                break;
            }
        } else {
            break;
        }
    }
    return filteredText;
};
var timer = function(name) {
    var start = new Date();
    return {
        stop: function() {
            var end = new Date();
            var time = end.getTime() - start.getTime();
            console.log('Timer:', name, 'finished in', time, 'ms');
        }
    }
};
Editor.prototype.countAll = function(text, flag) {
    if (this.optionsObject.details['word_count']) {
        this.countWords(text, flag);
    } else {
        this.count['word_count'] = 0;
        this.count_for_selection['word_count'] = 0;
    }
    if (this.optionsObject.details['character_count']) {
        this.countCharacters(text, flag);
    } else {
        this.count['character_count'] = 0;
        this.count_for_selection['character_count'] = 0;
    }
    if (this.optionsObject.details['character_count_no_spaces']) {
        this.countCharactersWithoutSpaces(text, flag);
    } else {
        this.count['chars_no_spaces'] = 0;
        this.count_for_selection['chars_no_spaces'] = 0;
    }
    if (this.optionsObject.details['unique_word_count']) {
        this.countUniqueWords(text, flag);
    }
    if (this.optionsObject.details['sentence_count']) {
        this.countSentences(text, flag);
    } else {
        this.count['sentence_count'] = 0;
        this.count_for_selection['sentence_count'] = 0;
    }
    this.countLongestSentenceWords(text, flag);
    this.countShortestSentenceWords(text, flag);
    this.countAvgSentenceWords(text, flag);
    this.countAvgSentenceChars(text, flag);
    this.countAvgWordLength(text, flag);
    this.countAvgPagesByWord(text, flag);
    this.countWordSyllables(text, flag);
    if (this.optionsObject.details['lines_count']) {
        this.countLines(text, flag);
    } else {
        this.count['lines_count'] = 0;
        this.count_for_selection['lines_count'] = 0;
    }
    this.countWordsManuscript(text, flag);
    if (this.optionsObject.details['paragraph_count']) {
        this.countParagraphs(text, flag);
    } else {
        this.count['paragraph_count'] = 0;
        this.count_for_selection['paragraph_count'] = 0;
    }
    this.readingTime(text, flag);
    this.speakingTime(text, flag);
    this.handWritingTime(text, flag);
    this.readingLevel(text, flag);
    this.displayCount(flag);
    this.displayTextBoxes(flag);
    goal.updateGoalBox();
    if (text == '') {
        $('#case-btn').attr('disabled', 'disabled');
    } else {
        $('#case-btn').removeAttr('disabled');
    }
};
Editor.prototype.countCharacters = function(text, flag) {
    var chars, chars_count;
    if (text.length < 100000) {
        chars = text.match(/(?:[^\r\n]|\r(?!\n))/g);
        chars_count = chars !== null ? chars.length : 0;
    } else {
        chars_count = text.length;
    }
    if (flag) {
        this.count_for_selection['character_count'] = chars_count;
    } else {
        this.count['character_count'] = chars_count;
    }
};
Editor.prototype.countWords = function(text, flag) {
    var $this = this;
    var words = this.wordsOfText(text);
    var words_count;
    this.uniqueWords = [];
    if (this.optionsObject.details['unique_word_count']) {
        if (Array.isArray(words)) {
            $this.uniqueWords = $this.uniqueArray(words);
        }
    }
    words_count = words !== null ? words.length : 0;
    if (flag) {
        this.count_for_selection['word_count'] = words_count;
    } else {
        this.count['word_count'] = words_count;
    }
};
Editor.prototype.wordsOfText = function(text) {
    var words, matches;
    var text_without_space = text.replace(/\s+/g, '');
    matches = text_without_space.match(/([^\x00-\x7F\u2013\u2014])+/gi);
    var latin_only = (matches === null);
    if (latin_only == false) {
        words = text.match(/\S+/g);
    } else {
        words = text.replace(/[;!:—\/]/g, ' ').replace(/\.\s+/g, ' ').replace(/[^a-zA-Z\d\s&:,]/g, '').replace(/,([^0-9])/g, ' $1').match(/\S+/g);
    }
    return words;
};
Editor.prototype.uniqueArray = function(array) {
    var obj = {},
        len = array.length,
        unique_arr = [];
    for (var i = 0; i < len; i++) {
        obj[array[i].toLowerCase()] = array[i];
    }
    for (var key in obj) {
        unique_arr.push(key);
    }
    return unique_arr;
};
Editor.prototype.countWordSyllables = function(text, flag) {
    if (this.optionsObject.details['count_words_syllables']) {
        var wordsArr = text.split(/\W+/);
        var wordsSyllables = 0;
        var len = wordsArr.length;
        for (var i = 0; i < len; i++) {
            wordsArr[i] = wordsArr[i].toLowerCase();
            if (wordsArr[i] in this.word_exceptions) {
                wordsSyllables += this.word_exceptions[wordsArr[i]];
            } else if (wordsArr[i].length <= 2 && wordsArr[i].length >= 1) {
                wordsSyllables++;
            } else if (wordsArr[i].length > 2) {
                wordsArr[i] = wordsArr[i].replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
                wordsArr[i] = wordsArr[i].replace(/^y/, '');
                if (!wordsArr[i].match(/[aeiouy]{1,2}/g)) {
                    wordsSyllables++;
                } else {
                    var wordSyllables = wordsArr[i].match(/[aeiouy]{1,2}/g).length;
                    wordsSyllables += wordSyllables;
                }
            }
        }
        if (flag) {
            this.count_for_selection['count_words_syllables'] = text != '' ? wordsSyllables : 0;
        } else {
            this.count['count_words_syllables'] = text != '' ? wordsSyllables : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['count_words_syllables'] = 0;
        } else {
            this.count['count_words_syllables'] = 0;
        }
    }
};
Editor.prototype.countCharactersWithoutSpaces = function(text, flag) {
    var chars_no_spaces = text.match(/\S/g);
    if (flag) {
        this.count_for_selection['chars_no_spaces'] = (chars_no_spaces !== null ? chars_no_spaces.length : 0);
    } else {
        this.count['chars_no_spaces'] = (chars_no_spaces !== null ? chars_no_spaces.length : 0);
    }
};
Editor.prototype.countSentences = function(text, flag) {
    var sentences = text.match(/[^.!?][^.!?]*(?:[.!?](?!['"]?|$)[^.!?]*)*[.!?]?['"]?(?=|$)([.!?]\s+[A-Z0-9])/g);
    if (sentences !== null) {
        var sentences_count = sentences.length;
        var actual_sentences_count = 1;
        for (var i = 0; i < sentences_count; i++) {
            if (sentences[i].match(/[0-9a-zA-Z]+/))
                actual_sentences_count++;
        }
        if (flag) {
            this.count_for_selection['sentence_count'] = actual_sentences_count;
        } else {
            this.count['sentence_count'] = actual_sentences_count;
        }
    } else {
        if (flag && text.match(/[0-9a-zA-Z]+/)) {
            this.count_for_selection['sentence_count'] = 1;
        } else if (!flag && text.match(/[0-9a-zA-Z]+/)) {
            this.count['sentence_count'] = 1;
        } else {
            this.count_for_selection['sentence_count'] = 0;
            this.count['sentence_count'] = 0;
        }
    }
};
Editor.prototype.countParagraphs = function(text, flag) {
    var paragraphs = text.match(/(\n\n?|^).+?(?=\n?\n?|$)/g);
    if (flag) {
        this.count_for_selection['paragraph_count'] = (text != '' ? (paragraphs !== null ? paragraphs.length : 0) : 0);
    } else {
        this.count['paragraph_count'] = (text != '' ? (paragraphs !== null ? paragraphs.length : 0) : 0);
    }
};
Editor.prototype.countUniqueWords = function(text, flag) {
    if (this.optionsObject.details['unique_word_count']) {
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (flag) {
            this.count_for_selection['unique_word_count'] = this.uniqueWords.length;
        } else {
            this.count['unique_word_count'] = this.uniqueWords.length;
        }
    } else {
        if (flag) {
            this.count_for_selection['unique_word_count'] = 0;
        } else {
            this.count['unique_word_count'] = 0;
        }
    }
};
Editor.prototype.countLongestSentenceWords = function(text, flag) {
    if (this.optionsObject.details.longest_sentence_words) {
        var sentences = text.match(/[^.!?][^.!?]*(?:[.!?](?!['"]?|$)[^.!?]*)*[.!?]?['"]?(?=|$)([.!?]\s+[A-Z0-9])/g);
        var words = 0,
            words_of_sentence, last_text = text;
        if (sentences) {
            for (var i = 0; i < sentences.length; i++) {
                if (i != sentences.length - 1) {
                    sentences[i + 1] = sentences[i][sentences[i].length - 1] + sentences[i + 1];
                }
                sentences[i] = sentences[i].slice(0, -1);
                last_text = last_text.replace(sentences[i], '');
            }
            sentences.push(last_text);
            for (var i = 0; i < sentences.length; i++) {
                words_of_sentence = (this.wordsOfText(sentences[i])).length;
                if (words_of_sentence > words) {
                    words = words_of_sentence;
                }
            }
        } else if (text != '') {
            words = (this.wordsOfText(text)).length
        }
        if (flag) {
            this.count_for_selection['longest_sentence_words'] = words;
        } else {
            this.count['longest_sentence_words'] = words;
        }
    } else {
        if (flag) {
            this.count_for_selection['longest_sentence_words'] = 0;
        } else {
            this.count['longest_sentence_words'] = 0;
        }
    }
};
Editor.prototype.countShortestSentenceWords = function(text, flag) {
    if (this.optionsObject.details.shortest_sentence_words) {
        var sentences = text.match(/[^.!?][^.!?]*(?:[.!?](?!['"]?|$)[^.!?]*)*[.!?]?['"]?(?=|$)([.!?]\s+[A-Z0-9])/g);
        var words = 0,
            words_of_sentence, last_text = text;
        if (sentences) {
            for (var i = 0; i < sentences.length; i++) {
                if (i != sentences.length - 1) {
                    sentences[i + 1] = sentences[i][sentences[i].length - 1] + sentences[i + 1];
                }
                sentences[i] = sentences[i].slice(0, -1);
                last_text = last_text.replace(sentences[i], '');
            }
            sentences.push(last_text);
            for (var i = 0; i < sentences.length; i++) {
                words_of_sentence = (this.wordsOfText(sentences[i])).length;
                if (i == 0) {
                    words = words_of_sentence;
                }
                if (words_of_sentence < words) {
                    words = words_of_sentence;
                }
            }
        } else if (text != '') {
            words = (this.wordsOfText(text)).length
        }
        if (flag) {
            this.count_for_selection['shortest_sentence_words'] = words;
        } else {
            this.count['shortest_sentence_words'] = words;
        }
    } else {
        if (flag) {
            this.count_for_selection['shortest_sentence_words'] = 0;
        } else {
            this.count['shortest_sentence_words'] = 0;
        }
    }
};
Editor.prototype.countAvgSentenceWords = function(text, flag) {
    if (this.optionsObject.details['avg_sentence_words']) {
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (!this.optionsObject.details['sentence_count'])
            this.countSentences(text, flag);
        if (flag) {
            this.count_for_selection['avg_sentence_words'] = text != '' ? Math.ceil(this.count_for_selection['word_count'] / this.count_for_selection['sentence_count']) : 0;
        } else {
            this.count['avg_sentence_words'] = text != '' ? Math.ceil(this.count['word_count'] / this.count['sentence_count']) : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['avg_sentence_words'] = 0;
        } else {
            this.count['avg_sentence_words'] = 0;
        }
    }
};
Editor.prototype.countAvgSentenceChars = function(text, flag) {
    if (this.optionsObject.details['avg_sentence_chars']) {
        if (!this.optionsObject.details['character_count'])
            this.countCharacters(text, flag);
        if (!this.optionsObject.details['sentence_count'])
            this.countSentences(text, flag);
        if (flag) {
            this.count_for_selection['avg_sentence_chars'] = text != '' ? Math.ceil(this.count_for_selection['character_count'] / this.count_for_selection['sentence_count']) : 0;
        } else {
            this.count['avg_sentence_chars'] = text != '' ? Math.ceil(this.count['character_count'] / this.count['sentence_count']) : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['avg_sentence_chars'] = 0;
        } else {
            this.count['avg_sentence_chars'] = 0;
        }
    }
};
Editor.prototype.countAvgWordLength = function(text, flag) {
    if (this.optionsObject.details['avg_word_length']) {
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (!this.optionsObject.details['character_count_no_spaces'])
            this.countCharactersWithoutSpaces(text, flag);
        if (flag) {
            this.count_for_selection['avg_word_length'] = text != '' ? Math.round((this.count_for_selection['chars_no_spaces'] / this.count_for_selection['word_count']) * 10) / 10 : 0;
        } else {
            this.count['avg_word_length'] = text != '' ? Math.round((this.count['chars_no_spaces'] / this.count['word_count']) * 10) / 10 : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['avg_word_length'] = 0;
        } else {
            this.count['avg_word_length'] = 0;
        }
    }
};
Editor.prototype.countAvgPagesByWord = function(text, flag) {
    if (this.optionsObject.details['avg_page_by_word']) {
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (flag) {
            this.count_for_selection['avg_page_by_word'] = text != '' ? Math.round((this.count_for_selection['word_count'] / 450) * 10) / 10 : 0;
        } else {
            this.count['avg_page_by_word'] = text != '' ? Math.round((this.count['word_count'] / 450) * 10) / 10 : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['avg_page_by_word'] = 0;
        } else {
            this.count['avg_page_by_word'] = 0;
        }
    }
};
Editor.prototype.countAvgCharsPerLine = function(box_width) {
    var $this = this;
    this.count['avg_width_of_char'] = 0;
    this.count_for_selection['avg_width_of_char'] = 0;
    var avg_width_of_char = 0;
    $('#for_counting_characters span').each(function() {
        $this.count['avg_width_of_char'] += $(this).width();
        $this.count_for_selection['avg_width_of_char'] += $(this).width();
    });
    this.count['avg_width_of_char'] = Math.round(this.count['avg_width_of_char'] / ($('#for_counting_characters span').length));
    this.count_for_selection['avg_width_of_char'] = Math.round(this.count_for_selection['avg_width_of_char'] / ($('#for_counting_characters span').length));
    this.count['avg_chars_count_per_line'] = box_width / this.count['avg_width_of_char'];
    this.count_for_selection['avg_chars_count_per_line'] = box_width / this.count_for_selection['avg_width_of_char'];
};
Editor.prototype.countLines = function(text, flag) {
    $('#for_counting_lines').css({
        'padding': this.box.css('padding'),
        'padding-top': 0,
        'padding-bottom': 0,
        'overflow': 'hidden'
    });
    var actualHeight = $('#for_counting_lines')[0].scrollHeight;
    if (flag) {
        this.count_for_selection['lines_count'] = text != '' ? Math.round(actualHeight / 20) : 0;
    } else {
        this.count['lines_count'] = text != '' ? Math.round(actualHeight / 20) : 0;
    }
};
Editor.prototype.countWordsManuscript = function(text, flag) {
    if (this.optionsObject.details['words_manuscript']) {
        if (!this.optionsObject.details['lines_count'])
            this.countLines(text, flag);
        if (!this.optionsObject.details['character_count'])
            this.countCharacters(text, flag);
        var box_readonly_width = $('#box-readonly').width();
        var box_width = this.box.width();
        if (box_readonly_width - box_width == 15 || box_readonly_width - box_width < 0) {
            this.countAvgCharsPerLine(box_width);
        } else {
            this.countAvgCharsPerLine(box_readonly_width);
        }
        if (flag) {
            this.count_for_selection['words_manuscript'] = text != '' ? Math.round((this.count_for_selection['avg_chars_count_per_line'] / 6) * this.count_for_selection['lines_count']) : 0;
        } else {
            this.count['words_manuscript'] = text != '' ? Math.round((this.count['avg_chars_count_per_line'] / 6) * this.count['lines_count']) : 0;
        }
    } else {
        if (flag) {
            this.count_for_selection['words_manuscript'] = 0;
        } else {
            this.count['words_manuscript'] = 0;
        }
    }
};
Editor.prototype.readingTime = function(text, flag) {
    if (this.optionsObject.details["reading_time"]) {
        var int_part_of_number, decimal_part_of_number;
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (flag) {
            var duration1 = this.count_for_selection['word_count'] / this.optionsObject.wordsPerMinuteForReading;
            if (duration1 < 1) {
                this.count_for_selection['reading_time'] = Math.ceil(duration1 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration1 >= 1 && duration1 < 60) {
                duration1 = Math.round(duration1 * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['reading_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration1 = Math.round((duration1 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['reading_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        } else {
            var duration2 = this.count['word_count'] / this.optionsObject.wordsPerMinuteForReading;
            if (duration2 < 1) {
                this.count['reading_time'] = Math.ceil(duration2 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration2 >= 1 && duration2 < 60) {
                duration2 = Math.round(duration2 * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['reading_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration2 = Math.round((duration2 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['reading_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        }
    } else {
        if (flag) {
            this.count_for_selection['reading_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        } else {
            this.count['reading_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        }
    }
};
Editor.prototype.speakingTime = function(text, flag) {
    if (this.optionsObject.details["speaking_time"]) {
        if (!this.optionsObject.details['word_count'])
            this.countWords(text, flag);
        if (flag) {
            var duration1 = this.count_for_selection['word_count'] / this.optionsObject.wordsPerMinuteForSpeaking;
            if (duration1 < 1) {
                this.count_for_selection['speaking_time'] = Math.ceil(duration1 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration1 >= 1 && duration1 < 60) {
                duration1 = Math.round(duration1 * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['speaking_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration1 = Math.round((duration1 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['speaking_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        } else {
            var duration2 = this.count['word_count'] / this.optionsObject.wordsPerMinuteForSpeaking;
            if (duration2 < 1) {
                this.count['speaking_time'] = Math.ceil(duration2 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration2 >= 1 && duration2 < 60) {
                duration2 = Math.round(duration2 * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['speaking_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration2 = Math.round((duration2 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['speaking_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        }
    } else {
        if (flag) {
            this.count_for_selection['speaking_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        } else {
            this.count['speaking_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        }
    }
};
Editor.prototype.handWritingTime = function(text, flag) {
    var int_part_of_number, decimal_part_of_number;
    if (this.optionsObject.details["hand_writing_time"]) {
        if (!this.optionsObject.details['character_count'])
            this.countCharacters(text, flag);
        if (flag) {
            var duration1 = this.count_for_selection['character_count'] / this.optionsObject.lettersPerMinuteForHandWriting;
            if (duration1 < 1) {
                this.count_for_selection['hand_writing_time'] = Math.ceil(duration1 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration1 >= 1 && duration1 < 60) {
                duration1 = Math.round(duration1 * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['hand_writing_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration1 = Math.round((duration1 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration1);
                decimal_part_of_number = Math.round(duration1 % 1 * 60);
                this.count_for_selection['hand_writing_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        } else {
            var duration2 = this.count['character_count'] / this.optionsObject.lettersPerMinuteForHandWriting;
            if (duration2 < 1) {
                this.count['hand_writing_time'] = Math.ceil(duration2 * 60) + ' ' + editor.selectedLanguage.sec;
            } else if (duration2 >= 1 && duration2 < 60) {
                duration2 = Math.round(duration2 * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['hand_writing_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins) + ' ' + decimal_part_of_number + ' ' + editor.selectedLanguage.sec
            } else {
                duration2 = Math.round((duration2 / 60) * 100) / 100;
                int_part_of_number = Math.floor(duration2);
                decimal_part_of_number = Math.round(duration2 % 1 * 60);
                this.count['hand_writing_time'] = int_part_of_number + ' ' + (int_part_of_number == 1 ? editor.selectedLanguage.hr : editor.selectedLanguage.hrs) + ' ' + decimal_part_of_number + ' ' + (decimal_part_of_number <= 1 ? editor.selectedLanguage.minute : editor.selectedLanguage.mins);
            }
        }
    } else {
        if (flag) {
            this.count_for_selection['hand_writing_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        } else {
            this.count['hand_writing_time'] = 0 + ' ' + editor.selectedLanguage.sec;
        }
    }
};
Editor.prototype.readingLevel = function(text, flag) {
    if (this.optionsObject.details["reading_level"]) {
        if (!this.optionsObject.details['sentence_count'])
            this.countSentences(text, flag);
        if (flag) {
            if (this.count_for_selection['sentence_count'] > 2) {
                var d = new DaleChallIndex(text, this.count_for_selection['sentence_count']);
                this.count_for_selection['reading_level'] = d.getReadingLevel();
            } else {
                this.count_for_selection['reading_level'] = editor.selectedLanguage.n_a;
            }
        } else {
            if (this.count['sentence_count'] > 2) {
                var d = new DaleChallIndex(text, this.count['sentence_count']);
                this.count['reading_level'] = d.getReadingLevel();
            } else {
                this.count['reading_level'] = editor.selectedLanguage.n_a;
            }
        }
    } else {
        if (flag) {
            this.count_for_selection['reading_level'] = editor.selectedLanguage.n_a;
        } else {
            this.count['reading_level'] = editor.selectedLanguage.n_a;
        }
    }
};
Editor.prototype.setWPM = function(obj, type) {
    var words_per_minute_reading = $('#words_per_minut_reading');
    var words_per_minute_speaking = $('#words_per_minut_speaking');
    if (type == 'reading') {
        words_per_minute_reading.val($(obj).data('number'));
        this.changeOption({
            'wordsPerMinuteForReading': words_per_minute_reading.val()
        });
    } else if (type == 'speaking') {
        words_per_minute_speaking.val($(obj).data('number'));
        this.changeOption({
            'wordsPerMinuteForSpeaking': words_per_minute_speaking.val()
        });
    }
};
Editor.prototype.setLPM = function(obj) {
    var score = $(obj).data('number');
    $('#letters_per_minute').val(score);
    this.changeOption({
        'lettersPerMinuteForHandWriting': score
    });
};
Editor.prototype.changeDetails = function() {
    var savedObject = {
        'details': {}
    };
    var $this = this;
    $('#details .bootstrap-switch-handle-on, #details .bootstrap-switch-handle-off, #details .bootstrap-switch-label').on('click', function() {
        var savedObject = {
            'details': {}
        };
        var obj = $(this).parent().find('input');
        var id = obj.data('detail');
        var state = obj.prop('checked');
        savedObject.details[id] = state;
        $this.changeOption(savedObject);
        $this.wordCountInternational();
    });
};
Editor.prototype.changeButtonDetails = function() {
    var $this = this;
    $('#buttons .bootstrap-switch-handle-on, #buttons .bootstrap-switch-handle-off, #buttons .bootstrap-switch-label').on('click', function() {
        var savedObject = {
            'buttons': {}
        };
        var obj = $(this).parent().find('input');
        var id = obj.data('detail');
        var state = obj.prop('checked');
        savedObject.buttons[id] = state;
        if (state) {
            $("#" + id).show();
            if (id == 'case-btn') {
                ga('send', 'event', 'case', 'show button', 'options -> buttons -> case switch: on');
            }
        } else {
            $("#" + id).hide();
            if (id == "speed-btn") {
                $("#copy").hide();
                savedObject.buttons['copy'] = false;
                $this.resetTimer();
            }
            if (id == 'case-btn') {
                ga('send', 'event', 'case', 'hide button', 'options -> buttons -> case switch: off');
            }
        }
        $this.changeOption(savedObject);
    });
};
Editor.prototype.showOrHideSpeedBox = function(obj, close) {
    var savedObject = {
        'buttons': {}
    };
    if (close === undefined) {
        if (!$(obj).hasClass('active')) {
            $('#copy').show();
            savedObject.buttons['copy'] = true;
            $(obj).addClass('active');
        } else {
            $('#copy').hide();
            savedObject.buttons['copy'] = false;
            $(obj).removeClass('active');
            this.resetTimer();
        }
    } else if (close == 'close') {
        $('#copy').hide();
        savedObject.buttons['copy'] = false;
        $(obj).removeClass('active');
        this.resetTimer();
    }
    this.changeOption(savedObject);
};
Editor.prototype.showOrHideReadBox = function(obj, close) {
    var savedObject = {
        'buttons': {}
    };
    if (close === undefined) {
        if (!$(obj).hasClass('active')) {
            $('#text-to-speech-controls').show();
            $(obj).addClass('active');
        } else {
            $('#text-to-speech-controls').hide();
            $(obj).removeClass('active');
        }
    } else if (close == 'close') {
        $('#text-to-speech-controls').hide();
        $(obj).removeClass('active');
    }
};
Editor.prototype.hideOrShowDetails = function(obj) {
    if ($(obj).attr('data-tr-detail') == 'hide') {
        var changeObj = {
            detailsContainer: false
        };
        $(obj).attr('data-tr-detail', 'show');
        this.changeOption(changeObj);
    } else if ($(obj).attr('data-tr-detail') == 'show') {
        var changeObj = {
            detailsContainer: true
        };
        $(obj).attr('data-tr-detail', 'hide');
        this.changeOption(changeObj);
    }
};
Editor.prototype.checkCollapses = function() {
    setTimeout(function() {
        if (!editor.optionsObject.keywordDensityPanel && !editor.optionsObject.detailsPanel && !editor.optionsObject.activityPanel) {
            var changeObj = {
                detailsContainer: false
            };
            editor.changeOption(changeObj);
        }
    }, 600);
};
Editor.prototype.checkAccordion = function() {
    setTimeout(function() {
        if (!editor.optionsObject.keywordDensityAccordion && !editor.optionsObject.detailsPanelAccordion && !editor.optionsObject.activityAccordion) {
            var changeObj = {
                detailsContainer: false
            };
            editor.changeOption(changeObj);
        }
    }, 600);
};
Editor.prototype.sendMessage = function() {
    var msg = $("#message").val();
    if (msg == '') {
        $(".success").html('<div class="alert alert-danger" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Error!</strong> Message can not be empty.</div>');
        $('.success').slideDown();
        setTimeout(function() {
            $('.success').slideUp();
        }, 6000);
        return false;
    }
    var dataObject = {
        'message': msg
    };
    $.ajax({
        type: "POST",
        url: "site/send-email",
        data: dataObject,
        success: function(data) {
            data = JSON.parse(data);
            if (data.success) {
                $(".success").html('<div class="alert alert-success" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Success!</strong> Your message was sent successfuly.</div>');
                $('.success').slideDown();
                setTimeout(function() {
                    $('.success').slideUp();
                }, 6000);
            } else {
                $(".success").html('<div class="alert alert-danger" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Error!</strong> Sorry, there was a problem sending your message.</div>');
                $('.success').slideDown();
                setTimeout(function() {
                    $('.success').slideUp();
                }, 6000);
            }
        },
        error: function() {
            $(".success").html('<div class="alert alert-danger" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Error!</strong> Sorry, there was a problem sending your message.</div>');
            $('.success').slideDown();
            setTimeout(function() {
                $('.success').slideUp();
            }, 6000);
        }
    });
};
Editor.prototype.nl2br = function(str, is_xhtml) {
    var breakTag = (is_xhtml || typeof is_xhtml === 'undefined') ? '<br />' : '<br>';
    return (str + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag);
};
Editor.prototype.autoSaveAlert = function() {
    var icon = $("#revisions-btn i.fa"),
        diskIc = 'fa-floppy-o',
        checkedIc = 'fa-check',
        refreshIc = 'fa-refresh';
    icon.removeClass(diskIc).addClass(refreshIc + ' fa-spin');
    icon.parent().addClass('active');
    var checkInterval = setInterval(function() {
        icon.removeClass(refreshIc + ' fa-spin').addClass(checkedIc);
        var interval = setInterval(function() {
            icon.removeClass(checkedIc).addClass(diskIc);
            icon.parent().removeClass('active');
            clearInterval(interval);
        }, 500);
        clearInterval(checkInterval);
    }, 2000);
};
Editor.prototype.setSelectionRange = function(node, selectionStart, selectionEnd) {
    if (node.setSelectionRange) {
        node.focus();
        node.setSelectionRange(selectionStart, selectionEnd);
    } else if (node.createTextRange) {
        var range = node.createTextRange();
        range.collapse(true);
        range.moveEnd('character', selectionEnd);
        range.moveStart('character', selectionStart);
        range.select();
    }
};
Editor.prototype.setCaretToPos = function(node, pos) {
    this.setSelectionRange(node, pos, pos);
};
Editor.prototype.editorUndo = function() {
    document.execCommand("undo", false, null);
    this.setCaretToPos(this.node_for_box, this.box.prop("selectionEnd"));
};
Editor.prototype.editorRedo = function() {
    document.execCommand("redo", false, null);
};
Editor.prototype.editorClear = function() {
    var scrollTop = this.body.scrollTop();
    this.box.focus();
    document.execCommand("SelectAll", false, null);
    this.body.scrollTop(scrollTop);
    document.execCommand('delete', false, '');
};
String.prototype.toTitleCase = function() {
    var i, j, str, lowers, uppers;
    str = this.replace(/([^\W_]+[^\s-]*) */g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
    lowers = ['A', 'An', 'The', 'And', 'But', 'Or', 'For', 'Nor', 'As', 'At', 'By', 'For', 'From', 'In', 'Into', 'Near', 'Of', 'On', 'Onto', 'To', 'With'];
    for (i = 0, j = lowers.length; i < j; i++)
        str = str.replace(new RegExp('\\s' + lowers[i] + '\\s', 'g'), function(txt) {
            return txt.toLowerCase();
        });
    uppers = ['Id', 'Tv'];
    for (i = 0, j = uppers.length; i < j; i++)
        str = str.replace(new RegExp('\\b' + uppers[i] + '\\b', 'g'), uppers[i].toUpperCase());
    return str;
};
String.prototype.toSentenceCase = function() {
    var str;
    var rg = /(^\w{1}|(\.|\?|!)\s+\w{1})/gi;
    str = this.toLowerCase().replace(rg, function(toReplace) {
        return toReplace.toUpperCase();
    });
    return str;
};
Editor.prototype.changeCase = function(event, letter_case) {
    var event = event || window.event;
    var text = '';
    var selection = '';
    event.preventDefault();
    if (this.lastFocus && this.box.selection() != '') {
        var start = this.box.prop("selectionStart");
        var end = this.box.prop("selectionEnd");
        this.lastFocus.focus();
        if ('WebkitAppearance' in document.documentElement.style) {
            switch (letter_case) {
                case 'upper':
                    selection = this.box.selection().toUpperCase();
                    break;
                case 'lower':
                    selection = this.box.selection().toLowerCase();
                    break;
                case 'title':
                    selection = this.box.selection().toTitleCase();
                    break;
                case 'sentence':
                    selection = this.box.selection().toSentenceCase();
                    break;
            }
            document.execCommand("insertHTML", false, selection);
            this.setSelectionRange(this.node_for_box, start, end);
        } else {
            switch (letter_case) {
                case 'upper':
                    this.box.selection('replace', {
                        text: editor.box.selection().toUpperCase()
                    });
                    break;
                case 'lower':
                    this.box.selection('replace', {
                        text: editor.box.selection().toLowerCase()
                    });
                    break;
                case 'title':
                    this.box.selection('replace', {
                        text: editor.box.selection().toTitleCase()
                    });
                    break;
                case 'sentence':
                    this.box.selection('replace', {
                        text: editor.box.selection().toSentenceCase()
                    });
                    break;
            }
        }
        this.lastFocus = null;
    } else {
        this.lastFocus.focus();
        switch (letter_case) {
            case 'upper':
                text = this.box.val().toUpperCase();
                break;
            case 'lower':
                text = this.box.val().toLowerCase();
                break;
            case 'title':
                text = this.box.val().toTitleCase();
                break;
            case 'sentence':
                text = this.box.val().toSentenceCase();
                break;
        }
        if ('WebkitAppearance' in document.documentElement.style) {
            document.execCommand('selectAll', false, null);
            document.execCommand("insertHTML", false, text);
        } else {
            this.box.val(text);
        }
    }
    this.wordCountInternational();
    this.keywordDensity();
    if (window.location.href == abs_path) {
        localStorage.setItem('text', this.box.val());
    }
    return (true);
};
Editor.prototype.disableActionButtons = function(status) {
    if (status)
        $("#undo-btn, #redo-btn, #clear-btn").addClass('disabled');
    else {
        $("#undo-btn, #redo-btn, #clear-btn").removeClass('disabled');
    }
};
Editor.prototype.getQueryParams = function(qs) {
    qs = qs.split("+").join(" ");
    var params = {},
        tokens, re = /[?&]?([^=]+)=([^&]*)/g;
    while (tokens = re.exec(qs)) {
        params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
    }
    return params;
};
String.prototype.toHtmlEntities = function() {
    return this.replace(/./gm, function(s) {
        return "&#" + s.charCodeAt(0) + ";";
    });
};
String.fromHtmlEntities = function(string) {
    return (string + "").replace(/&#\d+;/gm, function(s) {
        return String.fromCharCode(s.match(/\d+/gm)[0]);
    })
};
Editor.prototype.findStringBetween = function(words, text) {
    var pattern = '\\b' + words.join('\\b(.*?)\\b') + '\\b';
    var re = new RegExp(pattern, 'gmi');
    var matches = text.match(re);
    var flag = true;
    if (matches !== null) {
        for (var i = 0; i < matches.length; i++) {
            var sentences = matches[i].match(/[^.!?][^.!?]*(?:[.!?](?!['"]?|$)[^.!?]*)*[.!?]?['"]?(?=|$)/g);
            if (sentences.length > 1) {
                for (var l = 0; l < sentences.length; l++) {
                    var sentence_splited_words = sentences[l].replace(/[,;.!:—\/]/g, ' ').replace(/[^a-zA-Z\d\s&:]/g, '').match(/\S+/g);
                    if (sentence_splited_words.length >= words.length) {
                        this.findStringBetween(words, sentences[l]);
                    }
                }
            } else {
                var splited_words = matches[i].replace(/[,;.!:—\/]/g, ' ').replace(/[^'a-zA-Z\d\s&:]/g, '').match(/\S+/g);
                for (var j = 1; j < splited_words.length - 1; j++) {
                    if (words.indexOf(splited_words[j]) == -1 && words.length > 2) {
                        if (!$.wordStats.stopWords[splited_words[j]]) {
                            this.findStringBetween(words, matches[i].slice(splited_words[0].length));
                            flag = false;
                        }
                    } else if (words.length == 2) {
                        if (!$.wordStats.stopWords[splited_words[j]]) {
                            this.findStringBetween(words, matches[i].slice(splited_words[0].length));
                            flag = false;
                        }
                    }
                }
                if (flag) {
                    var exist = false;
                    for (var k = 0; k < this.highlighted_word_array.length; k++) {
                        if (matches[i] == this.highlighted_word_array[k]) {
                            exist = true;
                        }
                    }
                    if (!exist)
                        this.highlighted_word_array.push(matches[i]);
                }
            }
        }
    }
};
Editor.prototype.highlightWord = function(ev) {
    var event = ev || window.ev;
    var $this = $(ev.target);
    if ($this.is('#kwd-accordion a') || $this.is('#kwd-accordion a span')) {
        if ($('div.btn-group').hasClass('open')) {
            $('div.btn-group').removeClass('open');
        }
        event.preventDefault();
        if ($this.is('#kwd-accordion a span')) {
            $this = $this.parent();
        }
        if (!$this.hasClass('active')) {
            var box_readonly = $('#box-readonly');
            box_readonly.show();
            var text = this.box.val().replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>').replace(/\r/g, '<br>');
            box_readonly.html(text);
            var highlighted_words = $this.find('.word').text();
            var highlighted_words_splited = highlighted_words.split(' ');
            if (highlighted_words_splited.length > 1) {
                this.highlighted_word_array = [];
                this.findStringBetween(highlighted_words_splited, box_readonly.text());
                box_readonly.highlight(this.highlighted_word_array, {
                    wordsOnly: true
                });
            } else {
                box_readonly.highlight(highlighted_words, {
                    wordsOnly: true
                });
            }
            box_readonly.height(this.box.height() + 9);
            $('#form').hide();
            $this.siblings().removeClass('active');
            $this.addClass('active');
            $('#case-btn').addClass('disabled');
            $('#spell-btn').removeClass('active');
            this.disableActionButtons(true);
        } else {
            this.disableActionButtons(false);
            $('#box-readonly').hide();
            $('#form').show();
            $('#kwd-accordion').find('a').removeClass('active');
            $('#case-btn').removeClass('disabled');
        }
    }
};
Editor.prototype.unHighlightWord = function(ev) {
    var event = ev || window.event;
    if (!$(event.target).hasClass('hiddenSpellError') && !$(event.target).hasClass('hiddenGrammarError') && !$(event.target).is('#thesaurus-btn') && !$(event.target).parent().is('#thesaurus-btn')) {
        $('#box-readonly').hide();
        if ($('#spell-btn').hasClass('active')) {
            var text = $('#box-readonly').html();
            var text_arr = text.split('&gt;');
            var text_arr1 = [];
            for (var i = 0; i < text_arr.length; i++) {
                text_arr1 = text_arr[i].split('&lt;');
                for (var j = 0; j < text_arr1.length; j++) {
                    text_arr1[j] = this.replaceDivToEn(text_arr1[j]);
                }
                text_arr[i] = text_arr1.join('<');
            }
            text = text_arr.join('>');
            $('#box').val(text);
        }
        $('#form').show();
        $('#kwd-accordion').find('a').removeClass('active');
        $('#spell-btn').removeClass('active');
        $('#case-btn').removeClass('disabled');
        this.disableActionButtons(false);
        this.box.focus();
    }
};
Editor.prototype.thesaurusEnableOrDisable = function() {
    var selected = this.box.selection();
    if (selected != '' && selected.length >= 2 && selected.length <= 50) {
        $('#thesaurus-btn').removeAttr('disabled');
        this.thesaurus_word = selected.replace(/[,;.!:—\/]/g, ' ').replace(/[^a-zA-Z\d\s&:]/g, '').match(/\S+/g);
    } else {
        $('#thesaurus-btn').attr('disabled', 'disabled');
    }
};
Editor.prototype.thesaurus = function(ev) {
    ev.preventDefault();
    if (this.thesaurus_word == null) {
        $('#thesaurus_synonyms').empty();
        $('#thesaurus_synonyms').append('<span class="thesaurus_error">' + editor.selectedLanguage.no_results + '</span>');
    } else {
        var thesaurus_word_length = this.thesaurus_word.length;
        if (thesaurus_word_length == 0) {
            $('#thesaurus_synonyms').empty();
            $('#thesaurus_synonyms').append('<span class="thesaurus_error">' + editor.selectedLanguage.no_results + '</span>');
        } else {
            var text_words = this.box.val().replace(/[,;.!:—\/]/g, ' ').replace(/[^a-zA-Z\d\s&:]/g, '').match(/\S+/g);
            var word_exists = 0;
            var text_words_len = text_words.length;
            for (var j = 0; j < thesaurus_word_length; j++) {
                for (var i = 0; i < text_words_len; i++) {
                    if (this.thesaurus_word[j] == text_words[i]) {
                        word_exists++;
                        break;
                    }
                }
            }
            if (word_exists == thesaurus_word_length) {
                $('#thesaurus_synonyms').empty();
                $('#thesaurus_synonyms').append('<span class="glyphicon glyphicon-refresh glyphicon-spin"></span>');
                $.ajax({
                    url: 'https://words.bighugelabs.com/api/2/1e43949ba926d62523b855b849f84105/' + this.thesaurus_word.join(' ') + '/json',
                    dataType: "json",
                    error: function(xhr, status, error) {
                        if (status == 'error') {
                            $('#thesaurus_synonyms').empty();
                            $('#thesaurus_synonyms').append('<span class="thesaurus_error">' + editor.selectedLanguage.sorry_couldnt_find_any_synonyms_for_this_word + '</span>');
                        }
                    }
                }).done(function(data) {
                    if (data) {
                        var syn_arr;
                        var count = 0;
                        $('#thesaurus_synonyms').empty();
                        $.each(data, function(key, value) {
                            $('#thesaurus_synonyms').append('<li><a class="uppercase_word" href="#">' + editor.selectedLanguage[key] + '</a></li>');
                            if ('syn' in value) {
                                $.each(value.syn, function(key1, value1) {
                                    $('#thesaurus_synonyms').append('<li><a class="padding_left" href="#" onclick="editor.replaceThesaurusWord(event, this);">' + value1 + '</a></li>');
                                    count++;
                                    if (count == 10)
                                        return false;
                                });
                            } else if ('sim' in value) {
                                $.each(value.sim, function(key1, value1) {
                                    $('#thesaurus_synonyms').append('<li><a class="padding_left" href="#" onclick="editor.replaceThesaurusWord(event, this);">' + value1 + '</a></li>');
                                    count++;
                                    if (count == 10)
                                        return false;
                                });
                            }
                            if (count == 10)
                                return false;
                        });
                    } else {}
                });
            } else {
                $('#thesaurus_synonyms').empty();
                $('#thesaurus_synonyms').append('<span class="thesaurus_error">' + editor.selectedLanguage.no_results + '</span>');
            }
        }
    }
};
Editor.prototype.replaceThesaurusWord = function(ev, obj) {
    ev.preventDefault();
    var selected = this.box.selection();
    var selected_len = selected.length;
    var end_str = '';
    var start_str = '';
    var letterNumber = /^[0-9a-zA-Z]+$/;
    for (var i = selected_len - 1; i >= 0; i--) {
        if (!selected[i].match(letterNumber)) {
            end_str = selected[i] + end_str;
        } else {
            break;
        }
    }
    for (var i = 0; i < selected_len; i++) {
        if (!selected[i].match(letterNumber)) {
            start_str = start_str + selected[i];
        } else {
            break;
        }
    }
    var selected_word = $(obj).text().toString();
    selected_word = start_str + selected_word + end_str;
    if ('WebkitAppearance' in document.documentElement.style) {
        this.box.focus();
        document.execCommand("insertHTML", false, selected_word);
        $('#thesaurus-btn').attr('disabled', 'disabled');
    } else {
        this.box.selection('replace', {
            text: selected_word
        });
    }
};
Editor.prototype.openOptionsTab = function(obj) {
    $("#options-modal .modal-body [aria-controls='" + $(obj).attr('data-tab') + "']").click();
};
Editor.prototype.setTheme = function(theme) {
    $("#theme").attr("href", $('#data-block').data('css-path') + theme + '.css');
    $("#theme_dropdown option[value='" + theme + "']").attr('selected', 'selected');
};
Editor.prototype.setBoxFont = function(font) {
    this.box.css('font-family', font);
    $("#font_dropdown option[value='" + font + "']").attr('selected', 'selected');
};
Editor.prototype.setDateFormat = function(dateFormat) {
    $("#date_format_dropdown option[value='" + dateFormat + "']").attr('selected', 'selected');
    this.showActivities();
};
Editor.prototype.setTimeFormat = function(timeFormat) {
    $("#time_format_dropdown option[value='" + timeFormat + "']").attr('selected', 'selected');
};
Editor.prototype.setLanguageForSpeech = function() {
    for (var i = 0; i < this.langs.length; i++) {
        var option = new Option(this.langs[i][0], i);
        $('#select_language').append(option);
    }
    $('#select_language').val(this.optionsObject.selectLanguage);
    this.updateCountry();
    $('#select_dialect').val(this.optionsObject.selectDialect);
};
Editor.prototype.updateCountry = function() {
    $('#select_dialect').empty();
    var list = this.langs[$('#select_language').val()];
    for (var i = 1; i < list.length; i++) {
        $('#select_dialect').append(new Option(list[i][1], list[i][0]));
    }
    if (list[1].length == 1) {
        $('#select_dialect').css('visibility', 'hidden');
        $('#select_dialect').prev('label').css('visibility', 'hidden');
    } else {
        $('#select_dialect').css('visibility', 'visible');
        $('#select_dialect').prev('label').css('visibility', 'visible');
    }
};
Editor.prototype.speech = function(obj) {
    if ('webkitSpeechRecognition' in window) {
        this.speechRecog.lang = $('#select_dialect').val();
        if (!editor.recording) {
            editor.speechRecog.start();
        } else {
            editor.speechRecog.stop();
        }
        this.speechRecog.onstart = function() {
            $(obj).find("i").css("webkitAnimationName", "record");
            editor.recording = true;
        };
        this.speechRecog.onerror = function(event) {
            if (event.error == 'no-speech') {
                $(".message_output").html('<div id="message_error" class="alert alert-warning"' + ' style="display: none; position: absolute; z-index: 9999; left: 20%; right: 20%;">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>No speech was detected!</strong> You may need to adjust your microphone settings.</div>');
                $("#message_error").fadeIn();
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
            if (event.error == 'audio-capture') {
                $(".message_output").html('<div id="message_error" class="alert alert-warning">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Microphone is not turned on!</strong> You need to turn on your microphone.</div>');
                $("#message_error").fadeIn();
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
            if (event.error == 'not-allowed') {
                $(".message_output").html('<div id="message_error" class="alert alert-warning">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>Permission to use microphone is blocked.</strong> To change, go to chrome://settings/contentExceptions#media-stream</div>');
                $("#message_error").fadeIn();
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
        };
        this.speechRecog.onend = function() {
            editor.recording = false;
            $(obj).find("i").css("webkitAnimationName", "");
        };
        this.speechRecog.onresult = function(event) {
            if (typeof(event.results) == 'undefined') {
                editor.speechRecog.onend = null;
                editor.speechRecog.stop();
                return;
            }
            var i = 0;
            for (i = event.resultIndex; i < event.results.length; i += 1) {
                if (!event.results[i].isFinal) {
                    $(".interimResult").text(event.results[i][0].transcript);
                } else {
                    editor.box.focus();
                    document.execCommand("insertHTML", false, event.results[i][0].transcript);
                    editor.wordCountInternational();
                    editor.keywordDensity();
                }
            }
        }
    } else {
        alert("Speech Recognition Not Supported");
    }
};
Editor.prototype.speechUtteranceChunker = function(utt, settings, callback) {
    var $that = this;
    settings = settings || {};
    var newUtt;
    var txt = (settings && settings.offset !== undefined ? utt.text.substring(settings.offset) : utt.text);
    if (utt.voice && utt.voice.voiceURI === 'native') {
        newUtt = utt;
        newUtt.text = txt;
        newUtt.addEventListener('end', function() {
            if ($that.speechUtteranceChunker.cancel) {
                $that.speechUtteranceChunker.cancel = false;
            }
            if (callback !== undefined) {
                callback();
            }
        });
    } else {
        if (txt != '') {
            var chunkArr = txt.match(/[^.!?][^.!?]*(?:[.!?](?!['"]?|$)[^.!?]*)*[.!?]?['"]?(?=|$)/g);
            if (chunkArr[0].length >= 250) {
                var chunkLength = (settings && settings.chunkLength) || 160;
                var pattRegex = new RegExp('^[\\s\\S]{' + Math.floor(chunkLength / 2) + ',' + chunkLength + '}[.!?,]{1}|^[\\s\\S]{1,' + chunkLength + '}$|^[\\s\\S]{1,' + chunkLength + '} ');
                chunkArr[0] = txt.match(pattRegex)[0];
            }
            if (chunkArr[0].length <= 1) {
                if (callback !== undefined) {
                    callback();
                }
                return
            }
            var chunk = chunkArr[0];
            newUtt = new SpeechSynthesisUtterance(chunk);
            var x;
            for (x in utt) {
                if (utt.hasOwnProperty(x) && x !== 'text') {
                    newUtt[x] = utt[x];
                }
            }
            newUtt.addEventListener('end', function() {
                if ($that.speechUtteranceChunker.cancel) {
                    $that.speechUtteranceChunker.cancel = false;
                    return;
                }
                settings.offset = settings.offset || 0;
                settings.offset += chunk.length;
                $that.speechUtteranceChunker(utt, settings, callback);
            });
        } else {
            if (callback !== undefined) {
                callback();
            }
            return
        }
    }
    if (settings.modifier) {
        settings.modifier(newUtt);
    }
    console.log(newUtt);
    setTimeout(function() {
        newUtt.volume = 1;
        newUtt.rate = $('#read_rate').val();
        newUtt.pitch = $('#read_pitch').val();
        newUtt.voice = $that.voices[$('#read_voices').val()];
        speechSynthesis.speak(newUtt);
    }, 10);
};
Editor.prototype.toggleReadControls = function(event, obj) {
    $('#text-to-speech-controls').show();
};
Editor.prototype.startReading = function(event, obj) {
    this.box.focus();
    this.wordCountInternational();
    this.keywordDensity();
    event.preventDefault();
    if ('speechSynthesis' in window) {
        $('#r-play-link').hide();
        $('#r-pause-link').show();
        if (this.paused == true) {
            window.speechSynthesis.resume();
            console.log('resume');
        } else {
            console.log('play');
            var myLongText;
            var selection = this.box.selection();
            if (selection != '') {
                myLongText = selection;
            } else {
                var cursor_pos = this.getCursorPositionInTextarea(this.node_for_box);
                myLongText = this.box.val();
                myLongText = myLongText.substring(cursor_pos, this.box.val().length);
                if (myLongText == '') {
                    myLongText = this.box.val();
                }
            }
            var utterance = new SpeechSynthesisUtterance();
            utterance.text = myLongText;
            utterance.voice = this.voices[$('#read_voices').val()];
            $(obj).next('i.fa').show();
            this.speechUtteranceChunker(utterance, {
                chunkLength: 250
            }, function() {
                $('#r-play-link').show();
                $('#r-pause-link').hide();
                window.speechSynthesis.cancel();
            });
        }
        this.paused = false;
    } else {
        alert("Sorry, your browser doesn't support Text to Speech. Use Chrome to use this feature.");
    }
};
Editor.prototype.stopReading = function(event, obj) {
    this.box.focus();
    this.wordCountInternational();
    this.keywordDensity();
    event.preventDefault();
    $('#r-play-link').show();
    $('#r-pause-link').hide();
    window.speechSynthesis.cancel();
    this.speechUtteranceChunker.cancel = true;
    this.paused = false;
    console.log('stop');
};
Editor.prototype.pauseReading = function(event, obj) {
    this.box.focus();
    this.wordCountInternational();
    this.keywordDensity();
    event.preventDefault();
    $('#r-play-link').show();
    $('#r-pause-link').hide();
    window.speechSynthesis.pause();
    this.paused = true;
    console.log('pause');
};
Editor.prototype.checkGrammarSpelling = function(ev, obj) {
    var event = ev || window.ev;
    event.preventDefault();
    var box_readonly = $('#box-readonly');
    if (!$(obj).hasClass('active')) {
        var text = this.box.val().replace(/\n/g, '<br>').replace(/\r/g, '<br>');
        box_readonly.html(text);
        $('#kwd-accordion a').siblings().removeClass('active');
        $(obj).addClass('active');
        AtD.rpc = $('#data-block').data('spell-check-url');
        AtD.check('box-readonly', {
            success: function(errorCount) {
                if (errorCount == 0) {
                    alert("No writing errors were found");
                }
            },
            error: function(reason) {
                alert('Sorry, service unavailable, try again in a moment.');
            },
            ready: function(count) {
                box_readonly.show();
                box_readonly.height(editor.box.height() + 14);
                box_readonly.css('max-height', editor.box.height() + 14);
                $('#form').hide();
                editor.recursive(box_readonly);
            }
        });
        $('#case-btn').addClass('disabled');
        this.disableActionButtons(true);
    } else {
        this.disableActionButtons(false);
        box_readonly.hide();
        var text = $('#box-readonly').html().replace(/<br>/g, '\n');
        var text_arr = text.split('&gt;');
        var text_arr1 = [];
        for (var i = 0; i < text_arr.length; i++) {
            text_arr1 = text_arr[i].split('&lt;');
            for (var j = 0; j < text_arr1.length; j++) {
                text_arr1[j] = this.replaceDivToEn(text_arr1[j]);
            }
            text_arr[i] = text_arr1.join('<');
        }
        text = text_arr.join('>');
        $('#box').val(text);
        $('#form').show();
        $(obj).removeClass('active');
        $('#case-btn').removeClass('disabled');
    }
};
Editor.prototype.recursive = function(box_readonly) {
    box_readonly.children().not('span.mceItemHidden, br').each(function(index, item) {
        var regexp1 = /</g;
        var regexp2 = />/g;
        var html = item.outerHTML;
        var match, matches = [];
        while ((match = regexp1.exec(html)) != null) {
            matches.push(match.index);
        }
        html = [html.slice(0, matches[0]), '&lt;', html.slice(matches[0] + 1)].join('');
        matches = [];
        while ((match = regexp1.exec(html)) != null) {
            matches.push(match.index);
        }
        html = [html.slice(0, matches[matches.length - 1]), '&lt;', html.slice(matches[matches.length - 1] + 1)].join('');
        matches = [];
        while ((match = regexp2.exec(html)) != null) {
            matches.push(match.index);
        }
        html = [html.slice(0, matches[0]), '&gt;', html.slice(matches[0] + 1)].join('');
        matches = [];
        while ((match = regexp2.exec(html)) != null) {
            matches.push(match.index);
        }
        html = [html.slice(0, matches[matches.length - 1]), '&gt;', html.slice(matches[matches.length - 1] + 1)].join('');
        item.outerHTML = html;
        if ($(item).children().not('span.mceItemHidden')[0]) {
            editor.recursive($('#box-readonly'));
        }
    });
};
Editor.prototype.sendRevision = function(ev, obj) {
    ev.preventDefault();
    var $that = this;
    jQuery.ajax({
        type: "POST",
        url: "site/get-revision",
        data: {
            revision_id: $(obj).data('revision-id')
        }
    }).done(function(msg) {
        msg = msg.replace(/\n/g, '').replace(/<br>/g, '\n');
        msg = msg.replace(/&nbsp;/g, ' ');
        if ('WebkitAppearance' in document.documentElement.style) {
            msg = msg.replace(/</g, '&lt;');
            msg = msg.replace(/>/g, '&gt;');
            editor.box.focus();
            document.execCommand('selectAll', false, null);
            document.execCommand("insertHTML", false, msg);
        } else {
            editor.box.val(msg);
        }
        $that.keywordDensity();
        $that.wordCountInternational();
        $that.setCaretToPos($that.node_for_box, 0);
        if (window.location.href == abs_path) {
            localStorage.setItem('text', $that.box.html());
        }
    });
};
Editor.prototype.readTimer = function() {
    var written_words, press = 'no_press';
    $.extend({
        APP: {
            formatTimer: function(a) {
                if (a < 10) {
                    a = '0' + a;
                }
                return a;
            },
            startTimer: function(dir) {
                if (press == 'reset' || press == 'no_press')
                    written_words = parseInt($('#word_count').html());
                var a;
                $.APP.dir = dir;
                $.APP.d1 = new Date();
                switch ($.APP.state) {
                    case 'pause':
                        $.APP.t1 = $.APP.d1.getTime() - $.APP.td;
                        break;
                    default:
                        $.APP.t1 = $.APP.d1.getTime();
                        if ($.APP.dir === 'cd') {
                            $.APP.t1 += parseInt($('#cd_seconds').val()) * 1000;
                        }
                        break;
                }
                $.APP.state = 'alive';
                $('#' + $.APP.dir + '_status').html('Running');
                $.APP.loopTimer();
            },
            pauseTimer: function() {
                press = 'pause';
                $.APP.dp = new Date();
                $.APP.tp = $.APP.dp.getTime();
                $.APP.td = $.APP.tp - $.APP.t1;
                $.APP.state = 'pause';
            },
            stopTimer: function() {
                $.APP.state = 'stop';
            },
            resetTimer: function() {
                press = 'reset';
                $('#' + $.APP.dir + '_ms,#' + $.APP.dir + '_s,#' + $.APP.dir + '_m,#' + $.APP.dir + '_h').html('00');
                $('#' + $.APP.dir + '_ms1,#' + $.APP.dir + '_s1,#' + $.APP.dir + '_m1,#' + $.APP.dir + '_h1').html('00');
                $.APP.state = 'reset';
            },
            endTimer: function(callback) {
                $.APP.state = 'end';
                if (typeof callback === 'function') {
                    callback();
                }
            },
            loopTimer: function() {
                var td;
                var d2, t2;
                var ms = 0;
                var s = 0;
                var m = 0;
                var h = 0;
                var just_written_words;
                if ($.APP.state === 'alive') {
                    d2 = new Date();
                    t2 = d2.getTime();
                    if ($.APP.dir === 'sw') {
                        td = t2 - $.APP.t1;
                    } else {
                        td = $.APP.t1 - t2;
                        if (td <= 0) {
                            $.APP.endTimer(function() {
                                $.APP.resetTimer();
                            });
                        }
                    }
                    ms = td % 1000;
                    if (ms < 1) {
                        ms = 0;
                    } else {
                        just_written_words = parseInt($('#word_count').html()) - written_words;
                        if (just_written_words < 0) {
                            just_written_words = 0;
                            written_words--;
                        }
                        $('#wpm, #wpm1').html((just_written_words / (td / 1000 / 60)).toFixed(0));
                        s = (td - ms) / 1000;
                        if (s < 1) {
                            s = 0;
                        } else {
                            var m = (s - (s % 60)) / 60;
                            if (m < 1) {
                                m = 0;
                            } else {
                                var h = (m - (m % 60)) / 60;
                                if (h < 1) {
                                    h = 0;
                                }
                            }
                        }
                    }
                    ms = Math.round(ms / 100);
                    s = s - (m * 60);
                    m = m - (h * 60);
                    $('#' + $.APP.dir + '_ms, #' + $.APP.dir + '_ms1').html($.APP.formatTimer(ms));
                    $('#' + $.APP.dir + '_s, #' + $.APP.dir + '_s1').html($.APP.formatTimer(s));
                    $('#' + $.APP.dir + '_m, #' + $.APP.dir + '_m1').html($.APP.formatTimer(m));
                    $('#' + $.APP.dir + '_h, #' + $.APP.dir + '_h1').html($.APP.formatTimer(h));
                    $.APP.t = setTimeout($.APP.loopTimer, 100);
                } else {
                    clearTimeout($.APP.t);
                    return true;
                }
            }
        }
    });
};
Editor.prototype.startTimer = function(e) {
    e.preventDefault();
    this.box.focus();
    $.APP.startTimer('sw');
    $('#sw-pause-link').show();
    $('#sw-start-link').hide();
};
Editor.prototype.pauseTimer = function(e) {
    e.preventDefault();
    this.box.focus();
    $.APP.pauseTimer();
    $('#sw-pause-link').hide();
    $('#sw-start-link').show();
};
Editor.prototype.resetTimer = function(e) {
    if (e !== undefined)
        e.preventDefault();
    this.box.focus();
    $('#wpm, #wpm1').html('0');
    $.APP.resetTimer();
    $('#sw-pause-link').hide();
    $('#sw-start-link').show();
};
Editor.prototype.setGoalForEditor = function(arr) {
    if (arr) {
        var dataObject = {
            'goal_count': arr[0],
            'goal_type': arr[1],
            'goal_length_type': arr[2]
        };
        $.ajax({
            type: "POST",
            url: "site/set-goal",
            data: dataObject,
            success: function(data) {
                if (data.success) {
                    goal.set(arr);
                }
            }
        });
    } else {
        goal.set();
    }
};
Editor.prototype.createGoal = function() {
    var goal_name = $('#goalType').val();
    var goal_count = $('#goalQty').val();
    var written_count;
    if (goal_name === 'reading_time' || goal_name === 'speaking_time') {
        if (this.count[goal_name].indexOf('sec') > -1) {
            written_count = Math.round((this.count[goal_name].replace('sec', '').trim() / 60) * 100) / 100;
        } else if (this.count[goal_name].indexOf('mins') > -1) {
            written_count = this.count[goal_name].replace('mins', '').trim();
        } else if (this.count[goal_name].indexOf('hrs') > -1) {
            written_count = this.count[goal_name].replace('hrs', '').trim() * 60;
        }
    } else {
        written_count = this.count[goal_name];
    }
    var goal_type = $('#goalType option[value="' + goal_name + '"]').data('value');
    var goal_length_type = $('#goalLengthType').val();
    var dataObject = {
        'goal_type': goal_type,
        'goal_count': goal_count,
        'written_count': written_count,
        'goal_length_type': goal_length_type
    };
    $.ajax({
        type: "POST",
        url: "site/create-goal",
        data: dataObject,
        asinc: false,
        success: function(data) {
            if (data.success) {
                $(".errorMsgBox").html('<div id="message_error" class="alert alert-success fade in">' +
                    '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">&times;</a>' +
                    '<strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_goal_was_created_successfully +
                    '</div>');
                editor.getUserGoals(user_id_for_goal);
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
                editor.setGoalForEditor();
                goal.setDefaultValues();
            } else {
                $(".errorMsgBox").html('<div  class="alert alert-warning" id="message_error">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.type] + '</div>');
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
        }
    });
};
Editor.prototype.getUserGoals = function(user_id) {
    $.ajax({
        type: "GET",
        url: "site/get-user-goals",
        success: function(data) {
            $('#existing_goals').empty();
            var goal_count_with_commas;
            if (data.success == true) {
                if (data.user_goals) {
                    data.user_goals.forEach(function(goal, index) {
                        goal_count_with_commas = editor.commaSeparateNumber([goal.goal_count]);
                        $('#existing_goals').append('<div class="col-xs-12 user_goal goals_for_logged_in_user" id="goal_' + goal.id + '">' + '<div class="col-xs-1" style="padding: 5px 10px 0 10px">' + (index + 1) + '. ' + '</div>' + '<div class="col-xs-6 col-sm-5 goal_caption" style="padding: 5px 0 0 0">' + goal_count_with_commas + ' ' + editor.selectedLanguage[goal.goal_type] + ' (' + editor.selectedLanguage[goal.goal_length_type] + ')' + '</div>' + '<div class="col-xs-5 col-sm-6" style="padding: 0">' + '<button type="button" class="btn btn-danger btn-xs" style="float:right;margin-right:10px;" onclick="editor.deleteGoal(' + goal.id + ')">' + editor.selectedLanguage.delete + '</button>' + '<button type="button" class="btn btn-info btn-xs" style="float:right; margin-right:4%;" onclick="editor.slideToggleGoal(' + goal.id + ', [\'' + goal.goal_count + '\', \'' + goal.goal_type + '\', \'' + goal.goal_length_type + '\'])">' + editor.selectedLanguage.edit + '</button>' + '<button type="button" class="btn btn-primary btn-xs" style="float:right; margin-right:4%;" onclick="editor.setGoalForEditor([\'' + goal.goal_count + '\', \'' + goal.goal_type + '\', \'' + goal.goal_length_type + '\']);">' + editor.selectedLanguage.set + '</button>' + '</div>' + '</div>' + '<div class="col-xs-12" style="margin: 10px 0; display: none;" id="slide_toggle_' + goal.id + '">' + '<div class="col-sm-4 col-xs-3 pl0 pr0">' + '<input type="number" class="form-control goalQty" placeholder="' + editor.selectedLanguage.quantity + '" id="goalQty_' + goal.id + '" type="number" min="0" max="100000" onkeydown="editor.setGoalQuantity(event, this);">' + '</div>' + '<div class="col-sm-4 col-xs-3 pl0 pr0 select_after">' + '<select class="form-control goalType" id="goalType_' + goal.id + '" onchange="editor.setQuantityPlaceholder(this);">' + '<option value="Words">' + editor.selectedLanguage.words_label + '</option>' + '<option value="Characters">' + editor.selectedLanguage.characters_label + '</option>' + '<option value="Sentences">' + editor.selectedLanguage.sentences + '</option>' + '<option value="Paragraphs">' + editor.selectedLanguage.paragraphs + '</option>' + '<option value="Pages">' + editor.selectedLanguage.pages + '</option>' + '<option value="Reading Time">' + editor.selectedLanguage.reading_time + '</option>' + '<option value="Speaking Time">' + editor.selectedLanguage.speaking_time + '</option>' + '<option value="Publisher Words">' + editor.selectedLanguage.publisher_words + '</option>' + '</select>' + '</div>' + '<div class="col-sm-3 col-xs-3 pl0 pr0 select_after">' + '<select class="form-control goalLengthType" id="goalLengthType_' + goal.id + '">' + '<option value="min">' + editor.selectedLanguage.minimum + '</option>' + '<option value="max">' + editor.selectedLanguage.maximum + '</option>' + '</select>' + '</div>' + '<div class="col-sm-1 col-xs-3 pl0 pr0">' + '<button type="button" class="btn btn-info edit_goal_button" onclick="editor.editGoal(' + goal.id + ');">' + editor.selectedLanguage.save_modal_btn + '</button>' + '</div>' + '</div>');
                    });
                }
            } else if (data.success == 'empty') {
                $('#existing_goals').append('<div class="col-md-12 user_goal" id="" style="text-align: center;">' +
                    editor.selectedLanguage.above_you_can_create_your_first_goal + '</div>');
            }
        }
    });
};
Editor.prototype.slideToggleGoal = function(goal_id, goal_arr) {
    $('#goalQty_' + goal_id).val(goal_arr[0]);
    $('#goalType_' + goal_id + ' option').removeAttr('selected');
    $('#goalType_' + goal_id + ' option[value="' + goal_arr[1] + '"]').attr('selected', 'selected');
    $('#goalLengthType_' + goal_id + ' option').removeAttr('selected');
    $('#goalLengthType_' + goal_id + ' option[value="' + goal_arr[2] + '"]').attr('selected', 'selected');
    if (goal_arr[1] === 'Reading Time' || goal_arr[1] === 'Speaking Time') {
        $('#goalQty_' + goal_id).attr('placeholder', 'Quantity (in minutes)');
    }
    $('#slide_toggle_' + goal_id).slideToggle();
};
Editor.prototype.setQuantityPlaceholder = function(obj) {
    var selected = $(obj).val();
    if (selected === 'reading_time' || selected === 'speaking_time' || selected === 'Reading Time' || selected === 'Speaking Time') {
        $(obj).parent('div').prev('div').find('input').attr('placeholder', editor.selectedLanguage.quantity_in_minutes);
    } else {
        $(obj).parent('div').prev('div').find('input').attr('placeholder', editor.selectedLanguage.quantity);
    }
};
Editor.prototype.editGoal = function(goal_id) {
    var goal_count = $('#goalQty_' + goal_id).val();
    var goal_type = $('#goalType_' + goal_id).val();
    var goal_length_type = $('#goalLengthType_' + goal_id).val();
    var dataObject = {
        'id': goal_id,
        'goal_count': goal_count,
        'goal_type': goal_type,
        'goal_length_type': goal_length_type
    };
    $.ajax({
        type: "POST",
        url: "site/edit-goal",
        data: dataObject,
        success: function(data) {
            if (data.success) {
                $('#goal_' + goal_id + ' .goal_caption').text(goal_count + ' ' + goal_type + ' (' + goal_length_type + ')');
                $('#goal_' + goal_id + ' .btn-info').attr("onclick", 'editor.slideToggleGoal(' + goal_id + ', [\'' + goal_count + '\', \'' + goal_type + '\', \'' + goal_length_type + '\'])');
                $('#goal_' + goal_id + ' .btn-primary').attr("onclick", 'editor.setGoalForEditor([\'' + goal_count + '\', \'' + goal_type + '\', \'' + goal_length_type + '\'])');
                if (data.is_goal_set) {
                    goal.set([goal_count, goal_type, goal_length_type]);
                }
                $('#slide_toggle_' + goal_id).slideToggle();
                $(".errorMsgBox").html('<div id="message_error" class="alert alert-success fade in">' +
                    '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">&times;</a>' +
                    '<strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_goal_was_saved_successfully +
                    '</div>');
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            } else {
                $(".errorMsgBox").html('<div  class="alert alert-warning" id="message_error">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.type] + '</div>');
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
        }
    });
};
Editor.prototype.deleteGoal = function(id) {
    var dataObject = {
        'id': id
    };
    $.ajax({
        type: "POST",
        url: "site/delete-goal",
        data: dataObject,
        success: function(data) {
            if (data.success) {
                $('#goal_' + id).fadeOut(500);
                if (data.response) {
                    editor.disableGoalForEditor();
                }
                setTimeout(function() {
                    $('#goal_' + id).remove();
                    $('#slide_toggle_' + id).remove();
                    $('.goals_for_logged_in_user').each(function(key, value) {
                        $(value).find('div:first-child').text(key + 1);
                    });
                    if ($('#existing_goals').children().length == 0) {
                        $('#existing_goals').append('<div class="col-md-12 user_goal" id="" style="text-align: center;">' +
                            editor.selectedLanguage.above_you_can_create_your_first_goal + '</div>');
                    }
                }, 450);
                $(".errorMsgBox").html('<div id="message_error" class="alert alert-success fade in">' +
                    '<a href="#" class="close" data-dismiss="alert" aria-label="close" title="close">&times;</a>' +
                    '<strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.your_goal_was_deleted_successfully +
                    '</div>');
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            } else {
                $(".errorMsgBox").html('<div  class="alert alert-warning" id="message_error">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + '<strong>' + editor.selectedLanguage.warning + ' </strong>' + editor.selectedLanguage[data.message] + '</div>');
                setTimeout(function() {
                    $("#message_error").fadeOut();
                }, 6000);
            }
        }
    });
};
Editor.prototype.setGoalQuantity = function(e, obj) {
    goal.allowedChars(e, $(obj));
};
Editor.prototype.disableGoalForEditor = function(arr) {
    goal.disableGoal(arr);
};
Editor.prototype.addSimpleWords = function() {
    $.ajax({
        type: "GET",
        url: "site/add-simple-words",
        success: function(data) {
            if (data.success) {
                for (var i = 0; i < data.simple_words.length; i++) {
                    editor.simple_words[data.simple_words[i].simple_words] = 1;
                }
            }
        }
    });
};
Editor.prototype.findAndReplace = function() {
    editor.searchedString = $('#searched_text').val();
    editor.replacementString = $('#replacement_text').val();
    var text = editor.box.val();
    var re = new RegExp(editor.searchedString, "gi");
    var message_box = $('.message_for_find_and_replace');
    if (!editor.searchedString || !editor.replacementString) {
        message_box.html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.please_fill_both_fields + '</div>');
        message_box.slideDown();
        setTimeout(function() {
            message_box.slideUp();
        }, 6000);
    } else if (!text) {
        message_box.html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.text_is_empty_cant_start_searching_process + '</div>');
        message_box.slideDown();
        setTimeout(function() {
            message_box.slideUp();
        }, 6000);
    } else {
        var searched_string_pos = text.search(re);
        if (searched_string_pos == -1) {
            message_box.html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.coincidence_text_1 + ' \"' + editor.searchedString + '\" ' + editor.selectedLanguage.coincidence_text_2 + '</div>');
            message_box.slideDown();
            setTimeout(function() {
                message_box.slideUp();
            }, 6000);
        } else {
            editor.wholeWords = $('#whole_words').prop('checked');
            $('#find-and-replace-modal').modal('hide');
            editor.firstText = '';
            editor.secondText = text;
            if ($('#replace_all').prop('checked')) {
                editor.findAndReplaceAll();
            } else {
                editor.findAndReplaceOneAndOne();
            }
        }
    }
};
Editor.prototype.findAndReplaceOneAndOne = function() {
    var re, secondPos;
    if (editor.wholeWords) {
        re = new RegExp("\\W(" + editor.searchedString + ")\\W", "gi");
        secondPos = editor.secondText.search(re);
        editor.replacementPos = editor.firstText.length + secondPos + 1;
    } else {
        re = new RegExp(editor.searchedString, "gi");
        secondPos = editor.secondText.search(re);
        editor.replacementPos = editor.firstText.length + secondPos;
    }
    if (secondPos != -1) {
        editor.setCaretToPos(editor.node_for_box, editor.replacementPos);
        setTimeout(function() {
            $('#replace_container').find('p').text(editor.selectedLanguage.are_you_sure_you_want_to_replace + ' "' + editor.searchedString + '"' + editor.selectedLanguage.replace_with + '"' + editor.replacementString + '"' + editor.selectedLanguage.replace_at + '"' + editor.replacementPos + '"' + editor.selectedLanguage.replace_position);
            $('#replace_container').show();
            editor.box.blur();
            editor.box.trigger('keypress');
            editor.setSelectionRange(editor.node_for_box, editor.replacementPos, editor.replacementPos + editor.searchedString.length);
        }, 400);
    }
};
Editor.prototype.replaceOneByOne = function() {
    var secondPos = editor.replacementPos - editor.firstText.length;
    editor.setSelectionRange(editor.node_for_box, editor.replacementPos, editor.replacementPos + editor.searchedString.length);
    if ('WebkitAppearance' in document.documentElement.style) {
        document.execCommand("insertHTML", false, editor.replacementString);
    } else {
        editor.box.selection('replace', {
            text: editor.replacementString
        });
    }
    editor.firstText = editor.firstText + editor.secondText.slice(0, secondPos) + editor.replacementString;
    editor.secondText = editor.secondText.slice(secondPos + editor.searchedString.length);
    editor.findAndReplaceOneAndOne();
    $('#replace_container').hide();
};
Editor.prototype.cancelOne = function() {
    var secondPos = editor.replacementPos - editor.firstText.length;
    editor.firstText = editor.firstText + editor.secondText.slice(0, secondPos + editor.searchedString.length);
    editor.secondText = editor.secondText.slice(secondPos + editor.searchedString.length);
    editor.findAndReplaceOneAndOne();
    $('#replace_container').hide();
};
Editor.prototype.cancelAll = function() {
    this.searchedString = '';
    this.replacementString = '';
    this.replacementPos = 0;
    this.firstText = '';
    this.secondText = '';
    this.wholeWords = '';
    $('#replace_container').hide();
};
Editor.prototype.findAndReplaceAll = function() {
    var re, secondPos;
    if (editor.wholeWords) {
        re = new RegExp("\\W(" + editor.searchedString + ")\\W", "gi");
        secondPos = editor.secondText.search(re);
        editor.replacementPos = editor.firstText.length + secondPos + 1;
    } else {
        re = new RegExp(editor.searchedString, "gi");
        secondPos = editor.secondText.search(re);
        editor.replacementPos = editor.firstText.length + secondPos;
    }
    if (secondPos != -1) {
        editor.setSelectionRange(editor.node_for_box, editor.replacementPos, editor.replacementPos + editor.searchedString.length);
        if ('WebkitAppearance' in document.documentElement.style) {
            document.execCommand("insertHTML", false, editor.replacementString);
        } else {
            editor.box.selection('replace', {
                text: editor.replacementString
            });
        }
        editor.firstText = editor.firstText + editor.secondText.slice(0, secondPos) + editor.replacementString;
        editor.secondText = editor.secondText.slice(secondPos + editor.searchedString.length);
        editor.findAndReplaceAll();
    }
};
var BindSubmit = function() {
    $('._btncheck').unbind('click').bind('click', function() {
        var params = ((typeof apiParams != 'undefined') && (apiParams != null)) ? apiParams : {};
        params['text'] = $('.finalResult').val();
        if (params.text.length < 40) {
            alert('Please enter more text to start the check');
            return false;
        }
        var target = null;
        if (($(this).attr('target') == '_blank') || ($(this).attr('data-target') == '_blank')) {
            var protocol = location.protocol;
            var slashes = protocol.concat("//");
            var host = slashes.concat(window.location.hostname);
            target = window.open(slashes.concat(window.location.hostname) + '/hold-on.html', '');
        }
        jQuery.ajax({
            url: 'https://irbis.grammarly.com/api/funnels/embedded/check',
            data: params,
            context: {
                target: target
            },
            type: 'POST',
            success: function(response) {
                if (this.target != null) target.location = response.reportUrl;
                else window.location = response.reportUrl;
            },
            error: function(e) {
                console.error(e)
            }
        });
    });
};
var editor = new Editor();
editor.init();
var IsGrammarlyEnabled = function() {
    return (($('grammarly-ghost').length > 0) || ($('.gr-top-z-index').length > 0) || ($('grammarly-extension').length > 0));
};
var HideGrammarlyOFFIndicator = function() {
    if (IsGrammarlyEnabled()) {
        $('#grammarlyOFF').hide();
        $('#grammarlyON').show();
        $('#glya').hide();
        $('#glyb').show();
    } else {
        $('#grammarlyON').hide();
        $('#grammarlyOFF').show();
        $('#glyb').hide();
        $('#glya').show();
    }
};
$(document).ready(function() {
    if ($('img.lazy').length) {
        var lazyLoadInstance = new LazyLoad({
            elements_selector: ".lazy",
            threshold: 0
        });
    }
    if (window.location.hash == '#signin') {
        $($('a[data-target="#social-login-modal"]').get(0)).click();
    }
    setTimeout(HideGrammarlyOFFIndicator, 500);
    setTimeout(HideGrammarlyOFFIndicator, 1000);
    setTimeout(HideGrammarlyOFFIndicator, 5000);
});;
(function(window, document, exports, global, define, undefined) {
    /*!
     * @overview es6-promise - a tiny implementation of Promises/A+.
     * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
     * @license Licensed under MIT license
     * See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
     * @version 2.0.1
     */
    (function() {
        function r(a, b) {
            n[l] = a;
            n[l + 1] = b;
            l += 2;
            2 === l && A()
        }

        function s(a) {
            return "function" === typeof a
        }

        function F() {
            return function() {
                process.nextTick(t)
            }
        }

        function G() {
            var a = 0,
                b = new B(t),
                c = document.createTextNode("");
            b.observe(c, {
                characterData: !0
            });
            return function() {
                c.data = a = ++a % 2
            }
        }

        function H() {
            var a = new MessageChannel;
            a.port1.onmessage = t;
            return function() {
                a.port2.postMessage(0)
            }
        }

        function I() {
            return function() {
                setTimeout(t, 1)
            }
        }

        function t() {
            for (var a = 0; a < l; a += 2)(0, n[a])(n[a + 1]), n[a] = void 0, n[a + 1] = void 0;
            l = 0
        }

        function p() {}

        function J(a, b, c, d) {
            try {
                a.call(b, c, d)
            } catch (e) {
                return e
            }
        }

        function K(a, b, c) {
            r(function(a) {
                var e = !1,
                    f = J(c, b, function(c) {
                        e || (e = !0, b !== c ? q(a, c) : m(a, c))
                    }, function(b) {
                        e || (e = !0, g(a, b))
                    });
                !e && f && (e = !0, g(a, f))
            }, a)
        }

        function L(a, b) {
            1 === b.a ? m(a, b.b) : 2 === a.a ? g(a, b.b) : u(b, void 0, function(b) {
                q(a, b)
            }, function(b) {
                g(a, b)
            })
        }

        function q(a, b) {
            if (a === b) g(a, new TypeError("You cannot resolve a promise with itself"));
            else if ("function" === typeof b || "object" === typeof b && null !== b)
                if (b.constructor === a.constructor) L(a, b);
                else {
                    var c;
                    try {
                        c = b.then
                    } catch (d) {
                        v.error = d, c = v
                    }
                    c === v ? g(a, v.error) : void 0 === c ? m(a, b) : s(c) ? K(a, b, c) : m(a, b)
                }
            else m(a, b)
        }

        function M(a) {
            a.f && a.f(a.b);
            x(a)
        }

        function m(a, b) {
            void 0 === a.a && (a.b = b, a.a = 1, 0 !== a.e.length && r(x, a))
        }

        function g(a, b) {
            void 0 === a.a && (a.a = 2, a.b = b, r(M, a))
        }

        function u(a, b, c, d) {
            var e = a.e,
                f = e.length;
            a.f = null;
            e[f] = b;
            e[f + 1] = c;
            e[f + 2] = d;
            0 === f && a.a && r(x, a)
        }

        function x(a) {
            var b = a.e,
                c = a.a;
            if (0 !== b.length) {
                for (var d, e, f = a.b, g = 0; g < b.length; g += 3) d = b[g], e = b[g + c], d ? C(c, d, e, f) : e(f);
                a.e.length = 0
            }
        }

        function D() {
            this.error = null
        }

        function C(a, b, c, d) {
            var e = s(c),
                f, k, h, l;
            if (e) {
                try {
                    f = c(d)
                } catch (n) {
                    y.error = n, f = y
                }
                f === y ? (l = !0, k = f.error, f = null) : h = !0;
                if (b === f) {
                    g(b, new TypeError("A promises callback cannot return that same promise."));
                    return
                }
            } else f = d, h = !0;
            void 0 === b.a && (e && h ? q(b, f) : l ? g(b, k) : 1 === a ? m(b, f) : 2 === a && g(b, f))
        }

        function N(a, b) {
            try {
                b(function(b) {
                    q(a, b)
                }, function(b) {
                    g(a, b)
                })
            } catch (c) {
                g(a, c)
            }
        }

        function k(a, b, c, d) {
            this.n = a;
            this.c = new a(p, d);
            this.i = c;
            this.o(b) ? (this.m = b, this.d = this.length = b.length, this.l(), 0 === this.length ? m(this.c, this.b) : (this.length = this.length || 0, this.k(), 0 === this.d && m(this.c, this.b))) : g(this.c, this.p())
        }

        function h(a) {
            O++;
            this.b = this.a = void 0;
            this.e = [];
            if (p !== a) {
                if (!s(a)) throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                if (!(this instanceof h)) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                N(this, a)
            }
        }
        var E = Array.isArray ? Array.isArray : function(a) {
                return "[object Array]" === Object.prototype.toString.call(a)
            },
            l = 0,
            w = "undefined" !== typeof window ? window : {},
            B = w.MutationObserver || w.WebKitMutationObserver,
            w = "undefined" !== typeof Uint8ClampedArray && "undefined" !== typeof importScripts && "undefined" !== typeof MessageChannel,
            n = Array(1E3),
            A;
        A = "undefined" !== typeof process && "[object process]" === {}.toString.call(process) ? F() : B ? G() : w ? H() : I();
        var v = new D,
            y = new D;
        k.prototype.o = function(a) {
            return E(a)
        };
        k.prototype.p = function() {
            return Error("Array Methods must be provided an Array")
        };
        k.prototype.l = function() {
            this.b = Array(this.length)
        };
        k.prototype.k = function() {
            for (var a = this.length, b = this.c, c = this.m, d = 0; void 0 === b.a && d < a; d++) this.j(c[d], d)
        };
        k.prototype.j = function(a, b) {
            var c = this.n;
            "object" === typeof a && null !== a ? a.constructor === c && void 0 !== a.a ? (a.f = null, this.g(a.a, b, a.b)) : this.q(c.resolve(a), b) : (this.d--, this.b[b] = this.h(a))
        };
        k.prototype.g = function(a, b, c) {
            var d = this.c;
            void 0 === d.a && (this.d--, this.i && 2 === a ? g(d, c) : this.b[b] = this.h(c));
            0 === this.d && m(d, this.b)
        };
        k.prototype.h = function(a) {
            return a
        };
        k.prototype.q = function(a, b) {
            var c = this;
            u(a, void 0, function(a) {
                c.g(1, b, a)
            }, function(a) {
                c.g(2, b, a)
            })
        };
        var O = 0;
        h.all = function(a, b) {
            return (new k(this, a, !0, b)).c
        };
        h.race = function(a, b) {
            function c(a) {
                q(e, a)
            }

            function d(a) {
                g(e, a)
            }
            var e = new this(p, b);
            if (!E(a)) return (g(e, new TypeError("You must pass an array to race.")), e);
            for (var f = a.length, h = 0; void 0 === e.a && h < f; h++) u(this.resolve(a[h]), void 0, c, d);
            return e
        };
        h.resolve = function(a, b) {
            if (a && "object" === typeof a && a.constructor === this) return a;
            var c = new this(p, b);
            q(c, a);
            return c
        };
        h.reject = function(a, b) {
            var c = new this(p, b);
            g(c, a);
            return c
        };
        h.prototype = {
            constructor: h,
            then: function(a, b) {
                var c = this.a;
                if (1 === c && !a || 2 === c && !b) return this;
                var d = new this.constructor(p),
                    e = this.b;
                if (c) {
                    var f = arguments[c - 1];
                    r(function() {
                        C(c, d, f, e)
                    })
                } else u(this, d, a, b);
                return d
            },
            "catch": function(a) {
                return this.then(null, a)
            }
        };
        var z = {
            Promise: h,
            polyfill: function() {
                var a;
                a = "undefined" !== typeof global ? global : "undefined" !== typeof window && window.document ? window : self;
                "Promise" in a && "resolve" in
                    a.Promise && "reject" in a.Promise && "all" in a.Promise && "race" in a.Promise && function() {
                        var b;
                        new a.Promise(function(a) {
                            b = a
                        });
                        return s(b)
                    }() || (a.Promise = h)
            }
        };
        "function" === typeof define && define.amd ? define(function() {
            return z
        }) : "undefined" !== typeof module && module.exports ? module.exports = z : "undefined" !== typeof this && (this.ES6Promise = z);
    }).call(window);
    if (window) {
        window.ES6Promise.polyfill();
    }
    if (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") {
        (window || module.exports).html2canvas = function() {
            return Promise.reject("No canvas support");
        };
        return;
    }; /*!https://mths.be/punycode v1.3.1 by @mathias*/
    (function(root) {
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
        var freeModule = typeof module == 'object' && module && !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }
        var punycode, maxInt = 2147483647,
            base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            delimiter = '-',
            regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            errors = {
                'overflow': 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
            },
            baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,
            key;

        function error(type) {
            throw RangeError(errors[type]);
        }

        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                result = parts[0] + '@';
                string = parts[1];
            }
            var labels = string.split(regexSeparators);
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value, extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        function ucs2encode(array) {
            return map(array, function(value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        function digitToBasic(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        function decode(input) {
            var output = [],
                inputLength = input.length,
                out, i = 0,
                n = initialN,
                bias = initialBias,
                basic, j, index, oldi, w, k, digit, t, baseMinusT;
            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }
            for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }
            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                for (oldi = i, w = 1, k = base;; k += base) {
                    if (index >= inputLength) {
                        error('invalid-input');
                    }
                    digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }
                    i += digit * w;
                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                    if (digit < t) {
                        break;
                    }
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }
                    w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
            }
            return ucs2encode(output);
        }

        function encode(input) {
            var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
            input = ucs2decode(input);
            inputLength = input.length;
            n = initialN;
            delta = 0;
            bias = initialBias;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }
            handledCPCount = basicLength = output.length;
            if (basicLength) {
                output.push(delimiter);
            }
            while (handledCPCount < inputLength) {
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }
                    if (currentValue == n) {
                        for (q = delta, k = base;; k += base) {
                            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
                ++delta;
                ++n;
            }
            return output.join('');
        }

        function toUnicode(input) {
            return mapDomain(input, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        function toASCII(input) {
            return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }
        punycode = {
            'version': '1.3.1',
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            define('punycode', function() {
                return punycode;
            });
        } else if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                freeModule.exports = punycode;
            } else {
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            root.punycode = punycode;
        }
    }(this));
    var html2canvasNodeAttribute = "data-html2canvas-node";
    var html2canvasCanvasCloneAttribute = "data-html2canvas-canvas-clone";
    var html2canvasCanvasCloneIndex = 0;
    var html2canvasCloneIndex = 0;
    window.html2canvas = function(nodeList, options) {
        var index = html2canvasCloneIndex++;
        options = options || {};
        if (options.logging) {
            window.html2canvas.logging = true;
            window.html2canvas.start = Date.now();
        }
        options.async = typeof(options.async) === "undefined" ? true : options.async;
        options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
        options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
        options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
        options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
        options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
        options.strict = !!options.strict;
        if (typeof(nodeList) === "string") {
            if (typeof(options.proxy) !== "string") {
                return Promise.reject("Proxy must be used when rendering url");
            }
            var width = options.width != null ? options.width : window.innerWidth;
            var height = options.height != null ? options.height : window.innerHeight;
            return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
                return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
            });
        }
        var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
        node.setAttribute(html2canvasNodeAttribute + index, index);
        return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {
            if (typeof(options.onrendered) === "function") {
                log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
                options.onrendered(canvas);
            }
            return canvas;
        });
    };
    window.html2canvas.punycode = this.punycode;
    window.html2canvas.proxy = {};

    function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
        return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
            log("Document cloned");
            var attributeName = html2canvasNodeAttribute + html2canvasIndex;
            var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
            document.querySelector(selector).removeAttribute(attributeName);
            var clonedWindow = container.contentWindow;
            var node = clonedWindow.document.querySelector(selector);
            var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
            return oncloneHandler.then(function() {
                return renderWindow(node, container, options, windowWidth, windowHeight);
            });
        });
    }

    function renderWindow(node, container, options, windowWidth, windowHeight) {
        var clonedWindow = container.contentWindow;
        var support = new Support(clonedWindow.document);
        var imageLoader = new ImageLoader(options, support);
        var bounds = getBounds(node);
        var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
        var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
        var renderer = new options.renderer(width, height, imageLoader, options, document);
        var parser = new NodeParser(node, renderer, support, imageLoader, options);
        return parser.ready.then(function() {
            log("Finished rendering");
            var canvas;
            if (options.type === "view") {
                canvas = crop(renderer.canvas, {
                    width: renderer.canvas.width,
                    height: renderer.canvas.height,
                    top: 0,
                    left: 0,
                    x: 0,
                    y: 0
                });
            } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
                canvas = renderer.canvas;
            } else {
                canvas = crop(renderer.canvas, {
                    width: options.width != null ? options.width : bounds.width,
                    height: options.height != null ? options.height : bounds.height,
                    top: bounds.top,
                    left: bounds.left,
                    x: clonedWindow.pageXOffset,
                    y: clonedWindow.pageYOffset
                });
            }
            cleanupContainer(container, options);
            return canvas;
        });
    }

    function cleanupContainer(container, options) {
        if (options.removeContainer) {
            container.parentNode.removeChild(container);
            log("Cleaned up container");
        }
    }

    function crop(canvas, bounds) {
        var croppedCanvas = document.createElement("canvas");
        var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
        var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
        var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
        var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
        croppedCanvas.width = bounds.width;
        croppedCanvas.height = bounds.height;
        log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", (x2 - x1), "height:", (y2 - y1));
        log("Resulting crop with width", bounds.width, "and height", bounds.height, " with x", x1, "and y", y1);
        croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, x2 - x1, y2 - y1, bounds.x, bounds.y, x2 - x1, y2 - y1);
        return croppedCanvas;
    }

    function documentWidth(doc) {
        return Math.max(Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth), Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth), Math.max(doc.body.clientWidth, doc.documentElement.clientWidth));
    }

    function documentHeight(doc) {
        return Math.max(Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight), Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight), Math.max(doc.body.clientHeight, doc.documentElement.clientHeight));
    }

    function smallImage() {
        return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    }

    function isIE9() {
        return document.documentMode && document.documentMode <= 9;
    }

    function cloneNodeIE9(node, javascriptEnabled) {
        var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);
        var child = node.firstChild;
        while (child) {
            if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
                clone.appendChild(cloneNodeIE9(child, javascriptEnabled));
            }
            child = child.nextSibling;
        }
        return clone;
    }

    function createWindowClone(ownerDocument, containerDocument, width, height, options, x, y) {
        labelCanvasElements(ownerDocument);
        var documentElement = isIE9() ? cloneNodeIE9(ownerDocument.documentElement, options.javascriptEnabled) : ownerDocument.documentElement.cloneNode(true);
        var container = containerDocument.createElement("iframe");
        container.className = "html2canvas-container";
        container.style.visibility = "hidden";
        container.style.position = "fixed";
        container.style.left = "-10000px";
        container.style.top = "0px";
        container.style.border = "0";
        container.width = width;
        container.height = height;
        container.scrolling = "no";
        containerDocument.body.appendChild(container);
        return new Promise(function(resolve) {
            var documentClone = container.contentWindow.document;
            cloneNodeValues(ownerDocument.documentElement, documentElement, "textarea");
            cloneNodeValues(ownerDocument.documentElement, documentElement, "select");
            container.contentWindow.onload = container.onload = function() {
                var interval = setInterval(function() {
                    if (documentClone.body.childNodes.length > 0) {
                        cloneCanvasContents(ownerDocument, documentClone);
                        clearInterval(interval);
                        if (options.type === "view") {
                            container.contentWindow.scrollTo(x, y);
                        }
                        resolve(container);
                    }
                }, 50);
            };
            documentClone.open();
            documentClone.write("<!DOCTYPE html><html></html>");
            restoreOwnerScroll(ownerDocument, x, y);
            documentClone.replaceChild(options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement);
            documentClone.close();
        });
    }

    function cloneNodeValues(document, clone, nodeName) {
        var originalNodes = document.getElementsByTagName(nodeName);
        var clonedNodes = clone.getElementsByTagName(nodeName);
        var count = originalNodes.length;
        for (var i = 0; i < count; i++) {
            clonedNodes[i].value = originalNodes[i].value;
        }
    }

    function restoreOwnerScroll(ownerDocument, x, y) {
        if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x, y);
        }
    }

    function loadUrlDocument(src, proxy, document, width, height, options) {
        return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
            return createWindowClone(doc, document, width, height, options, 0, 0);
        });
    }

    function documentFromHTML(src) {
        return function(html) {
            var parser = new DOMParser(),
                doc;
            try {
                doc = parser.parseFromString(html, "text/html");
            } catch (e) {
                log("DOMParser not supported, falling back to createHTMLDocument");
                doc = document.implementation.createHTMLDocument("");
                try {
                    doc.open();
                    doc.write(html);
                    doc.close();
                } catch (ee) {
                    log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                    doc.body.innerHTML = html;
                }
            }
            var b = doc.querySelector("base");
            if (!b || !b.href.host) {
                var base = doc.createElement("base");
                base.href = src;
                doc.head.insertBefore(base, doc.head.firstChild);
            }
            return doc;
        };
    }

    function labelCanvasElements(ownerDocument) {
        [].slice.call(ownerDocument.querySelectorAll("canvas"), 0).forEach(function(canvas) {
            canvas.setAttribute(html2canvasCanvasCloneAttribute, "canvas-" + html2canvasCanvasCloneIndex++);
        });
    }

    function cloneCanvasContents(ownerDocument, documentClone) {
        [].slice.call(ownerDocument.querySelectorAll("[" + html2canvasCanvasCloneAttribute + "]"), 0).forEach(function(canvas) {
            try {
                var clonedCanvas = documentClone.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
                if (clonedCanvas) {
                    clonedCanvas.width = canvas.width;
                    clonedCanvas.height = canvas.height;
                    clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                }
            } catch (e) {
                log("Unable to copy canvas content from", canvas, e);
            }
            canvas.removeAttribute(html2canvasCanvasCloneAttribute);
        });
    }

    function removeScriptNodes(parent) {
        [].slice.call(parent.childNodes, 0).filter(isElementNode).forEach(function(node) {
            if (node.tagName === "SCRIPT") {
                parent.removeChild(node);
            } else {
                removeScriptNodes(node);
            }
        });
        return parent;
    }

    function isElementNode(node) {
        return node.nodeType === Node.ELEMENT_NODE;
    }

    function absoluteUrl(url) {
        var link = document.createElement("a");
        link.href = url;
        link.href = link.href;
        return link;
    }

    function Color(value) {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = null;
        var result = this.fromArray(value) || this.namedColor(value) || this.rgb(value) || this.rgba(value) || this.hex6(value) || this.hex3(value);
    }
    Color.prototype.darken = function(amount) {
        var a = 1 - amount;
        return new Color([Math.round(this.r * a), Math.round(this.g * a), Math.round(this.b * a), this.a]);
    };
    Color.prototype.isTransparent = function() {
        return this.a === 0;
    };
    Color.prototype.isBlack = function() {
        return this.r === 0 && this.g === 0 && this.b === 0;
    };
    Color.prototype.fromArray = function(array) {
        if (Array.isArray(array)) {
            this.r = Math.min(array[0], 255);
            this.g = Math.min(array[1], 255);
            this.b = Math.min(array[2], 255);
            if (array.length > 3) {
                this.a = array[3];
            }
        }
        return (Array.isArray(array));
    };
    var _hex3 = /^#([a-f0-9]{3})$/i;
    Color.prototype.hex3 = function(value) {
        var match = null;
        if ((match = value.match(_hex3)) !== null) {
            this.r = parseInt(match[1][0] + match[1][0], 16);
            this.g = parseInt(match[1][1] + match[1][1], 16);
            this.b = parseInt(match[1][2] + match[1][2], 16);
        }
        return match !== null;
    };
    var _hex6 = /^#([a-f0-9]{6})$/i;
    Color.prototype.hex6 = function(value) {
        var match = null;
        if ((match = value.match(_hex6)) !== null) {
            this.r = parseInt(match[1].substring(0, 2), 16);
            this.g = parseInt(match[1].substring(2, 4), 16);
            this.b = parseInt(match[1].substring(4, 6), 16);
        }
        return match !== null;
    };
    var _rgb = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    Color.prototype.rgb = function(value) {
        var match = null;
        if ((match = value.match(_rgb)) !== null) {
            this.r = Number(match[1]);
            this.g = Number(match[2]);
            this.b = Number(match[3]);
        }
        return match !== null;
    };
    var _rgba = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    Color.prototype.rgba = function(value) {
        var match = null;
        if ((match = value.match(_rgba)) !== null) {
            this.r = Number(match[1]);
            this.g = Number(match[2]);
            this.b = Number(match[3]);
            this.a = Number(match[4]);
        }
        return match !== null;
    };
    Color.prototype.toString = function() {
        return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" : "rgb(" + [this.r, this.g, this.b].join(",") + ")";
    };
    Color.prototype.namedColor = function(value) {
        var color = colors[value.toLowerCase()];
        if (color) {
            this.r = color[0];
            this.g = color[1];
            this.b = color[2];
        } else if (value.toLowerCase() === "transparent") {
            this.r = this.g = this.b = this.a = 0;
            return true;
        }
        return !!color;
    };
    Color.prototype.isColor = true;
    var colors = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
    };

    function DummyImageContainer(src) {
        this.src = src;
        log("DummyImageContainer for", src);
        if (!this.promise || !this.image) {
            log("Initiating DummyImageContainer");
            DummyImageContainer.prototype.image = new Image();
            var image = this.image;
            DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
                image.onload = resolve;
                image.onerror = reject;
                image.src = smallImage();
                if (image.complete === true) {
                    resolve(image);
                }
            });
        }
    }

    function Font(family, size) {
        var container = document.createElement('div'),
            img = document.createElement('img'),
            span = document.createElement('span'),
            sampleText = 'Hidden Text',
            baseline, middle;
        container.style.visibility = "hidden";
        container.style.fontFamily = family;
        container.style.fontSize = size;
        container.style.margin = 0;
        container.style.padding = 0;
        document.body.appendChild(container);
        img.src = smallImage();
        img.width = 1;
        img.height = 1;
        img.style.margin = 0;
        img.style.padding = 0;
        img.style.verticalAlign = "baseline";
        span.style.fontFamily = family;
        span.style.fontSize = size;
        span.style.margin = 0;
        span.style.padding = 0;
        span.appendChild(document.createTextNode(sampleText));
        container.appendChild(span);
        container.appendChild(img);
        baseline = (img.offsetTop - span.offsetTop) + 1;
        container.removeChild(span);
        container.appendChild(document.createTextNode(sampleText));
        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";
        middle = (img.offsetTop - container.offsetTop) + 1;
        document.body.removeChild(container);
        this.baseline = baseline;
        this.lineWidth = 1;
        this.middle = middle;
    }

    function FontMetrics() {
        this.data = {};
    }
    FontMetrics.prototype.getMetrics = function(family, size) {
        if (this.data[family + "-" + size] === undefined) {
            this.data[family + "-" + size] = new Font(family, size);
        }
        return this.data[family + "-" + size];
    };

    function FrameContainer(container, sameOrigin, options) {
        this.image = null;
        this.src = container;
        var self = this;
        var bounds = getBounds(container);
        this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
            if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
                container.contentWindow.onload = container.onload = function() {
                    resolve(container);
                };
            } else {
                resolve(container);
            }
        })).then(function(container) {
            return html2canvas(container.contentWindow.document.documentElement, {
                type: 'view',
                width: container.width,
                height: container.height,
                proxy: options.proxy,
                javascriptEnabled: options.javascriptEnabled,
                removeContainer: options.removeContainer,
                allowTaint: options.allowTaint,
                imageTimeout: options.imageTimeout / 2
            });
        }).then(function(canvas) {
            return self.image = canvas;
        });
    }
    FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
        var container = this.src;
        return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
    };

    function GradientContainer(imageData) {
        this.src = imageData.value;
        this.colorStops = [];
        this.type = null;
        this.x0 = 0.5;
        this.y0 = 0.5;
        this.x1 = 0.5;
        this.y1 = 0.5;
        this.promise = Promise.resolve(true);
    }
    GradientContainer.prototype.TYPES = {
        LINEAR: 1,
        RADIAL: 2
    };

    function ImageContainer(src, cors) {
        this.src = src;
        this.image = new Image();
        var self = this;
        this.tainted = null;
        this.promise = new Promise(function(resolve, reject) {
            self.image.onload = resolve;
            self.image.onerror = reject;
            if (cors) {
                self.image.crossOrigin = "anonymous";
            }
            self.image.src = src;
            if (self.image.complete === true) {
                resolve(self.image);
            }
        });
    }

    function ImageLoader(options, support) {
        this.link = null;
        this.options = options;
        this.support = support;
        this.origin = this.getOrigin(window.location.href);
    }
    ImageLoader.prototype.findImages = function(nodes) {
        var images = [];
        nodes.reduce(function(imageNodes, container) {
            switch (container.node.nodeName) {
                case "IMG":
                    return imageNodes.concat([{
                        args: [container.node.src],
                        method: "url"
                    }]);
                case "svg":
                case "IFRAME":
                    return imageNodes.concat([{
                        args: [container.node],
                        method: container.node.nodeName
                    }]);
            }
            return imageNodes;
        }, []).forEach(this.addImage(images, this.loadImage), this);
        return images;
    };
    ImageLoader.prototype.findBackgroundImage = function(images, container) {
        container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
        return images;
    };
    ImageLoader.prototype.addImage = function(images, callback) {
        return function(newImage) {
            newImage.args.forEach(function(image) {
                if (!this.imageExists(images, image)) {
                    images.splice(0, 0, callback.call(this, newImage));
                    log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
                }
            }, this);
        };
    };
    ImageLoader.prototype.hasImageBackground = function(imageData) {
        return imageData.method !== "none";
    };
    ImageLoader.prototype.loadImage = function(imageData) {
        if (imageData.method === "url") {
            var src = imageData.args[0];
            if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
                return new SVGContainer(src);
            } else if (src.match(/data:image\/.*;base64,/i)) {
                return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
            } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
                return new ImageContainer(src, false);
            } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
                return new ImageContainer(src, true);
            } else if (this.options.proxy) {
                return new ProxyImageContainer(src, this.options.proxy);
            } else {
                return new DummyImageContainer(src);
            }
        } else if (imageData.method === "linear-gradient") {
            return new LinearGradientContainer(imageData);
        } else if (imageData.method === "gradient") {
            return new WebkitGradientContainer(imageData);
        } else if (imageData.method === "svg") {
            return new SVGNodeContainer(imageData.args[0], this.support.svg);
        } else if (imageData.method === "IFRAME") {
            return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
        } else {
            return new DummyImageContainer(imageData);
        }
    };
    ImageLoader.prototype.isSVG = function(src) {
        return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
    };
    ImageLoader.prototype.imageExists = function(images, src) {
        return images.some(function(image) {
            return image.src === src;
        });
    };
    ImageLoader.prototype.isSameOrigin = function(url) {
        return (this.getOrigin(url) === this.origin);
    };
    ImageLoader.prototype.getOrigin = function(url) {
        var link = this.link || (this.link = document.createElement("a"));
        link.href = url;
        link.href = link.href;
        return link.protocol + link.hostname + link.port;
    };
    ImageLoader.prototype.getPromise = function(container) {
        return this.timeout(container, this.options.imageTimeout)['catch'](function() {
            var dummy = new DummyImageContainer(container.src);
            return dummy.promise.then(function(image) {
                container.image = image;
            });
        });
    };
    ImageLoader.prototype.get = function(src) {
        var found = null;
        return this.images.some(function(img) {
            return (found = img).src === src;
        }) ? found : null;
    };
    ImageLoader.prototype.fetch = function(nodes) {
        this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
        this.images.forEach(function(image, index) {
            image.promise.then(function() {
                log("Succesfully loaded image #" + (index + 1), image);
            }, function(e) {
                log("Failed loading image #" + (index + 1), image, e);
            });
        });
        this.ready = Promise.all(this.images.map(this.getPromise, this));
        log("Finished searching images");
        return this;
    };
    ImageLoader.prototype.timeout = function(container, timeout) {
        var timer;
        var promise = Promise.race([container.promise, new Promise(function(res, reject) {
            timer = setTimeout(function() {
                log("Timed out loading image", container);
                reject(container);
            }, timeout);
        })]).then(function(container) {
            clearTimeout(timer);
            return container;
        });
        promise['catch'](function() {
            clearTimeout(timer);
        });
        return promise;
    };

    function LinearGradientContainer(imageData) {
        GradientContainer.apply(this, arguments);
        this.type = this.TYPES.LINEAR;
        var hasDirection = imageData.args[0].match(this.stepRegExp) === null;
        if (hasDirection) {
            imageData.args[0].split(" ").reverse().forEach(function(position) {
                switch (position) {
                    case "left":
                        this.x0 = 0;
                        this.x1 = 1;
                        break;
                    case "top":
                        this.y0 = 0;
                        this.y1 = 1;
                        break;
                    case "right":
                        this.x0 = 1;
                        this.x1 = 0;
                        break;
                    case "bottom":
                        this.y0 = 1;
                        this.y1 = 0;
                        break;
                    case "to":
                        var y0 = this.y0;
                        var x0 = this.x0;
                        this.y0 = this.y1;
                        this.x0 = this.x1;
                        this.x1 = x0;
                        this.y1 = y0;
                        break;
                }
            }, this);
        } else {
            this.y0 = 0;
            this.y1 = 1;
        }
        this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
            var colorStopMatch = colorStop.match(this.stepRegExp);
            return {
                color: new Color(colorStopMatch[1]),
                stop: colorStopMatch[3] === "%" ? colorStopMatch[2] / 100 : null
            };
        }, this);
        if (this.colorStops[0].stop === null) {
            this.colorStops[0].stop = 0;
        }
        if (this.colorStops[this.colorStops.length - 1].stop === null) {
            this.colorStops[this.colorStops.length - 1].stop = 1;
        }
        this.colorStops.forEach(function(colorStop, index) {
            if (colorStop.stop === null) {
                this.colorStops.slice(index).some(function(find, count) {
                    if (find.stop !== null) {
                        colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                        return true;
                    } else {
                        return false;
                    }
                }, this);
            }
        }, this);
    }
    LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);
    LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/;

    function log() {
        if (window.html2canvas.logging && window.console && window.console.log) {
            Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - window.html2canvas.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
        }
    }

    function NodeContainer(node, parent) {
        this.node = node;
        this.parent = parent;
        this.stack = null;
        this.bounds = null;
        this.borders = null;
        this.clip = [];
        this.backgroundClip = [];
        this.offsetBounds = null;
        this.visible = null;
        this.computedStyles = null;
        this.colors = {};
        this.styles = {};
        this.backgroundImages = null;
        this.transformData = null;
        this.transformMatrix = null;
        this.isPseudoElement = false;
        this.opacity = null;
    }
    NodeContainer.prototype.cloneTo = function(stack) {
        stack.visible = this.visible;
        stack.borders = this.borders;
        stack.bounds = this.bounds;
        stack.clip = this.clip;
        stack.backgroundClip = this.backgroundClip;
        stack.computedStyles = this.computedStyles;
        stack.styles = this.styles;
        stack.backgroundImages = this.backgroundImages;
        stack.opacity = this.opacity;
    };
    NodeContainer.prototype.getOpacity = function() {
        return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
    };
    NodeContainer.prototype.assignStack = function(stack) {
        this.stack = stack;
        stack.children.push(this);
    };
    NodeContainer.prototype.isElementVisible = function() {
        return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (this.css('display') !== "none" && this.css('visibility') !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden"));
    };
    NodeContainer.prototype.css = function(attribute) {
        if (!this.computedStyles) {
            this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
        }
        return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
    };
    NodeContainer.prototype.prefixedCss = function(attribute) {
        var prefixes = ["webkit", "moz", "ms", "o"];
        var value = this.css(attribute);
        if (value === undefined) {
            prefixes.some(function(prefix) {
                value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
                return value !== undefined;
            }, this);
        }
        return value === undefined ? null : value;
    };
    NodeContainer.prototype.computedStyle = function(type) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
    };
    NodeContainer.prototype.cssInt = function(attribute) {
        var value = parseInt(this.css(attribute), 10);
        return (isNaN(value)) ? 0 : value;
    };
    NodeContainer.prototype.color = function(attribute) {
        return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
    };
    NodeContainer.prototype.cssFloat = function(attribute) {
        var value = parseFloat(this.css(attribute));
        return (isNaN(value)) ? 0 : value;
    };
    NodeContainer.prototype.fontWeight = function() {
        var weight = this.css("fontWeight");
        switch (parseInt(weight, 10)) {
            case 401:
                weight = "bold";
                break;
            case 400:
                weight = "normal";
                break;
        }
        return weight;
    };
    NodeContainer.prototype.parseClip = function() {
        var matches = this.css('clip').match(this.CLIP);
        if (matches) {
            return {
                top: parseInt(matches[1], 10),
                right: parseInt(matches[2], 10),
                bottom: parseInt(matches[3], 10),
                left: parseInt(matches[4], 10)
            };
        }
        return null;
    };
    NodeContainer.prototype.parseBackgroundImages = function() {
        return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
    };
    NodeContainer.prototype.cssList = function(property, index) {
        var value = (this.css(property) || '').split(',');
        value = value[index || 0] || value[0] || 'auto';
        value = value.trim().split(' ');
        if (value.length === 1) {
            value = [value[0], value[0]];
        }
        return value;
    };
    NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
        var size = this.cssList("backgroundSize", index);
        var width, height;
        if (isPercentage(size[0])) {
            width = bounds.width * parseFloat(size[0]) / 100;
        } else if (/contain|cover/.test(size[0])) {
            var targetRatio = bounds.width / bounds.height,
                currentRatio = image.width / image.height;
            return (targetRatio < currentRatio ^ size[0] === 'contain') ? {
                width: bounds.height * currentRatio,
                height: bounds.height
            } : {
                width: bounds.width,
                height: bounds.width / currentRatio
            };
        } else {
            width = parseInt(size[0], 10);
        }
        if (size[0] === 'auto' && size[1] === 'auto') {
            height = image.height;
        } else if (size[1] === 'auto') {
            height = width / image.width * image.height;
        } else if (isPercentage(size[1])) {
            height = bounds.height * parseFloat(size[1]) / 100;
        } else {
            height = parseInt(size[1], 10);
        }
        if (size[0] === 'auto') {
            width = height / image.height * image.width;
        }
        return {
            width: width,
            height: height
        };
    };
    NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
        var position = this.cssList('backgroundPosition', index);
        var left, top;
        if (isPercentage(position[0])) {
            left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
        } else {
            left = parseInt(position[0], 10);
        }
        if (position[1] === 'auto') {
            top = left / image.width * image.height;
        } else if (isPercentage(position[1])) {
            top = (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
        } else {
            top = parseInt(position[1], 10);
        }
        if (position[0] === 'auto') {
            left = top / image.height * image.width;
        }
        return {
            left: left,
            top: top
        };
    };
    NodeContainer.prototype.parseBackgroundRepeat = function(index) {
        return this.cssList("backgroundRepeat", index)[0];
    };
    NodeContainer.prototype.parseTextShadows = function() {
        var textShadow = this.css("textShadow");
        var results = [];
        if (textShadow && textShadow !== 'none') {
            var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
            for (var i = 0; shadows && (i < shadows.length); i++) {
                var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
                results.push({
                    color: new Color(s[0]),
                    offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                    offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                    blur: s[3] ? s[3].replace('px', '') : 0
                });
            }
        }
        return results;
    };
    NodeContainer.prototype.parseTransform = function() {
        if (!this.transformData) {
            if (this.hasTransform()) {
                var offset = this.parseBounds();
                var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
                origin[0] += offset.left;
                origin[1] += offset.top;
                this.transformData = {
                    origin: origin,
                    matrix: this.parseTransformMatrix()
                };
            } else {
                this.transformData = {
                    origin: [0, 0],
                    matrix: [1, 0, 0, 1, 0, 0]
                };
            }
        }
        return this.transformData;
    };
    NodeContainer.prototype.parseTransformMatrix = function() {
        if (!this.transformMatrix) {
            var transform = this.prefixedCss("transform");
            var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
            this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
        }
        return this.transformMatrix;
    };
    NodeContainer.prototype.parseBounds = function() {
        return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
    };
    NodeContainer.prototype.hasTransform = function() {
        return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
    };
    NodeContainer.prototype.getValue = function() {
        var value = this.node.value || "";
        if (this.node.tagName === "SELECT") {
            value = selectionValue(this.node);
        } else if (this.node.type === "password") {
            value = Array(value.length + 1).join('\u2022');
        }
        return value.length === 0 ? (this.node.placeholder || "") : value;
    };
    NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/;
    NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
    NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
    NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

    function selectionValue(node) {
        var option = node.options[node.selectedIndex || 0];
        return option ? (option.text || "") : "";
    }

    function parseMatrix(match) {
        if (match && match[1] === "matrix") {
            return match[2].split(",").map(function(s) {
                return parseFloat(s.trim());
            });
        }
    }

    function isPercentage(value) {
        return value.toString().indexOf("%") !== -1;
    }

    function parseBackgrounds(backgroundImage) {
        var whitespace = ' \r\n\t',
            method, definition, prefix, prefix_i, block, results = [],
            mode = 0,
            numParen = 0,
            quote, args;
        var appendResult = function() {
            if (method) {
                if (definition.substr(0, 1) === '"') {
                    definition = definition.substr(1, definition.length - 2);
                }
                if (definition) {
                    args.push(definition);
                }
                if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                    prefix = method.substr(0, prefix_i);
                    method = method.substr(prefix_i);
                }
                results.push({
                    prefix: prefix,
                    method: method.toLowerCase(),
                    value: block,
                    args: args,
                    image: null
                });
            }
            args = [];
            method = prefix = definition = block = '';
        };
        args = [];
        method = prefix = definition = block = '';
        backgroundImage.split("").forEach(function(c) {
            if (mode === 0 && whitespace.indexOf(c) > -1) {
                return;
            }
            switch (c) {
                case '"':
                    if (!quote) {
                        quote = c;
                    } else if (quote === c) {
                        quote = null;
                    }
                    break;
                case '(':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        mode = 1;
                        block += c;
                        return;
                    } else {
                        numParen++;
                    }
                    break;
                case ')':
                    if (quote) {
                        break;
                    } else if (mode === 1) {
                        if (numParen === 0) {
                            mode = 0;
                            block += c;
                            appendResult();
                            return;
                        } else {
                            numParen--;
                        }
                    }
                    break;
                case ',':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        appendResult();
                        return;
                    } else if (mode === 1) {
                        if (numParen === 0 && !method.match(/^url$/i)) {
                            args.push(definition);
                            definition = '';
                            block += c;
                            return;
                        }
                    }
                    break;
            }
            block += c;
            if (mode === 0) {
                method += c;
            } else {
                definition += c;
            }
        });
        appendResult();
        return results;
    }

    function removePx(str) {
        return str.replace("px", "");
    }

    function asFloat(str) {
        return parseFloat(str);
    }

    function getBounds(node) {
        if (node.getBoundingClientRect) {
            var clientRect = node.getBoundingClientRect();
            var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
            return {
                top: clientRect.top,
                bottom: clientRect.bottom || (clientRect.top + clientRect.height),
                right: clientRect.left + width,
                left: clientRect.left,
                width: width,
                height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
            };
        }
        return {};
    }

    function offsetBounds(node) {
        var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {
            top: 0,
            left: 0
        };
        return {
            top: node.offsetTop + parent.top,
            bottom: node.offsetTop + node.offsetHeight + parent.top,
            right: node.offsetLeft + parent.left + node.offsetWidth,
            left: node.offsetLeft + parent.left,
            width: node.offsetWidth,
            height: node.offsetHeight
        };
    }

    function NodeParser(element, renderer, support, imageLoader, options) {
        log("Starting NodeParser");
        this.renderer = renderer;
        this.options = options;
        this.range = null;
        this.support = support;
        this.renderQueue = [];
        this.stack = new StackingContext(true, 1, element.ownerDocument, null);
        var parent = new NodeContainer(element, null);
        if (options.background) {
            renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
        }
        if (element === element.ownerDocument.documentElement) {
            var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
            renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
        }
        parent.visibile = parent.isElementVisible();
        this.createPseudoHideStyles(element.ownerDocument);
        this.disableAnimations(element.ownerDocument);
        this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
            return container.visible = container.isElementVisible();
        }).map(this.getPseudoElements, this));
        this.fontMetrics = new FontMetrics();
        log("Fetched nodes, total:", this.nodes.length);
        log("Calculate overflow clips");
        this.calculateOverflowClips();
        log("Start fetching images");
        this.images = imageLoader.fetch(this.nodes.filter(isElement));
        this.ready = this.images.ready.then(bind(function() {
            log("Images loaded, starting parsing");
            log("Creating stacking contexts");
            this.createStackingContexts();
            log("Sorting stacking contexts");
            this.sortStackingContexts(this.stack);
            this.parse(this.stack);
            log("Render queue created with " + this.renderQueue.length + " items");
            return new Promise(bind(function(resolve) {
                if (!options.async) {
                    this.renderQueue.forEach(this.paint, this);
                    resolve();
                } else if (typeof(options.async) === "function") {
                    options.async.call(this, this.renderQueue, resolve);
                } else if (this.renderQueue.length > 0) {
                    this.renderIndex = 0;
                    this.asyncRenderer(this.renderQueue, resolve);
                } else {
                    resolve();
                }
            }, this));
        }, this));
    }
    NodeParser.prototype.calculateOverflowClips = function() {
        this.nodes.forEach(function(container) {
            if (isElement(container)) {
                if (isPseudoElement(container)) {
                    container.appendToDOM();
                }
                container.borders = this.parseBorders(container);
                var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
                var cssClip = container.parseClip();
                if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                    clip.push([
                        ["rect", container.bounds.left + cssClip.left, container.bounds.top + cssClip.top, cssClip.right - cssClip.left, cssClip.bottom - cssClip.top]
                    ]);
                }
                container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
                container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
                if (isPseudoElement(container)) {
                    container.cleanDOM();
                }
            } else if (isTextNode(container)) {
                container.clip = hasParentClip(container) ? container.parent.clip : [];
            }
            if (!isPseudoElement(container)) {
                container.bounds = null;
            }
        }, this);
    };

    function hasParentClip(container) {
        return container.parent && container.parent.clip.length;
    }
    NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
        asyncTimer = asyncTimer || Date.now();
        this.paint(queue[this.renderIndex++]);
        if (queue.length === this.renderIndex) {
            resolve();
        } else if (asyncTimer + 20 > Date.now()) {
            this.asyncRenderer(queue, resolve, asyncTimer);
        } else {
            setTimeout(bind(function() {
                this.asyncRenderer(queue, resolve);
            }, this), 0);
        }
    };
    NodeParser.prototype.createPseudoHideStyles = function(document) {
        this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' + '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
    };
    NodeParser.prototype.disableAnimations = function(document) {
        this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' + '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
    };
    NodeParser.prototype.createStyles = function(document, styles) {
        var hidePseudoElements = document.createElement('style');
        hidePseudoElements.innerHTML = styles;
        document.body.appendChild(hidePseudoElements);
    };
    NodeParser.prototype.getPseudoElements = function(container) {
        var nodes = [
            [container]
        ];
        if (container.node.nodeType === Node.ELEMENT_NODE) {
            var before = this.getPseudoElement(container, ":before");
            var after = this.getPseudoElement(container, ":after");
            if (before) {
                nodes.push(before);
            }
            if (after) {
                nodes.push(after);
            }
        }
        return flatten(nodes);
    };

    function toCamelCase(str) {
        return str.replace(/(\-[a-z])/g, function(match) {
            return match.toUpperCase().replace('-', '');
        });
    }
    NodeParser.prototype.getPseudoElement = function(container, type) {
        var style = container.computedStyle(type);
        if (!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
            return null;
        }
        var content = stripQuotes(style.content);
        var isImage = content.substr(0, 3) === 'url';
        var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
        var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);
        for (var i = style.length - 1; i >= 0; i--) {
            var property = toCamelCase(style.item(i));
            pseudoNode.style[property] = style[property];
        }
        pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        if (isImage) {
            pseudoNode.src = parseBackgrounds(content)[0].args[0];
            return [pseudoContainer];
        } else {
            var text = document.createTextNode(content);
            pseudoNode.appendChild(text);
            return [pseudoContainer, new TextContainer(text, pseudoContainer)];
        }
    };
    NodeParser.prototype.getChildren = function(parentContainer) {
        return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
            var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
            return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
        }, this));
    };
    NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
        var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
        container.cloneTo(stack);
        var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
        parentStack.contexts.push(stack);
        container.stack = stack;
    };
    NodeParser.prototype.createStackingContexts = function() {
        this.nodes.forEach(function(container) {
            if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
                this.newStackingContext(container, true);
            } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
                this.newStackingContext(container, false);
            } else {
                container.assignStack(container.parent.stack);
            }
        }, this);
    };
    NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
        return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
    };
    NodeParser.prototype.isRootElement = function(container) {
        return container.parent === null;
    };
    NodeParser.prototype.sortStackingContexts = function(stack) {
        stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
        stack.contexts.forEach(this.sortStackingContexts, this);
    };
    NodeParser.prototype.parseTextBounds = function(container) {
        return function(text, index, textList) {
            if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
                if (this.support.rangeBounds && !container.parent.hasTransform()) {
                    var offset = textList.slice(0, index).join("").length;
                    return this.getRangeBounds(container.node, offset, text.length);
                } else if (container.node && typeof(container.node.data) === "string") {
                    var replacementNode = container.node.splitText(text.length);
                    var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                    container.node = replacementNode;
                    return bounds;
                }
            } else if (!this.support.rangeBounds || container.parent.hasTransform()) {
                container.node = container.node.splitText(text.length);
            }
            return {};
        };
    };
    NodeParser.prototype.getWrapperBounds = function(node, transform) {
        var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
        var parent = node.parentNode,
            backupText = node.cloneNode(true);
        wrapper.appendChild(node.cloneNode(true));
        parent.replaceChild(wrapper, node);
        var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
        parent.replaceChild(backupText, wrapper);
        return bounds;
    };
    NodeParser.prototype.getRangeBounds = function(node, offset, length) {
        var range = this.range || (this.range = node.ownerDocument.createRange());
        range.setStart(node, offset);
        range.setEnd(node, offset + length);
        return range.getBoundingClientRect();
    };

    function ClearTransform() {}
    NodeParser.prototype.parse = function(stack) {
        var negativeZindex = stack.contexts.filter(negativeZIndex);
        var descendantElements = stack.children.filter(isElement);
        var descendantNonFloats = descendantElements.filter(not(isFloating));
        var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel));
        var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating);
        var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel);
        var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0);
        var text = stack.children.filter(isTextNode).filter(hasText);
        var positiveZindex = stack.contexts.filter(positiveZIndex);
        negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats).concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
    };
    NodeParser.prototype.paint = function(container) {
        try {
            if (container instanceof ClearTransform) {
                this.renderer.ctx.restore();
            } else if (isTextNode(container)) {
                if (isPseudoElement(container.parent)) {
                    container.parent.appendToDOM();
                }
                this.paintText(container);
                if (isPseudoElement(container.parent)) {
                    container.parent.cleanDOM();
                }
            } else {
                this.paintNode(container);
            }
        } catch (e) {
            log(e);
            if (this.options.strict) {
                throw e;
            }
        }
    };
    NodeParser.prototype.paintNode = function(container) {
        if (isStackingContext(container)) {
            this.renderer.setOpacity(container.opacity);
            this.renderer.ctx.save();
            if (container.hasTransform()) {
                this.renderer.setTransform(container.parseTransform());
            }
        }
        if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
            this.paintCheckbox(container);
        } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
            this.paintRadio(container);
        } else {
            this.paintElement(container);
        }
    };
    NodeParser.prototype.paintElement = function(container) {
        var bounds = container.parseBounds();
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
        }, this);
        this.renderer.clip(container.clip, function() {
            this.renderer.renderBorders(container.borders.borders);
        }, this);
        this.renderer.clip(container.backgroundClip, function() {
            switch (container.node.nodeName) {
                case "svg":
                case "IFRAME":
                    var imgContainer = this.images.get(container.node);
                    if (imgContainer) {
                        this.renderer.renderImage(container, bounds, container.borders, imgContainer);
                    } else {
                        log("Error loading <" + container.node.nodeName + ">", container.node);
                    }
                    break;
                case "IMG":
                    var imageContainer = this.images.get(container.node.src);
                    if (imageContainer) {
                        this.renderer.renderImage(container, bounds, container.borders, imageContainer);
                    } else {
                        log("Error loading <img>", container.node.src);
                    }
                    break;
                case "CANVAS":
                    this.renderer.renderImage(container, bounds, container.borders, {
                        image: container.node
                    });
                    break;
                case "SELECT":
                case "INPUT":
                case "TEXTAREA":
                    this.paintFormValue(container);
                    break;
            }
        }, this);
    };
    NodeParser.prototype.paintCheckbox = function(container) {
        var b = container.parseBounds();
        var size = Math.min(b.width, b.height);
        var bounds = {
            width: size - 1,
            height: size - 1,
            top: b.top,
            left: b.left
        };
        var r = [3, 3];
        var radius = [r, r, r, r];
        var borders = [1, 1, 1, 1].map(function(w) {
            return {
                color: new Color('#A5A5A5'),
                width: w
            };
        });
        var borderPoints = calculateCurvePoints(bounds, radius, borders);
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
            this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
            if (container.node.checked) {
                this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
                this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
            }
        }, this);
    };
    NodeParser.prototype.paintRadio = function(container) {
        var bounds = container.parseBounds();
        var size = Math.min(bounds.width, bounds.height) - 2;
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
            if (container.node.checked) {
                this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
            }
        }, this);
    };
    NodeParser.prototype.paintFormValue = function(container) {
        var value = container.getValue();
        if (value.length > 0) {
            var document = container.node.ownerDocument;
            var wrapper = document.createElement('html2canvaswrapper');
            var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth', 'boxSizing', 'whiteSpace', 'wordWrap'];
            properties.forEach(function(property) {
                try {
                    wrapper.style[property] = container.css(property);
                } catch (e) {
                    log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                }
            });
            var bounds = container.parseBounds();
            wrapper.style.position = "fixed";
            wrapper.style.left = bounds.left + "px";
            wrapper.style.top = bounds.top + "px";
            wrapper.textContent = value;
            document.body.appendChild(wrapper);
            this.paintText(new TextContainer(wrapper.firstChild, container));
            document.body.removeChild(wrapper);
        }
    };
    NodeParser.prototype.paintText = function(container) {
        container.applyTextTransform();
        var characters = window.html2canvas.punycode.ucs2.decode(container.node.data);
        var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
            return window.html2canvas.punycode.ucs2.encode([character]);
        });
        var weight = container.parent.fontWeight();
        var size = container.parent.css('fontSize');
        var family = container.parent.css('fontFamily');
        var shadows = container.parent.parseTextShadows();
        this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
        if (shadows.length) {
            this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
        } else {
            this.renderer.clearShadow();
        }
        this.renderer.clip(container.parent.clip, function() {
            textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
                if (bounds) {
                    this.renderer.text(textList[index], bounds.left, bounds.bottom);
                    this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
                }
            }, this);
        }, this);
    };
    NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
        switch (container.css("textDecoration").split(" ")[0]) {
            case "underline":
                this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
                break;
            case "overline":
                this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
                break;
            case "line-through":
                this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
                break;
        }
    };
    var borderColorTransforms = {
        inset: [
            ["darken", 0.60],
            ["darken", 0.10],
            ["darken", 0.10],
            ["darken", 0.60]
        ]
    };
    NodeParser.prototype.parseBorders = function(container) {
        var nodeBounds = container.parseBounds();
        var radius = getBorderRadiusData(container);
        var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
            var style = container.css('border' + side + 'Style');
            var color = container.color('border' + side + 'Color');
            if (style === "inset" && color.isBlack()) {
                color = new Color([255, 255, 255, color.a]);
            }
            var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
            return {
                width: container.cssInt('border' + side + 'Width'),
                color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
                args: null
            };
        });
        var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);
        return {
            clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
            borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
        };
    };

    function calculateBorders(borders, nodeBounds, borderPoints, radius) {
        return borders.map(function(border, borderSide) {
            if (border.width > 0) {
                var bx = nodeBounds.left;
                var by = nodeBounds.top;
                var bw = nodeBounds.width;
                var bh = nodeBounds.height - (borders[2].width);
                switch (borderSide) {
                    case 0:
                        bh = borders[0].width;
                        border.args = drawSide({
                            c1: [bx, by],
                            c2: [bx + bw, by],
                            c3: [bx + bw - borders[1].width, by + bh],
                            c4: [bx + borders[3].width, by + bh]
                        }, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                        break;
                    case 1:
                        bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                        bw = borders[1].width;
                        border.args = drawSide({
                            c1: [bx + bw, by],
                            c2: [bx + bw, by + bh + borders[2].width],
                            c3: [bx, by + bh],
                            c4: [bx, by + borders[0].width]
                        }, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                        break;
                    case 2:
                        by = (by + nodeBounds.height) - (borders[2].width);
                        bh = borders[2].width;
                        border.args = drawSide({
                            c1: [bx + bw, by + bh],
                            c2: [bx, by + bh],
                            c3: [bx + borders[3].width, by],
                            c4: [bx + bw - borders[3].width, by]
                        }, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                        break;
                    case 3:
                        bw = borders[3].width;
                        border.args = drawSide({
                            c1: [bx, by + bh + borders[2].width],
                            c2: [bx, by],
                            c3: [bx + bw, by + borders[0].width],
                            c4: [bx + bw, by + bh]
                        }, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                        break;
                }
            }
            return border;
        });
    }
    NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
        var backgroundClip = container.css('backgroundClip'),
            borderArgs = [];
        switch (backgroundClip) {
            case "content-box":
            case "padding-box":
                parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                break;
            default:
                parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                break;
        }
        return borderArgs;
    };

    function getCurvePoints(x, y, r1, r2) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = (r1) * kappa,
            oy = (r2) * kappa,
            xm = x + r1,
            ym = y + r2;
        return {
            topLeft: bezierCurve({
                x: x,
                y: ym
            }, {
                x: x,
                y: ym - oy
            }, {
                x: xm - ox,
                y: y
            }, {
                x: xm,
                y: y
            }),
            topRight: bezierCurve({
                x: x,
                y: y
            }, {
                x: x + ox,
                y: y
            }, {
                x: xm,
                y: ym - oy
            }, {
                x: xm,
                y: ym
            }),
            bottomRight: bezierCurve({
                x: xm,
                y: y
            }, {
                x: xm,
                y: y + oy
            }, {
                x: x + ox,
                y: ym
            }, {
                x: x,
                y: ym
            }),
            bottomLeft: bezierCurve({
                x: xm,
                y: ym
            }, {
                x: xm - ox,
                y: ym
            }, {
                x: x,
                y: y + oy
            }, {
                x: x,
                y: y
            })
        };
    }

    function calculateCurvePoints(bounds, borderRadius, borders) {
        var x = bounds.left,
            y = bounds.top,
            width = bounds.width,
            height = bounds.height,
            tlh = borderRadius[0][0],
            tlv = borderRadius[0][1],
            trh = borderRadius[1][0],
            trv = borderRadius[1][1],
            brh = borderRadius[2][0],
            brv = borderRadius[2][1],
            blh = borderRadius[3][0],
            blv = borderRadius[3][1];
        var topWidth = width - trh,
            rightHeight = height - brv,
            bottomWidth = width - brh,
            leftHeight = height - blv;
        return {
            topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
            topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
            topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
            topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 : trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
            bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
            bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), brv - borders[2].width).bottomRight.subdivide(0.5),
            bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
            bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
        };
    }

    function bezierCurve(start, startControl, endControl, end) {
        var lerp = function(a, b, t) {
            return {
                x: a.x + (b.x - a.x) * t,
                y: a.y + (b.y - a.y) * t
            };
        };
        return {
            start: start,
            startControl: startControl,
            endControl: endControl,
            end: end,
            subdivide: function(t) {
                var ab = lerp(start, startControl, t),
                    bc = lerp(startControl, endControl, t),
                    cd = lerp(endControl, end, t),
                    abbc = lerp(ab, bc, t),
                    bccd = lerp(bc, cd, t),
                    dest = lerp(abbc, bccd, t);
                return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
            },
            curveTo: function(borderArgs) {
                borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
            },
            curveToReversed: function(borderArgs) {
                borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
            }
        };
    }

    function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
        var borderArgs = [];
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
            outer1[1].curveTo(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
        }
        if (radius2[0] > 0 || radius2[1] > 0) {
            borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
            outer2[0].curveTo(borderArgs);
            borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
            inner2[0].curveToReversed(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
            borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
        }
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
            inner1[1].curveToReversed(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
        }
        return borderArgs;
    }

    function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
            corner1[0].curveTo(borderArgs);
            corner1[1].curveTo(borderArgs);
        } else {
            borderArgs.push(["line", x, y]);
        }
        if (radius2[0] > 0 || radius2[1] > 0) {
            borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
        }
    }

    function negativeZIndex(container) {
        return container.cssInt("zIndex") < 0;
    }

    function positiveZIndex(container) {
        return container.cssInt("zIndex") > 0;
    }

    function zIndex0(container) {
        return container.cssInt("zIndex") === 0;
    }

    function inlineLevel(container) {
        return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
    }

    function isStackingContext(container) {
        return (container instanceof StackingContext);
    }

    function hasText(container) {
        return container.node.data.trim().length > 0;
    }

    function noLetterSpacing(container) {
        return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
    }

    function getBorderRadiusData(container) {
        return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
            var value = container.css('border' + side + 'Radius');
            var arr = value.split(" ");
            if (arr.length <= 1) {
                arr[1] = arr[0];
            }
            return arr.map(asInt);
        });
    }

    function renderableNode(node) {
        return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }

    function isPositionedForStacking(container) {
        var position = container.css("position");
        var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
        return zIndex !== "auto";
    }

    function isPositioned(container) {
        return container.css("position") !== "static";
    }

    function isFloating(container) {
        return container.css("float") !== "none";
    }

    function isInlineBlock(container) {
        return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
    }

    function not(callback) {
        var context = this;
        return function() {
            return !callback.apply(context, arguments);
        };
    }

    function isElement(container) {
        return container.node.nodeType === Node.ELEMENT_NODE;
    }

    function isPseudoElement(container) {
        return container.isPseudoElement === true;
    }

    function isTextNode(container) {
        return container.node.nodeType === Node.TEXT_NODE;
    }

    function zIndexSort(contexts) {
        return function(a, b) {
            return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
        };
    }

    function hasOpacity(container) {
        return container.getOpacity() < 1;
    }

    function bind(callback, context) {
        return function() {
            return callback.apply(context, arguments);
        };
    }

    function asInt(value) {
        return parseInt(value, 10);
    }

    function getWidth(border) {
        return border.width;
    }

    function nonIgnoredElement(nodeContainer) {
        return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
    }

    function flatten(arrays) {
        return [].concat.apply([], arrays);
    }

    function stripQuotes(content) {
        var first = content.substr(0, 1);
        return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
    }

    function getWords(characters) {
        var words = [],
            i = 0,
            onWordBoundary = false,
            word;
        while (characters.length) {
            if (isWordBoundary(characters[i]) === onWordBoundary) {
                word = characters.splice(0, i);
                if (word.length) {
                    words.push(window.html2canvas.punycode.ucs2.encode(word));
                }
                onWordBoundary = !onWordBoundary;
                i = 0;
            } else {
                i++;
            }
            if (i >= characters.length) {
                word = characters.splice(0, i);
                if (word.length) {
                    words.push(window.html2canvas.punycode.ucs2.encode(word));
                }
            }
        }
        return words;
    }

    function isWordBoundary(characterCode) {
        return [32, 13, 10, 9, 45].indexOf(characterCode) !== -1;
    }

    function hasUnicode(string) {
        return (/[^\u0000-\u00ff]/).test(string);
    }

    function Proxy(src, proxyUrl, document) {
        if (!proxyUrl) {
            return Promise.reject("No proxy configured");
        }
        var callback = createCallback(supportsCORS);
        var url = createProxyUrl(proxyUrl, src, callback);
        return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
            return decode64(response.content);
        }));
    }
    var proxyCount = 0;
    var supportsCORS = ('withCredentials' in new XMLHttpRequest());
    var supportsCORSImage = ('crossOrigin' in new Image());

    function ProxyURL(src, proxyUrl, document) {
        var callback = createCallback(supportsCORSImage);
        var url = createProxyUrl(proxyUrl, src, callback);
        return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
            return "data:" + response.type + ";base64," + response.content;
        }));
    }

    function jsonp(document, url, callback) {
        return new Promise(function(resolve, reject) {
            var s = document.createElement("script");
            var cleanup = function() {
                delete window.html2canvas.proxy[callback];
                document.body.removeChild(s);
            };
            window.html2canvas.proxy[callback] = function(response) {
                cleanup();
                resolve(response);
            };
            s.src = url;
            s.onerror = function(e) {
                cleanup();
                reject(e);
            };
            document.body.appendChild(s);
        });
    }

    function createCallback(useCORS) {
        return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
    }

    function createProxyUrl(proxyUrl, src, callback) {
        return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
    }

    function ProxyImageContainer(src, proxy) {
        var script = document.createElement("script");
        var link = document.createElement("a");
        link.href = src;
        src = link.href;
        this.src = src;
        this.image = new Image();
        var self = this;
        this.promise = new Promise(function(resolve, reject) {
            self.image.crossOrigin = "Anonymous";
            self.image.onload = resolve;
            self.image.onerror = reject;
            new ProxyURL(src, proxy, document).then(function(url) {
                self.image.src = url;
            })['catch'](reject);
        });
    }

    function PseudoElementContainer(node, parent, type) {
        NodeContainer.call(this, node, parent);
        this.isPseudoElement = true;
        this.before = type === ":before";
    }
    PseudoElementContainer.prototype.cloneTo = function(stack) {
        PseudoElementContainer.prototype.cloneTo.call(this, stack);
        stack.isPseudoElement = true;
        stack.before = this.before;
    };
    PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);
    PseudoElementContainer.prototype.appendToDOM = function() {
        if (this.before) {
            this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
        } else {
            this.parent.node.appendChild(this.node);
        }
        this.parent.node.className += " " + this.getHideClass();
    };
    PseudoElementContainer.prototype.cleanDOM = function() {
        this.node.parentNode.removeChild(this.node);
        this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    };
    PseudoElementContainer.prototype.getHideClass = function() {
        return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    };
    PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
    PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

    function Renderer(width, height, images, options, document) {
        this.width = width;
        this.height = height;
        this.images = images;
        this.options = options;
        this.document = document;
    }
    Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
        var paddingLeft = container.cssInt('paddingLeft'),
            paddingTop = container.cssInt('paddingTop'),
            paddingRight = container.cssInt('paddingRight'),
            paddingBottom = container.cssInt('paddingBottom'),
            borders = borderData.borders;
        var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
        var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
        this.drawImage(imageContainer, 0, 0, imageContainer.image.width || width, imageContainer.image.height || height, bounds.left + paddingLeft + borders[3].width, bounds.top + paddingTop + borders[0].width, width, height);
    };
    Renderer.prototype.renderBackground = function(container, bounds, borderData) {
        if (bounds.height > 0 && bounds.width > 0) {
            this.renderBackgroundColor(container, bounds);
            this.renderBackgroundImage(container, bounds, borderData);
        }
    };
    Renderer.prototype.renderBackgroundColor = function(container, bounds) {
        var color = container.color("backgroundColor");
        if (!color.isTransparent()) {
            this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
        }
    };
    Renderer.prototype.renderBorders = function(borders) {
        borders.forEach(this.renderBorder, this);
    };
    Renderer.prototype.renderBorder = function(data) {
        if (!data.color.isTransparent() && data.args !== null) {
            this.drawShape(data.args, data.color);
        }
    };
    Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
        var backgroundImages = container.parseBackgroundImages();
        backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
            switch (backgroundImage.method) {
                case "url":
                    var image = this.images.get(backgroundImage.args[0]);
                    if (image) {
                        this.renderBackgroundRepeating(container, bounds, image, arr.length - (index + 1), borderData);
                    } else {
                        log("Error loading background-image", backgroundImage.args[0]);
                    }
                    break;
                case "linear-gradient":
                case "gradient":
                    var gradientImage = this.images.get(backgroundImage.value);
                    if (gradientImage) {
                        this.renderBackgroundGradient(gradientImage, bounds, borderData);
                    } else {
                        log("Error loading background-image", backgroundImage.args[0]);
                    }
                    break;
                case "none":
                    break;
                default:
                    log("Unknown background-image type", backgroundImage.args[0]);
            }
        }, this);
    };
    Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
        var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
        var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
        var repeat = container.parseBackgroundRepeat(index);
        switch (repeat) {
            case "repeat-x":
            case "repeat no-repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
                break;
            case "repeat-y":
            case "no-repeat repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
                break;
            case "no-repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
                break;
            default:
                this.renderBackgroundRepeat(imageContainer, position, size, {
                    top: bounds.top,
                    left: bounds.left
                }, borderData[3], borderData[0]);
                break;
        }
    };

    function StackingContext(hasOwnStacking, opacity, element, parent) {
        NodeContainer.call(this, element, parent);
        this.ownStacking = hasOwnStacking;
        this.contexts = [];
        this.children = [];
        this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
    }
    StackingContext.prototype = Object.create(NodeContainer.prototype);
    StackingContext.prototype.getParentStack = function(context) {
        var parentStack = (this.parent) ? this.parent.stack : null;
        return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
    };

    function Support(document) {
        this.rangeBounds = this.testRangeBounds(document);
        this.cors = this.testCORS();
        this.svg = this.testSVG();
    }
    Support.prototype.testRangeBounds = function(document) {
        var range, testElement, rangeBounds, rangeHeight, support = false;
        if (document.createRange) {
            range = document.createRange();
            if (range.getBoundingClientRect) {
                testElement = document.createElement('boundtest');
                testElement.style.height = "123px";
                testElement.style.display = "block";
                document.body.appendChild(testElement);
                range.selectNode(testElement);
                rangeBounds = range.getBoundingClientRect();
                rangeHeight = rangeBounds.height;
                if (rangeHeight === 123) {
                    support = true;
                }
                document.body.removeChild(testElement);
            }
        }
        return support;
    };
    Support.prototype.testCORS = function() {
        return typeof((new Image()).crossOrigin) !== "undefined";
    };
    Support.prototype.testSVG = function() {
        var img = new Image();
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
        } catch (e) {
            return false;
        }
        return true;
    };

    function SVGContainer(src) {
        this.src = src;
        this.image = null;
        var self = this;
        this.promise = this.hasFabric().then(function() {
            return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
        }).then(function(svg) {
            return new Promise(function(resolve) {
                html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
            });
        });
    }
    SVGContainer.prototype.hasFabric = function() {
        return !html2canvas.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
    };
    SVGContainer.prototype.inlineFormatting = function(src) {
        return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
    };
    SVGContainer.prototype.removeContentType = function(src) {
        return src.replace(/^data:image\/svg\+xml(;base64)?,/, '');
    };
    SVGContainer.prototype.isInline = function(src) {
        return (/^data:image\/svg\+xml/i.test(src));
    };
    SVGContainer.prototype.createCanvas = function(resolve) {
        var self = this;
        return function(objects, options) {
            var canvas = new html2canvas.fabric.StaticCanvas('c');
            self.image = canvas.lowerCanvasEl;
            canvas.setWidth(options.width).setHeight(options.height).add(html2canvas.fabric.util.groupSVGElements(objects, options)).renderAll();
            resolve(canvas.lowerCanvasEl);
        };
    };
    SVGContainer.prototype.decode64 = function(str) {
        return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
    };

    function decode64(base64) {
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var len = base64.length,
            i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;
        var output = "";
        for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            byte1 = (encoded1 << 2) | (encoded2 >> 4);
            byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            byte3 = ((encoded3 & 3) << 6) | encoded4;
            if (encoded3 === 64) {
                output += String.fromCharCode(byte1);
            } else if (encoded4 === 64 || encoded4 === -1) {
                output += String.fromCharCode(byte1, byte2);
            } else {
                output += String.fromCharCode(byte1, byte2, byte3);
            }
        }
        return output;
    }

    function SVGNodeContainer(node, native) {
        this.src = node;
        this.image = null;
        var self = this;
        this.promise = native ? new Promise(function(resolve, reject) {
            self.image = new Image();
            self.image.onload = resolve;
            self.image.onerror = reject;
            self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
            if (self.image.complete === true) {
                resolve(self.image);
            }
        }) : this.hasFabric().then(function() {
            return new Promise(function(resolve) {
                html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
            });
        });
    }
    SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

    function TextContainer(node, parent) {
        NodeContainer.call(this, node, parent);
    }
    TextContainer.prototype = Object.create(NodeContainer.prototype);
    TextContainer.prototype.applyTextTransform = function() {
        this.node.data = this.transform(this.parent.css("textTransform"));
    };
    TextContainer.prototype.transform = function(transform) {
        var text = this.node.data;
        switch (transform) {
            case "lowercase":
                return text.toLowerCase();
            case "capitalize":
                return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
            case "uppercase":
                return text.toUpperCase();
            default:
                return text;
        }
    };

    function capitalize(m, p1, p2) {
        if (m.length > 0) {
            return p1 + p2.toUpperCase();
        }
    }

    function WebkitGradientContainer(imageData) {
        GradientContainer.apply(this, arguments);
        this.type = (imageData.args[0] === "linear") ? this.TYPES.LINEAR : this.TYPES.RADIAL;
    }
    WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

    function XHR(url) {
        return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    resolve(xhr.responseText);
                } else {
                    reject(new Error(xhr.statusText));
                }
            };
            xhr.onerror = function() {
                reject(new Error("Network Error"));
            };
            xhr.send();
        });
    }

    function CanvasRenderer(width, height) {
        Renderer.apply(this, arguments);
        this.canvas = this.options.canvas || this.document.createElement("canvas");
        if (!this.options.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }
        this.ctx = this.canvas.getContext("2d");
        this.taintCtx = this.document.createElement("canvas").getContext("2d");
        this.ctx.textBaseline = "bottom";
        this.variables = {};
        log("Initialized CanvasRenderer with size", width, "x", height);
    }
    CanvasRenderer.prototype = Object.create(Renderer.prototype);
    CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
        this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
        return this.ctx;
    };
    CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
        this.setFillStyle(color).fillRect(left, top, width, height);
    };
    CanvasRenderer.prototype.circle = function(left, top, size, color) {
        this.setFillStyle(color);
        this.ctx.beginPath();
        this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI * 2, true);
        this.ctx.closePath();
        this.ctx.fill();
    };
    CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
        this.circle(left, top, size, color);
        this.ctx.strokeStyle = strokeColor.toString();
        this.ctx.stroke();
    };
    CanvasRenderer.prototype.drawShape = function(shape, color) {
        this.shape(shape);
        this.setFillStyle(color).fill();
    };
    CanvasRenderer.prototype.taints = function(imageContainer) {
        if (imageContainer.tainted === null) {
            this.taintCtx.drawImage(imageContainer.image, 0, 0);
            try {
                this.taintCtx.getImageData(0, 0, 1, 1);
                imageContainer.tainted = false;
            } catch (e) {
                this.taintCtx = document.createElement("canvas").getContext("2d");
                imageContainer.tainted = true;
            }
        }
        return imageContainer.tainted;
    };
    CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (!this.taints(imageContainer) || this.options.allowTaint) {
            this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
        }
    };
    CanvasRenderer.prototype.clip = function(shapes, callback, context) {
        this.ctx.save();
        shapes.filter(hasEntries).forEach(function(shape) {
            this.shape(shape).clip();
        }, this);
        callback.call(context);
        this.ctx.restore();
    };
    CanvasRenderer.prototype.shape = function(shape) {
        this.ctx.beginPath();
        shape.forEach(function(point, index) {
            if (point[0] === "rect") {
                this.ctx.rect.apply(this.ctx, point.slice(1));
            } else {
                this.ctx[(index === 0) ? "moveTo" : point[0] + "To"].apply(this.ctx, point.slice(1));
            }
        }, this);
        this.ctx.closePath();
        return this.ctx;
    };
    CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
        this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
    };
    CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
        this.setVariable("shadowColor", color.toString()).setVariable("shadowOffsetY", offsetX).setVariable("shadowOffsetX", offsetY).setVariable("shadowBlur", blur);
    };
    CanvasRenderer.prototype.clearShadow = function() {
        this.setVariable("shadowColor", "rgba(0,0,0,0)");
    };
    CanvasRenderer.prototype.setOpacity = function(opacity) {
        this.ctx.globalAlpha = opacity;
    };
    CanvasRenderer.prototype.setTransform = function(transform) {
        this.ctx.translate(transform.origin[0], transform.origin[1]);
        this.ctx.transform.apply(this.ctx, transform.matrix);
        this.ctx.translate(-transform.origin[0], -transform.origin[1]);
    };
    CanvasRenderer.prototype.setVariable = function(property, value) {
        if (this.variables[property] !== value) {
            this.variables[property] = this.ctx[property] = value;
        }
        return this;
    };
    CanvasRenderer.prototype.text = function(text, left, bottom) {
        this.ctx.fillText(text, left, bottom);
    };
    CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
        var shape = [
            ["line", Math.round(left), Math.round(top)],
            ["line", Math.round(left + width), Math.round(top)],
            ["line", Math.round(left + width), Math.round(height + top)],
            ["line", Math.round(left), Math.round(height + top)]
        ];
        this.clip([shape], function() {
            this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
        }, this);
    };
    CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
        var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft),
            offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
        this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
        this.ctx.translate(offsetX, offsetY);
        this.ctx.fill();
        this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
        if (gradientImage instanceof LinearGradientContainer) {
            var gradient = this.ctx.createLinearGradient(bounds.left + bounds.width * gradientImage.x0, bounds.top + bounds.height * gradientImage.y0, bounds.left + bounds.width * gradientImage.x1, bounds.top + bounds.height * gradientImage.y1);
            gradientImage.colorStops.forEach(function(colorStop) {
                gradient.addColorStop(colorStop.stop, colorStop.color.toString());
            });
            this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
        }
    };
    CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
        var image = imageContainer.image;
        if (image.width === size.width && image.height === size.height) {
            return image;
        }
        var ctx, canvas = document.createElement('canvas');
        canvas.width = size.width;
        canvas.height = size.height;
        ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
        return canvas;
    };

    function hasEntries(array) {
        return array.length > 0;
    }
}).call({}, typeof(window) !== "undefined" ? window : undefined, typeof(document) !== "undefined" ? document : undefined);;
(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.oauthioWeb = f()
    }
})(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    })({
        1: [function(require, module, exports) {
            module.exports = {
                oauthd_url: "https://oauth.io",
                oauthd_api: "https://oauth.io/api",
                version: "web-0.5.1",
                options: {}
            };
        }, {}],
        2: [function(require, module, exports) {
            "use strict";
            module.exports = function(Materia) {
                var $, apiCall;
                $ = Materia.getJquery();
                apiCall = (function(_this) {
                    return function(type, url, params) {
                        var base, defer;
                        defer = $.Deferred();
                        base = Materia.getOAuthdURL();
                        $.ajax({
                            url: base + url,
                            type: type,
                            data: params
                        }).then((function(data) {
                            return defer.resolve(data);
                        }), (function(err) {
                            return defer.reject(err && err.responseJSON);
                        }));
                        return defer.promise();
                    };
                })(this);
                return {
                    get: (function(_this) {
                        return function(url, params) {
                            return apiCall('get', url, params);
                        };
                    })(this),
                    post: (function(_this) {
                        return function(url, params) {
                            return apiCall('post', url, params);
                        };
                    })(this),
                    put: (function(_this) {
                        return function(url, params) {
                            return apiCall('put', url, params);
                        };
                    })(this),
                    del: (function(_this) {
                        return function(url, params) {
                            return apiCall('delete', url, params);
                        };
                    })(this)
                };
            };
        }, {}],
        3: [function(require, module, exports) {
            "use strict";
            var Location, Url, cache, config, cookies, lstorage;
            config = require('../config');
            Url = require("../tools/url");
            Location = require('../tools/location_operations');
            cookies = require("../tools/cookies");
            lstorage = require("../tools/lstorage");
            cache = require("../tools/cache");
            module.exports = function(window, document, jquery, navigator) {
                var Materia, location_operations, storage;
                Url = Url(document);
                location_operations = Location(document);
                storage = lstorage.active() && lstorage || cookies;
                cookies.init(config, document);
                cache.init(storage, config);
                Materia = {
                    initialize: function(public_key, options) {
                        var i;
                        config.key = public_key;
                        if (options) {
                            for (i in options) {
                                config.options[i] = options[i];
                            }
                        }
                    },
                    setOAuthdURL: function(url) {
                        config.oauthd_url = url;
                        config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^\/]+/)[0];
                    },
                    getOAuthdURL: function() {
                        return config.oauthd_url;
                    },
                    getVersion: function() {
                        return config.version;
                    },
                    extend: function(name, module) {
                        return this[name] = module(this);
                    },
                    getConfig: function() {
                        return config;
                    },
                    getWindow: function() {
                        return window;
                    },
                    getDocument: function() {
                        return document;
                    },
                    getNavigator: function() {
                        return navigator;
                    },
                    getJquery: function() {
                        return jquery;
                    },
                    getUrl: function() {
                        return Url;
                    },
                    getCache: function() {
                        return cache;
                    },
                    getStorage: function() {
                        return storage;
                    },
                    getLocationOperations: function() {
                        return location_operations;
                    }
                };
                return Materia;
            };
        }, {
            "../config": 1,
            "../tools/cache": 9,
            "../tools/cookies": 10,
            "../tools/location_operations": 12,
            "../tools/lstorage": 13,
            "../tools/url": 15
        }],
        4: [function(require, module, exports) {
            "use strict";
            var cookies, oauthio_requests, sha1;
            cookies = require("../tools/cookies");
            oauthio_requests = require("./request");
            sha1 = require("../tools/sha1");
            module.exports = function(Materia) {
                var $, Url, cache, client_states, config, document, location_operations, oauth, oauth_result, oauthio, parse_urlfragment, providers_api, window;
                Url = Materia.getUrl();
                config = Materia.getConfig();
                document = Materia.getDocument();
                window = Materia.getWindow();
                $ = Materia.getJquery();
                cache = Materia.getCache();
                providers_api = require('./providers')(Materia);
                config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^\/]+/)[0];
                client_states = [];
                oauth_result = void 0;
                (parse_urlfragment = function() {
                    var cookie_state, results;
                    results = /[\\#&]oauthio=([^&]*)/.exec(document.location.hash);
                    if (results) {
                        document.location.hash = document.location.hash.replace(/&?oauthio=[^&]*/, "");
                        oauth_result = decodeURIComponent(results[1].replace(/\+/g, " "));
                        cookie_state = cookies.read("oauthio_state");
                        if (cookie_state) {
                            client_states.push(cookie_state);
                            cookies.erase("oauthio_state");
                        }
                    }
                })();
                location_operations = Materia.getLocationOperations();
                oauthio = {
                    request: oauthio_requests(Materia, client_states, providers_api)
                };
                oauth = {
                    initialize: function(public_key, options) {
                        return Materia.initialize(public_key, options);
                    },
                    setOAuthdURL: function(url) {
                        config.oauthd_url = url;
                        config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^\/]+/)[0];
                    },
                    create: function(provider, tokens, request) {
                        var i, make_res, make_res_endpoint, res;
                        if (!tokens) {
                            return cache.tryCache(oauth, provider, true);
                        }
                        if (typeof request !== "object") {
                            providers_api.fetchDescription(provider);
                        }
                        make_res = function(method) {
                            return oauthio.request.mkHttp(provider, tokens, request, method);
                        };
                        make_res_endpoint = function(method, url) {
                            return oauthio.request.mkHttpEndpoint(provider, tokens, request, method, url);
                        };
                        res = {};
                        for (i in tokens) {
                            res[i] = tokens[i];
                        }
                        res.toJson = function() {
                            var a;
                            a = {};
                            if (res.access_token != null) {
                                a.access_token = res.access_token;
                            }
                            if (res.oauth_token != null) {
                                a.oauth_token = res.oauth_token;
                            }
                            if (res.oauth_token_secret != null) {
                                a.oauth_token_secret = res.oauth_token_secret;
                            }
                            if (res.expires_in != null) {
                                a.expires_in = res.expires_in;
                            }
                            if (res.token_type != null) {
                                a.token_type = res.token_type;
                            }
                            if (res.id_token != null) {
                                a.id_token = res.id_token;
                            }
                            if (res.provider != null) {
                                a.provider = res.provider;
                            }
                            if (res.email != null) {
                                a.email = res.email;
                            }
                            return a;
                        };
                        res.get = make_res("GET");
                        res.post = make_res("POST");
                        res.put = make_res("PUT");
                        res.patch = make_res("PATCH");
                        res.del = make_res("DELETE");
                        res.me = oauthio.request.mkHttpMe(provider, tokens, request, "GET");
                        return res;
                    },
                    popup: function(provider, opts, callback) {
                        var defer, frm, getMessage, gotmessage, interval, res, url, wnd, wndTimeout, wnd_options, wnd_settings;
                        gotmessage = false;
                        getMessage = function(e) {
                            if (!gotmessage) {
                                if (e.origin !== config.oauthd_base) {
                                    return;
                                }
                                try {
                                    wnd.close();
                                } catch (_error) {}
                                opts.data = e.data;
                                oauthio.request.sendCallback(opts, defer);
                                return gotmessage = true;
                            }
                        };
                        wnd = void 0;
                        frm = void 0;
                        wndTimeout = void 0;
                        defer = $.Deferred();
                        opts = opts || {};
                        if (!config.key) {
                            if (defer != null) {
                                defer.reject(new Error("OAuth object must be initialized"));
                            }
                            if (callback == null) {
                                return defer.promise();
                            } else {
                                return callback(new Error("OAuth object must be initialized"));
                            }
                        }
                        if (arguments.length === 2 && typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        if (cache.cacheEnabled(opts.cache)) {
                            res = cache.tryCache(oauth, provider, opts.cache);
                            if (res) {
                                if (defer != null) {
                                    defer.resolve(res);
                                }
                                if (callback) {
                                    return callback(null, res);
                                } else {
                                    return defer.promise();
                                }
                            }
                        }
                        if (!opts.state) {
                            opts.state = sha1.create_hash();
                            opts.state_type = "client";
                        }
                        client_states.push(opts.state);
                        url = config.oauthd_url + "/auth/" + provider + "?k=" + config.key;
                        url += "&d=" + encodeURIComponent(Url.getAbsUrl("/"));
                        if (opts) {
                            url += "&opts=" + encodeURIComponent(JSON.stringify(opts));
                        }
                        if (opts.wnd_settings) {
                            wnd_settings = opts.wnd_settings;
                            delete opts.wnd_settings;
                        } else {
                            wnd_settings = {
                                width: Math.floor(window.outerWidth * 0.8),
                                height: Math.floor(window.outerHeight * 0.5)
                            };
                        }
                        if (wnd_settings.width < 1000) {
                            wnd_settings.width = 1000;
                        }
                        if (wnd_settings.height < 630) {
                            wnd_settings.height = 630;
                        }
                        wnd_settings.left = Math.floor(window.screenX + (window.outerWidth - wnd_settings.width) / 2);
                        wnd_settings.top = Math.floor(window.screenY + (window.outerHeight - wnd_settings.height) / 8);
                        wnd_options = "width=" + wnd_settings.width + ",height=" + wnd_settings.height;
                        wnd_options += ",toolbar=0,scrollbars=1,status=1,resizable=1,location=1,menuBar=0";
                        wnd_options += ",left=" + wnd_settings.left + ",top=" + wnd_settings.top;
                        opts = {
                            provider: provider,
                            cache: opts.cache
                        };
                        opts.callback = function(e, r) {
                            if (window.removeEventListener) {
                                window.removeEventListener("message", getMessage, false);
                            } else if (window.detachEvent) {
                                window.detachEvent("onmessage", getMessage);
                            } else {
                                if (document.detachEvent) {
                                    document.detachEvent("onmessage", getMessage);
                                }
                            }
                            opts.callback = function() {};
                            if (wndTimeout) {
                                clearTimeout(wndTimeout);
                                wndTimeout = undefined;
                            }
                            if (callback) {
                                return callback(e, r);
                            } else {
                                return undefined;
                            }
                        };
                        if (window.attachEvent) {
                            window.attachEvent("onmessage", getMessage);
                        } else if (document.attachEvent) {
                            document.attachEvent("onmessage", getMessage);
                        } else {
                            if (window.addEventListener) {
                                window.addEventListener("message", getMessage, false);
                            }
                        }
                        if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.onMessageExternal) {
                            chrome.runtime.onMessageExternal.addListener(function(request, sender, sendResponse) {
                                request.origin = sender.url.match(/^.{2,5}:\/\/[^\/]+/)[0];
                                return getMessage(request);
                            });
                        }
                        if (!frm && (navigator.userAgent.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf("Trident/") > 0)) {
                            frm = document.createElement("iframe");
                            frm.src = config.oauthd_url + "/auth/iframe?d=" + encodeURIComponent(Url.getAbsUrl("/"));
                            frm.width = 0;
                            frm.height = 0;
                            frm.frameBorder = 0;
                            frm.style.visibility = "hidden";
                            document.body.appendChild(frm);
                        }
                        wndTimeout = setTimeout(function() {
                            if (defer != null) {
                                defer.reject(new Error("Authorization timed out"));
                            }
                            if (opts.callback && typeof opts.callback === "function") {
                                opts.callback(new Error("Authorization timed out"));
                            }
                            try {
                                wnd.close();
                            } catch (_error) {}
                        }, 1200 * 1000);
                        wnd = window.open(url, "Authorization", wnd_options);
                        if (wnd) {
                            wnd.focus();
                            interval = window.setInterval(function() {
                                if (wnd === null || wnd.closed) {
                                    window.clearInterval(interval);
                                    if (!gotmessage) {
                                        if (defer != null) {
                                            defer.reject(new Error("The popup was closed"));
                                        }
                                        if (opts.callback && typeof opts.callback === "function") {
                                            return opts.callback(new Error("The popup was closed"));
                                        }
                                    }
                                }
                            }, 500);
                        } else {
                            if (defer != null) {
                                defer.reject(new Error("Could not open a popup"));
                            }
                            if (opts.callback && typeof opts.callback === "function") {
                                opts.callback(new Error("Could not open a popup"));
                            }
                        }
                        return defer != null ? defer.promise() : void 0;
                    },
                    redirect: function(provider, opts, url) {
                        var redirect_uri, res;
                        if (arguments.length === 2) {
                            url = opts;
                            opts = {};
                        }
                        if (typeof url !== 'string') {
                            throw new Error('You must specify an url');
                        }
                        if (cache.cacheEnabled(opts.cache)) {
                            res = cache.tryCache(oauth, provider, opts.cache);
                            if (res) {
                                url = Url.getAbsUrl(url) + (url.indexOf("#") === -1 ? "#" : "&") + "oauthio=cache:" + provider;
                                location_operations.changeHref(url);
                                location_operations.reload();
                                return;
                            }
                        }
                        if (!opts.state) {
                            opts.state = sha1.create_hash();
                            opts.state_type = "client";
                        }
                        cookies.create("oauthio_state", opts.state);
                        redirect_uri = encodeURIComponent(Url.getAbsUrl(url));
                        url = config.oauthd_url + "/auth/" + provider + "?k=" + config.key;
                        url += "&redirect_uri=" + redirect_uri;
                        if (opts) {
                            url += "&opts=" + encodeURIComponent(JSON.stringify(opts));
                        }
                        location_operations.changeHref(url);
                    },
                    isRedirect: function(provider) {
                        var cache_provider, data, e;
                        if (oauth_result == null) {
                            return false;
                        }
                        if ((oauth_result != null ? oauth_result.substr(0, 6) : void 0) === "cache:") {
                            cache_provider = oauth_result != null ? oauth_result.substr(6) : void 0;
                            if (!provider) {
                                return cache_provider;
                            }
                            return cache_provider.toLowerCase() === provider.toLowerCase();
                        }
                        try {
                            data = JSON.parse(oauth_result);
                        } catch (_error) {
                            e = _error;
                            return false;
                        }
                        if (provider) {
                            return data.provider.toLowerCase() === provider.toLowerCase();
                        }
                        return data.provider;
                    },
                    callback: function(provider, opts, callback) {
                        var defer, err, res;
                        defer = $.Deferred();
                        if (arguments.length === 1 && typeof provider === "function") {
                            callback = provider;
                            provider = undefined;
                            opts = {};
                        }
                        if (arguments.length === 1 && typeof provider === "string") {
                            opts = {};
                        }
                        if (arguments.length === 2 && typeof opts === "function") {
                            callback = opts;
                            opts = {};
                        }
                        if (cache.cacheEnabled(opts != null ? opts.cache : void 0) || (oauth_result != null ? oauth_result.substr(0, 6) : void 0) === "cache:") {
                            if (!provider && (oauth_result != null ? oauth_result.substr(0, 6) : void 0) === "cache:") {
                                provider = oauth_result.substr(6);
                            }
                            res = cache.tryCache(oauth, provider, true);
                            if (res) {
                                if (callback) {
                                    if (res) {
                                        return callback(null, res);
                                    }
                                } else {
                                    if (defer != null) {
                                        defer.resolve(res);
                                    }
                                    return defer != null ? defer.promise() : void 0;
                                }
                            } else if ((oauth_result != null ? oauth_result.substr(0, 6) : void 0) === "cache:") {
                                err = new Error('Could not fetch data from cache');
                                if (callback) {
                                    return callback(err);
                                } else {
                                    if (defer != null) {
                                        defer.reject(err);
                                    }
                                    return defer != null ? defer.promise() : void 0;
                                }
                            }
                        }
                        if (!oauth_result) {
                            return;
                        }
                        oauthio.request.sendCallback({
                            data: oauth_result,
                            provider: provider,
                            cache: opts != null ? opts.cache : void 0,
                            expires: opts != null ? opts.expires : void 0,
                            callback: callback
                        }, defer);
                        return defer != null ? defer.promise() : void 0;
                    },
                    clearCache: function(provider) {
                        return cache.clearCache(provider);
                    },
                    http_me: function(opts) {
                        if (oauthio.request.http_me) {
                            oauthio.request.http_me(opts);
                        }
                    },
                    http: function(opts) {
                        if (oauthio.request.http) {
                            oauthio.request.http(opts);
                        }
                    },
                    getVersion: function() {
                        return Materia.getVersion.apply(this);
                    }
                };
                return oauth;
            };
        }, {
            "../tools/cookies": 10,
            "../tools/sha1": 14,
            "./providers": 5,
            "./request": 6
        }],
        5: [function(require, module, exports) {
            "use strict";
            var config;
            config = require("../config");
            module.exports = function(Materia) {
                var $, providers_api, providers_cb, providers_desc;
                $ = Materia.getJquery();
                providers_desc = {};
                providers_cb = {};
                providers_api = {
                    execProvidersCb: function(provider, e, r) {
                        var cbs, i;
                        if (providers_cb[provider]) {
                            cbs = providers_cb[provider];
                            delete providers_cb[provider];
                            for (i in cbs) {
                                cbs[i](e, r);
                            }
                        }
                    },
                    fetchDescription: function(provider) {
                        if (providers_desc[provider]) {
                            return;
                        }
                        providers_desc[provider] = true;
                        $.ajax({
                            url: config.oauthd_api + "/providers/" + provider,
                            data: {
                                extend: true
                            },
                            dataType: "json"
                        }).done(function(data) {
                            providers_desc[provider] = data.data;
                            providers_api.execProvidersCb(provider, null, data.data);
                        }).always(function() {
                            if (typeof providers_desc[provider] !== "object") {
                                delete providers_desc[provider];
                                providers_api.execProvidersCb(provider, new Error("Unable to fetch request description"));
                            }
                        });
                    },
                    getDescription: function(provider, opts, callback) {
                        opts = opts || {};
                        if (typeof providers_desc[provider] === "object") {
                            return callback(null, providers_desc[provider]);
                        }
                        if (!providers_desc[provider]) {
                            providers_api.fetchDescription(provider);
                        }
                        if (!opts.wait) {
                            return callback(null, {});
                        }
                        providers_cb[provider] = providers_cb[provider] || [];
                        providers_cb[provider].push(callback);
                    }
                };
                return providers_api;
            };
        }, {
            "../config": 1
        }],
        6: [function(require, module, exports) {
            "use strict";
            var Url, indexOf = [].indexOf || function(item) {
                for (var i = 0, l = this.length; i < l; i++) {
                    if (i in this && this[i] === item) return i;
                }
                return -1;
            };
            Url = require('../tools/url')();
            module.exports = function(Materia, client_states, providers_api) {
                var $, cache, config, extended_methods, fetched_methods;
                $ = Materia.getJquery();
                config = Materia.getConfig();
                cache = Materia.getCache();
                extended_methods = [];
                fetched_methods = false;
                return {
                    retrieveMethods: function() {
                        var defer;
                        defer = $.Deferred();
                        if (!fetched_methods) {
                            $.ajax(config.oauthd_url + '/api/extended-endpoints').then(function(data) {
                                extended_methods = data.data;
                                fetched_methods = true;
                                return defer.resolve();
                            }).fail(function(e) {
                                fetched_methods = true;
                                return defer.reject(e);
                            });
                        } else {
                            defer.resolve(extended_methods);
                        }
                        return defer.promise();
                    },
                    generateMethods: function(request_object, tokens, provider) {
                        var j, k, kk, len, name_array, pt, results, v, vv;
                        if (extended_methods != null) {
                            results = [];
                            for (k = j = 0, len = extended_methods.length; j < len; k = ++j) {
                                v = extended_methods[k];
                                name_array = v.name.split('.');
                                pt = request_object;
                                results.push((function() {
                                    var l, len1, results1;
                                    results1 = [];
                                    for (kk = l = 0, len1 = name_array.length; l < len1; kk = ++l) {
                                        vv = name_array[kk];
                                        if (kk < name_array.length - 1) {
                                            if (pt[vv] == null) {
                                                pt[vv] = {};
                                            }
                                            results1.push(pt = pt[vv]);
                                        } else {
                                            results1.push(pt[vv] = this.mkHttpAll(provider, tokens, v, arguments));
                                        }
                                    }
                                    return results1;
                                }).apply(this, arguments));
                            }
                            return results;
                        }
                    },
                    http: function(opts) {
                        var defer, desc_opts, doRequest, i, options;
                        doRequest = function() {
                            var i, k, qs, request;
                            request = options.oauthio.request || {};
                            if (!request.cors) {
                                options.url = encodeURIComponent(options.url);
                                if (options.url[0] !== "/") {
                                    options.url = "/" + options.url;
                                }
                                options.url = config.oauthd_url + "/request/" + options.oauthio.provider + options.url;
                                options.headers = options.headers || {};
                                options.headers.oauthio = "k=" + config.key;
                                if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
                                    options.headers.oauthio += "&oauthv=1";
                                }
                                for (k in options.oauthio.tokens) {
                                    options.headers.oauthio += "&" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);
                                }
                                delete options.oauthio;
                                return $.ajax(options);
                            }
                            if (options.oauthio.tokens) {
                                if (options.oauthio.tokens.access_token) {
                                    options.oauthio.tokens.token = options.oauthio.tokens.access_token;
                                }
                                if (!options.url.match(/^[a-z]{2,16}:\/\//)) {
                                    if (options.url[0] !== "/") {
                                        options.url = "/" + options.url;
                                    }
                                    options.url = request.url + options.url;
                                }
                                options.url = Url.replaceParam(options.url, options.oauthio.tokens, request.parameters);
                                if (request.query) {
                                    qs = [];
                                    for (i in request.query) {
                                        qs.push(encodeURIComponent(i) + "=" + encodeURIComponent(Url.replaceParam(request.query[i], options.oauthio.tokens, request.parameters)));
                                    }
                                    if (indexOf.call(options.url, "?") >= 0) {
                                        options.url += "&" + qs;
                                    } else {
                                        options.url += "?" + qs;
                                    }
                                }
                                if (request.headers) {
                                    options.headers = options.headers || {};
                                    for (i in request.headers) {
                                        options.headers[i] = Url.replaceParam(request.headers[i], options.oauthio.tokens, request.parameters);
                                    }
                                }
                                delete options.oauthio;
                                return $.ajax(options);
                            }
                        };
                        options = {};
                        i = void 0;
                        for (i in opts) {
                            options[i] = opts[i];
                        }
                        if (!options.oauthio.request || options.oauthio.request === true) {
                            desc_opts = {
                                wait: !!options.oauthio.request
                            };
                            defer = $.Deferred();
                            providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {
                                if (e) {
                                    return defer.reject(e);
                                }
                                if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
                                    options.oauthio.request = desc.oauth1 && desc.oauth1.request;
                                } else {
                                    options.oauthio.request = desc.oauth2 && desc.oauth2.request;
                                }
                                defer.resolve();
                            });
                            return defer.then(doRequest);
                        } else {
                            return doRequest();
                        }
                    },
                    http_me: function(opts) {
                        var defer, desc_opts, doRequest, k, options;
                        doRequest = function() {
                            var defer, k, promise, request;
                            defer = $.Deferred();
                            request = options.oauthio.request || {};
                            options.url = config.oauthd_url + "/auth/" + options.oauthio.provider + "/me";
                            options.headers = options.headers || {};
                            options.headers.oauthio = "k=" + config.key;
                            if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
                                options.headers.oauthio += "&oauthv=1";
                            }
                            for (k in options.oauthio.tokens) {
                                options.headers.oauthio += "&" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);
                            }
                            delete options.oauthio;
                            promise = $.ajax(options);
                            $.when(promise).done(function(data) {
                                defer.resolve(data.data);
                            }).fail(function(data) {
                                if (data.responseJSON) {
                                    defer.reject(data.responseJSON.data);
                                } else {
                                    defer.reject(new Error("An error occured while trying to access the resource"));
                                }
                            });
                            return defer.promise();
                        };
                        options = {};
                        for (k in opts) {
                            options[k] = opts[k];
                        }
                        if (!options.oauthio.request || options.oauthio.request === true) {
                            desc_opts = {
                                wait: !!options.oauthio.request
                            };
                            defer = $.Deferred();
                            providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {
                                if (e) {
                                    return defer.reject(e);
                                }
                                if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
                                    options.oauthio.request = desc.oauth1 && desc.oauth1.request;
                                } else {
                                    options.oauthio.request = desc.oauth2 && desc.oauth2.request;
                                }
                                defer.resolve();
                            });
                            return defer.then(doRequest);
                        } else {
                            return doRequest();
                        }
                    },
                    http_all: function(options, endpoint_descriptor, parameters) {
                        var doRequest;
                        doRequest = function() {
                            var defer, k, promise, request;
                            defer = $.Deferred();
                            request = options.oauthio.request || {};
                            options.headers = options.headers || {};
                            options.headers.oauthio = "k=" + config.key;
                            if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
                                options.headers.oauthio += "&oauthv=1";
                            }
                            for (k in options.oauthio.tokens) {
                                options.headers.oauthio += "&" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);
                            }
                            delete options.oauthio;
                            promise = $.ajax(options);
                            $.when(promise).done(function(data) {
                                var error;
                                if (typeof data.data === 'string') {
                                    try {
                                        data.data = JSON.parse(data.data);
                                    } catch (_error) {
                                        error = _error;
                                        data.data = data.data;
                                    } finally {
                                        defer.resolve(data.data);
                                    }
                                }
                            }).fail(function(data) {
                                if (data.responseJSON) {
                                    defer.reject(data.responseJSON.data);
                                } else {
                                    defer.reject(new Error("An error occured while trying to access the resource"));
                                }
                            });
                            return defer.promise();
                        };
                        return doRequest();
                    },
                    mkHttp: function(provider, tokens, request, method) {
                        var base;
                        base = this;
                        return function(opts, opts2) {
                            var i, options;
                            options = {};
                            if (typeof opts === "string") {
                                if (typeof opts2 === "object") {
                                    for (i in opts2) {
                                        options[i] = opts2[i];
                                    }
                                }
                                options.url = opts;
                            } else if (typeof opts === "object") {
                                for (i in opts) {
                                    options[i] = opts[i];
                                }
                            }
                            options.type = options.type || method;
                            options.oauthio = {
                                provider: provider,
                                tokens: tokens,
                                request: request
                            };
                            return base.http(options);
                        };
                    },
                    mkHttpMe: function(provider, tokens, request, method) {
                        var base;
                        base = this;
                        return function(filter) {
                            var options;
                            options = {};
                            options.type = options.type || method;
                            options.oauthio = {
                                provider: provider,
                                tokens: tokens,
                                request: request
                            };
                            options.data = options.data || {};
                            if (filter) {
                                options.data.filter = filter.join(",");
                            }
                            return base.http_me(options);
                        };
                    },
                    mkHttpAll: function(provider, tokens, endpoint_descriptor) {
                        var base;
                        base = this;
                        return function() {
                            var k, options, th_param, v;
                            options = {};
                            options.type = endpoint_descriptor.method;
                            options.url = config.oauthd_url + endpoint_descriptor.endpoint.replace(':provider', provider);
                            options.oauthio = {
                                provider: provider,
                                tokens: tokens
                            };
                            options.data = {};
                            for (k in arguments) {
                                v = arguments[k];
                                th_param = endpoint_descriptor.params[k];
                                if (th_param != null) {
                                    options.data[th_param.name] = v;
                                }
                            }
                            options.data = options.data || {};
                            return base.http_all(options, endpoint_descriptor, arguments);
                        };
                    },
                    sendCallback: function(opts, defer) {
                        var base, data, e, err, i, make_res, request, res, tokens;
                        base = this;
                        data = void 0;
                        err = void 0;
                        try {
                            data = JSON.parse(opts.data);
                        } catch (_error) {
                            e = _error;
                            defer.reject(new Error("Error while parsing result"));
                            return opts.callback(new Error("Error while parsing result"));
                        }
                        if (!data || !data.provider) {
                            return;
                        }
                        if (opts.provider && data.provider.toLowerCase() !== opts.provider.toLowerCase()) {
                            err = new Error("Returned provider name does not match asked provider");
                            defer.reject(err);
                            if (opts.callback && typeof opts.callback === "function") {
                                return opts.callback(err);
                            } else {
                                return;
                            }
                        }
                        if (data.status === "error" || data.status === "fail") {
                            err = new Error(data.message);
                            err.body = data.data;
                            defer.reject(err);
                            if (opts.callback && typeof opts.callback === "function") {
                                return opts.callback(err);
                            } else {
                                return;
                            }
                        }
                        if (data.status !== "success" || !data.data) {
                            err = new Error();
                            err.body = data.data;
                            defer.reject(err);
                            if (opts.callback && typeof opts.callback === "function") {
                                return opts.callback(err);
                            } else {
                                return;
                            }
                        }
                        data.state = data.state.replace(/\s+/g, "");
                        i = 0;
                        while (i < client_states.length) {
                            client_states[i] = client_states[i].replace(/\s+/g, "");
                            i++;
                        }
                        if (!data.state || client_states.indexOf(data.state) === -1) {
                            defer.reject(new Error("State is not matching"));
                            if (opts.callback && typeof opts.callback === "function") {
                                return opts.callback(new Error("State is not matching"));
                            } else {
                                return;
                            }
                        }
                        if (!opts.provider) {
                            data.data.provider = data.provider;
                        }
                        res = data.data;
                        res.provider = data.provider.toLowerCase();
                        if (cache.cacheEnabled(opts.cache) && res) {
                            if (opts.expires && !res.expires_in) {
                                res.expires_in = opts.expires;
                            }
                            cache.storeCache(data.provider, res);
                        }
                        request = res.request;
                        delete res.request;
                        tokens = void 0;
                        if (res.access_token) {
                            tokens = {
                                access_token: res.access_token
                            };
                        } else if (res.oauth_token && res.oauth_token_secret) {
                            tokens = {
                                oauth_token: res.oauth_token,
                                oauth_token_secret: res.oauth_token_secret
                            };
                        }
                        if (!request) {
                            defer.resolve(res);
                            if (opts.callback && typeof opts.callback === "function") {
                                return opts.callback(null, res);
                            } else {
                                return;
                            }
                        }
                        if (request.required) {
                            for (i in request.required) {
                                tokens[request.required[i]] = res[request.required[i]];
                            }
                        }
                        make_res = function(method) {
                            return base.mkHttp(data.provider, tokens, request, method);
                        };
                        res.toJson = function() {
                            var a;
                            a = {};
                            if (res.access_token != null) {
                                a.access_token = res.access_token;
                            }
                            if (res.oauth_token != null) {
                                a.oauth_token = res.oauth_token;
                            }
                            if (res.oauth_token_secret != null) {
                                a.oauth_token_secret = res.oauth_token_secret;
                            }
                            if (res.expires_in != null) {
                                a.expires_in = res.expires_in;
                            }
                            if (res.token_type != null) {
                                a.token_type = res.token_type;
                            }
                            if (res.id_token != null) {
                                a.id_token = res.id_token;
                            }
                            if (res.provider != null) {
                                a.provider = res.provider;
                            }
                            if (res.email != null) {
                                a.email = res.email;
                            }
                            return a;
                        };
                        res.get = make_res("GET");
                        res.post = make_res("POST");
                        res.put = make_res("PUT");
                        res.patch = make_res("PATCH");
                        res.del = make_res("DELETE");
                        res.me = base.mkHttpMe(data.provider, tokens, request, "GET");
                        return this.retrieveMethods().then((function(_this) {
                            return function() {
                                _this.generateMethods(res, tokens, data.provider);
                                defer.resolve(res);
                                if (opts.callback && typeof opts.callback === "function") {
                                    return opts.callback(null, res);
                                } else {}
                            };
                        })(this)).fail((function(_this) {
                            return function(e) {
                                console.log('Could not retrieve methods', e);
                                defer.resolve(res);
                                if (opts.callback && typeof opts.callback === "function") {
                                    return opts.callback(null, res);
                                } else {}
                            };
                        })(this));
                    }
                };
            };
        }, {
            "../tools/url": 15
        }],
        7: [function(require, module, exports) {
            "use strict";
            module.exports = function(Materia) {
                var $, UserObject, config, lastSave, storage;
                $ = Materia.getJquery();
                config = Materia.getConfig();
                storage = Materia.getStorage();
                lastSave = null;
                UserObject = (function() {
                    function UserObject(data) {
                        this.token = data.token;
                        this.data = data.user;
                        this.providers = data.providers;
                        lastSave = this.getEditableData();
                    }
                    UserObject.prototype.getEditableData = function() {
                        var data, key;
                        data = [];
                        for (key in this.data) {
                            if (['id', 'email'].indexOf(key) === -1) {
                                data.push({
                                    key: key,
                                    value: this.data[key]
                                });
                            }
                        }
                        return data;
                    };
                    UserObject.prototype.save = function() {
                        var d, dataToSave, i, j, keyIsInLastSave, len, len1, ref;
                        dataToSave = {};
                        for (i = 0, len = lastSave.length; i < len; i++) {
                            d = lastSave[i];
                            if (this.data[d.key] !== d.value) {
                                dataToSave[d.key] = this.data[d.key];
                            }
                            if (this.data[d.key] === null) {
                                delete this.data[d.key];
                            }
                        }
                        keyIsInLastSave = function(key) {
                            var j, len1, o;
                            for (j = 0, len1 = lastSave.length; j < len1; j++) {
                                o = lastSave[j];
                                if (o.key === key) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        ref = this.getEditableData();
                        for (j = 0, len1 = ref.length; j < len1; j++) {
                            d = ref[j];
                            if (!keyIsInLastSave(d.key)) {
                                dataToSave[d.key] = this.data[d.key];
                            }
                        }
                        this.saveLocal();
                        return Materia.API.put('/api/usermanagement/user?k=' + config.key + '&token=' + this.token, dataToSave);
                    };
                    UserObject.prototype.select = function(provider) {
                        var OAuthResult;
                        OAuthResult = null;
                        return OAuthResult;
                    };
                    UserObject.prototype.saveLocal = function() {
                        var copy;
                        copy = {
                            token: this.token,
                            user: this.data,
                            providers: this.providers
                        };
                        storage.erase('oio_auth');
                        return storage.create('oio_auth', JSON.stringify(copy), 21600);
                    };
                    UserObject.prototype.hasProvider = function(provider) {
                        var ref;
                        return ((ref = this.providers) != null ? ref.indexOf(provider) : void 0) !== -1;
                    };
                    UserObject.prototype.getProviders = function() {
                        var defer;
                        defer = $.Deferred();
                        Materia.API.get('/api/usermanagement/user/providers?k=' + config.key + '&token=' + this.token).done((function(_this) {
                            return function(providers) {
                                _this.providers = providers.data;
                                _this.saveLocal();
                                return defer.resolve(_this.providers);
                            };
                        })(this)).fail(function(err) {
                            return defer.reject(err);
                        });
                        return defer.promise();
                    };
                    UserObject.prototype.addProvider = function(oauthRes) {
                        var defer;
                        defer = $.Deferred();
                        if (typeof oauthRes.toJson === 'function') {
                            oauthRes = oauthRes.toJson();
                        }
                        oauthRes.email = this.data.email;
                        this.providers.push(oauthRes.provider);
                        Materia.API.post('/api/usermanagement/user/providers?k=' + config.key + '&token=' + this.token, oauthRes).done((function(_this) {
                            return function(res) {
                                _this.data = res.data;
                                _this.saveLocal();
                                return defer.resolve();
                            };
                        })(this)).fail((function(_this) {
                            return function(err) {
                                _this.providers.splice(_this.providers.indexOf(oauthRes.provider), 1);
                                return defer.reject(err);
                            };
                        })(this));
                        return defer.promise();
                    };
                    UserObject.prototype.removeProvider = function(provider) {
                        var defer;
                        defer = $.Deferred();
                        this.providers.splice(this.providers.indexOf(provider), 1);
                        Materia.API.del('/api/usermanagement/user/providers/' + provider + '?k=' + config.key + '&token=' + this.token).done((function(_this) {
                            return function(res) {
                                _this.saveLocal();
                                return defer.resolve(res);
                            };
                        })(this)).fail((function(_this) {
                            return function(err) {
                                _this.providers.push(provider);
                                return defer.reject(err);
                            };
                        })(this));
                        return defer.promise();
                    };
                    UserObject.prototype.changePassword = function(oldPassword, newPassword) {
                        return Materia.API.post('/api/usermanagement/user/password?k=' + config.key + '&token=' + this.token, {
                            password: newPassword
                        });
                    };
                    UserObject.prototype.isLoggued = function() {
                        return Materia.User.isLogged();
                    };
                    UserObject.prototype.isLogged = function() {
                        return Materia.User.isLogged();
                    };
                    UserObject.prototype.logout = function() {
                        var defer;
                        defer = $.Deferred();
                        storage.erase('oio_auth');
                        Materia.API.post('/api/usermanagement/user/logout?k=' + config.key + '&token=' + this.token).done(function() {
                            return defer.resolve();
                        }).fail(function(err) {
                            return defer.reject(err);
                        });
                        return defer.promise();
                    };
                    return UserObject;
                })();
                return {
                    initialize: function(public_key, options) {
                        return Materia.initialize(public_key, options);
                    },
                    setOAuthdURL: function(url) {
                        return Materia.setOAuthdURL(url);
                    },
                    signup: function(data) {
                        var defer;
                        defer = $.Deferred();
                        if (typeof data.toJson === 'function') {
                            data = data.toJson();
                        }
                        Materia.API.post('/api/usermanagement/signup?k=' + config.key, data).done(function(res) {
                            storage.create('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);
                            return defer.resolve(new UserObject(res.data));
                        }).fail(function(err) {
                            return defer.reject(err);
                        });
                        return defer.promise();
                    },
                    signin: function(email, password) {
                        var defer, signinData;
                        defer = $.Deferred();
                        if (typeof email !== "string" && !password) {
                            signinData = email;
                            if (typeof signinData.toJson === 'function') {
                                signinData = signinData.toJson();
                            }
                            Materia.API.post('/api/usermanagement/signin?k=' + config.key, signinData).done(function(res) {
                                storage.create('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);
                                return defer.resolve(new UserObject(res.data));
                            }).fail(function(err) {
                                return defer.reject(err);
                            });
                        } else {
                            Materia.API.post('/api/usermanagement/signin?k=' + config.key, {
                                email: email,
                                password: password
                            }).done(function(res) {
                                storage.create('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);
                                return defer.resolve(new UserObject(res.data));
                            }).fail(function(err) {
                                return defer.reject(err);
                            });
                        }
                        return defer.promise();
                    },
                    confirmResetPassword: function(newPassword, sptoken) {
                        return Materia.API.post('/api/usermanagement/user/password?k=' + config.key, {
                            password: newPassword,
                            token: sptoken
                        });
                    },
                    resetPassword: function(email, callback) {
                        return Materia.API.post('/api/usermanagement/user/password/reset?k=' + config.key, {
                            email: email
                        });
                    },
                    refreshIdentity: function() {
                        var defer;
                        defer = $.Deferred();
                        Materia.API.get('/api/usermanagement/user?k=' + config.key + '&token=' + JSON.parse(storage.read('oio_auth')).token).done(function(res) {
                            return defer.resolve(new UserObject(res.data));
                        }).fail(function(err) {
                            return defer.reject(err);
                        });
                        return defer.promise();
                    },
                    getIdentity: function() {
                        var user;
                        user = storage.read('oio_auth');
                        if (!user) {
                            return null;
                        }
                        return new UserObject(JSON.parse(user));
                    },
                    isLogged: function() {
                        var a;
                        a = storage.read('oio_auth');
                        if (a) {
                            return true;
                        }
                        return false;
                    }
                };
            };
        }, {}],
        8: [function(require, module, exports) {
            (function() {
                var Materia, jquery;
                jquery = require('./tools/jquery-lite.js');
                Materia = require('./lib/core')(window, document, jquery, navigator);
                Materia.extend('OAuth', require('./lib/oauth'));
                Materia.extend('API', require('./lib/api'));
                Materia.extend('User', require('./lib/user'));
                if (typeof angular !== "undefined" && angular !== null) {
                    angular.module('oauthio', []).factory('Materia', [function() {
                        return Materia;
                    }]).factory('OAuth', [function() {
                        return Materia.OAuth;
                    }]).factory('User', [function() {
                        return Materia.User;
                    }]);
                }
                window.Materia = exports.Materia = Materia;
                window.User = exports.User = exports.Materia.User;
                window.OAuth = exports.OAuth = exports.Materia.OAuth;
                if (typeof define === 'function' && define.amd) {
                    define(function() {
                        return exports;
                    });
                }
                if ((typeof module !== "undefined" && module !== null ? module.exports : void 0)) {
                    module.exports = exports;
                }
                return exports;
            })();
        }, {
            "./lib/api": 2,
            "./lib/core": 3,
            "./lib/oauth": 4,
            "./lib/user": 7,
            "./tools/jquery-lite.js": 11
        }],
        9: [function(require, module, exports) {
            "use strict";
            module.exports = {
                init: function(storage, config) {
                    this.config = config;
                    return this.storage = storage;
                },
                tryCache: function(OAuth, provider, cache) {
                    var e, i, res;
                    if (this.cacheEnabled(cache)) {
                        cache = this.storage.read("oauthio_provider_" + provider);
                        if (!cache) {
                            return false;
                        }
                        cache = decodeURIComponent(cache);
                    }
                    if (typeof cache === "string") {
                        try {
                            cache = JSON.parse(cache);
                        } catch (_error) {
                            e = _error;
                            return false;
                        }
                    }
                    if (typeof cache === "object") {
                        res = {};
                        for (i in cache) {
                            if (i !== "request" && typeof cache[i] !== "function") {
                                res[i] = cache[i];
                            }
                        }
                        return OAuth.create(provider, res, cache.request);
                    }
                    return false;
                },
                storeCache: function(provider, cache) {
                    var expires;
                    expires = 3600;
                    if (cache.expires_in) {
                        expires = cache.expires_in;
                    } else if (this.config.options.expires || this.config.options.expires === false) {
                        expires = this.config.options.expires;
                    }
                    this.storage.create("oauthio_provider_" + provider, encodeURIComponent(JSON.stringify(cache)), expires);
                },
                cacheEnabled: function(cache) {
                    if (typeof cache === "undefined") {
                        return this.config.options.cache;
                    }
                    return cache;
                },
                clearCache: function(provider) {
                    if (provider) {
                        this.storage.erase("oauthio_provider_" + provider);
                    } else {
                        this.storage.eraseFrom("oauthio_provider_");
                    }
                }
            };
        }, {}],
        10: [function(require, module, exports) {
            "use strict";
            module.exports = {
                init: function(config, document) {
                    this.config = config;
                    return this.document = document;
                },
                create: function(name, value, expires) {
                    var date;
                    this.erase(name);
                    date = new Date();
                    if (expires) {
                        date.setTime(date.getTime() + (expires || 1200) * 1000);
                    } else {
                        date.setFullYear(date.getFullYear() + 3);
                    }
                    expires = "; expires=" + date.toGMTString();
                    this.document.cookie = name + "=" + value + expires + "; path=/";
                },
                read: function(name) {
                    var c, ca, i, nameEQ;
                    nameEQ = name + "=";
                    ca = this.document.cookie.split(";");
                    i = 0;
                    while (i < ca.length) {
                        c = ca[i];
                        while (c.charAt(0) === " ") {
                            c = c.substring(1, c.length);
                        }
                        if (c.indexOf(nameEQ) === 0) {
                            return c.substring(nameEQ.length, c.length);
                        }
                        i++;
                    }
                    return null;
                },
                erase: function(name) {
                    var date;
                    date = new Date();
                    date.setTime(date.getTime() - 86400000);
                    this.document.cookie = name + "=; expires=" + date.toGMTString() + "; path=/";
                },
                eraseFrom: function(prefix) {
                    var cname, cookie, cookies, j, len;
                    cookies = this.document.cookie.split(";");
                    for (j = 0, len = cookies.length; j < len; j++) {
                        cookie = cookies[j];
                        cname = cookie.split("=")[0].trim();
                        if (cname.substr(0, prefix.length) === prefix) {
                            this.erase(cname);
                        }
                    }
                }
            };
        }, {}],
        11: [function(require, module, exports) {
            /*!
             * jQuery JavaScript Library v2.1.1 -attributes,-attributes/attr,-attributes/classes,-attributes/prop,-attributes/support,-attributes/val,-css/addGetHookIf,-css/curCSS,-css/defaultDisplay,-css/hiddenVisibleSelectors,-css/support,-css/swap,-css/var,-css/var/cssExpand,-css/var/getStyles,-css/var/isHidden,-css/var/rmargin,-css/var/rnumnonpx,-css,-effects,-effects/Tween,-effects/animatedSelector,-dimensions,-offset,-data/var/data_user,-deprecated,-event/alias,-event/support,-intro,-manipulation/_evalUrl,-manipulation/support,-manipulation/var,-manipulation/var/rcheckableType,-manipulation,-outro,-queue,-queue/delay,-selector-native,-selector-sizzle,-sizzle/dist,-sizzle/dist/sizzle,-sizzle/dist/min,-sizzle/test,-sizzle/test/jquery,-traversing,-traversing/findFilter,-traversing/var/rneedsContext,-traversing/var,-wrap,-exports,-exports/amd
             * http://jquery.com/
             *
             * Includes Sizzle.js
             * http://sizzlejs.com/
             *
             * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
             * Released under the MIT license
             * http://jquery.org/license
             *
             * Date: 2015-10-12T19:37Z
             */
            (function(global, factory) {
                if (typeof module === "object" && typeof module.exports === "object") {
                    module.exports = global.document ? factory(global, true) : function(w) {
                        if (!w.document) {
                            throw new Error("jQuery requires a window with a document");
                        }
                        return factory(w);
                    };
                } else {
                    factory(global);
                }
            }(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
                var arr = [];
                var slice = arr.slice;
                var concat = arr.concat;
                var push = arr.push;
                var indexOf = arr.indexOf;
                var class2type = {};
                var toString = class2type.toString;
                var hasOwn = class2type.hasOwnProperty;
                var support = {};
                var
                    document = window.document,
                    version = "2.1.1 -attributes,-attributes/attr,-attributes/classes,-attributes/prop,-attributes/support,-attributes/val,-css/addGetHookIf,-css/curCSS,-css/defaultDisplay,-css/hiddenVisibleSelectors,-css/support,-css/swap,-css/var,-css/var/cssExpand,-css/var/getStyles,-css/var/isHidden,-css/var/rmargin,-css/var/rnumnonpx,-css,-effects,-effects/Tween,-effects/animatedSelector,-dimensions,-offset,-data/var/data_user,-deprecated,-event/alias,-event/support,-intro,-manipulation/_evalUrl,-manipulation/support,-manipulation/var,-manipulation/var/rcheckableType,-manipulation,-outro,-queue,-queue/delay,-selector-native,-selector-sizzle,-sizzle/dist,-sizzle/dist/sizzle,-sizzle/dist/min,-sizzle/test,-sizzle/test/jquery,-traversing,-traversing/findFilter,-traversing/var/rneedsContext,-traversing/var,-wrap,-exports,-exports/amd",
                    jQuery = function(selector, context) {
                        return new jQuery.fn.init(selector, context);
                    },
                    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                    rmsPrefix = /^-ms-/,
                    rdashAlpha = /-([\da-z])/gi,
                    fcamelCase = function(all, letter) {
                        return letter.toUpperCase();
                    };
                jQuery.fn = jQuery.prototype = {
                    jquery: version,
                    constructor: jQuery,
                    selector: "",
                    length: 0,
                    toArray: function() {
                        return slice.call(this);
                    },
                    get: function(num) {
                        return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
                    },
                    pushStack: function(elems) {
                        var ret = jQuery.merge(this.constructor(), elems);
                        ret.prevObject = this;
                        ret.context = this.context;
                        return ret;
                    },
                    each: function(callback, args) {
                        return jQuery.each(this, callback, args);
                    },
                    map: function(callback) {
                        return this.pushStack(jQuery.map(this, function(elem, i) {
                            return callback.call(elem, i, elem);
                        }));
                    },
                    slice: function() {
                        return this.pushStack(slice.apply(this, arguments));
                    },
                    first: function() {
                        return this.eq(0);
                    },
                    last: function() {
                        return this.eq(-1);
                    },
                    eq: function(i) {
                        var len = this.length,
                            j = +i + (i < 0 ? len : 0);
                        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                    },
                    end: function() {
                        return this.prevObject || this.constructor(null);
                    },
                    push: push,
                    sort: arr.sort,
                    splice: arr.splice
                };
                jQuery.extend = jQuery.fn.extend = function() {
                    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
                        i = 1,
                        length = arguments.length,
                        deep = false;
                    if (typeof target === "boolean") {
                        deep = target;
                        target = arguments[i] || {};
                        i++;
                    }
                    if (typeof target !== "object" && !jQuery.isFunction(target)) {
                        target = {};
                    }
                    if (i === length) {
                        target = this;
                        i--;
                    }
                    for (; i < length; i++) {
                        if ((options = arguments[i]) != null) {
                            for (name in options) {
                                src = target[name];
                                copy = options[name];
                                if (target === copy) {
                                    continue;
                                }
                                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                    if (copyIsArray) {
                                        copyIsArray = false;
                                        clone = src && jQuery.isArray(src) ? src : [];
                                    } else {
                                        clone = src && jQuery.isPlainObject(src) ? src : {};
                                    }
                                    target[name] = jQuery.extend(deep, clone, copy);
                                } else if (copy !== undefined) {
                                    target[name] = copy;
                                }
                            }
                        }
                    }
                    return target;
                };
                jQuery.extend({
                    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
                    isReady: true,
                    error: function(msg) {
                        throw new Error(msg);
                    },
                    noop: function() {},
                    isFunction: function(obj) {
                        return jQuery.type(obj) === "function";
                    },
                    isArray: Array.isArray,
                    isWindow: function(obj) {
                        return obj != null && obj === obj.window;
                    },
                    isNumeric: function(obj) {
                        return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
                    },
                    isPlainObject: function(obj) {
                        if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                            return false;
                        }
                        if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                            return false;
                        }
                        return true;
                    },
                    isEmptyObject: function(obj) {
                        var name;
                        for (name in obj) {
                            return false;
                        }
                        return true;
                    },
                    type: function(obj) {
                        if (obj == null) {
                            return obj + "";
                        }
                        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
                    },
                    globalEval: function(code) {
                        var script, indirect = eval;
                        code = jQuery.trim(code);
                        if (code) {
                            if (code.indexOf("use strict") === 1) {
                                script = document.createElement("script");
                                script.text = code;
                                document.head.appendChild(script).parentNode.removeChild(script);
                            } else {
                                indirect(code);
                            }
                        }
                    },
                    camelCase: function(string) {
                        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                    },
                    nodeName: function(elem, name) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                    },
                    each: function(obj, callback, args) {
                        var value, i = 0,
                            length = obj.length,
                            isArray = isArraylike(obj);
                        if (args) {
                            if (isArray) {
                                for (; i < length; i++) {
                                    value = callback.apply(obj[i], args);
                                    if (value === false) {
                                        break;
                                    }
                                }
                            } else {
                                for (i in obj) {
                                    value = callback.apply(obj[i], args);
                                    if (value === false) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            if (isArray) {
                                for (; i < length; i++) {
                                    value = callback.call(obj[i], i, obj[i]);
                                    if (value === false) {
                                        break;
                                    }
                                }
                            } else {
                                for (i in obj) {
                                    value = callback.call(obj[i], i, obj[i]);
                                    if (value === false) {
                                        break;
                                    }
                                }
                            }
                        }
                        return obj;
                    },
                    trim: function(text) {
                        return text == null ? "" : (text + "").replace(rtrim, "");
                    },
                    makeArray: function(arr, results) {
                        var ret = results || [];
                        if (arr != null) {
                            if (isArraylike(Object(arr))) {
                                jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                            } else {
                                push.call(ret, arr);
                            }
                        }
                        return ret;
                    },
                    inArray: function(elem, arr, i) {
                        return arr == null ? -1 : indexOf.call(arr, elem, i);
                    },
                    merge: function(first, second) {
                        var len = +second.length,
                            j = 0,
                            i = first.length;
                        for (; j < len; j++) {
                            first[i++] = second[j];
                        }
                        first.length = i;
                        return first;
                    },
                    grep: function(elems, callback, invert) {
                        var callbackInverse, matches = [],
                            i = 0,
                            length = elems.length,
                            callbackExpect = !invert;
                        for (; i < length; i++) {
                            callbackInverse = !callback(elems[i], i);
                            if (callbackInverse !== callbackExpect) {
                                matches.push(elems[i]);
                            }
                        }
                        return matches;
                    },
                    map: function(elems, callback, arg) {
                        var value, i = 0,
                            length = elems.length,
                            isArray = isArraylike(elems),
                            ret = [];
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback(elems[i], i, arg);
                                if (value != null) {
                                    ret.push(value);
                                }
                            }
                        } else {
                            for (i in elems) {
                                value = callback(elems[i], i, arg);
                                if (value != null) {
                                    ret.push(value);
                                }
                            }
                        }
                        return concat.apply([], ret);
                    },
                    guid: 1,
                    proxy: function(fn, context) {
                        var tmp, args, proxy;
                        if (typeof context === "string") {
                            tmp = fn[context];
                            context = fn;
                            fn = tmp;
                        }
                        if (!jQuery.isFunction(fn)) {
                            return undefined;
                        }
                        args = slice.call(arguments, 2);
                        proxy = function() {
                            return fn.apply(context || this, args.concat(slice.call(arguments)));
                        };
                        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                        return proxy;
                    },
                    now: Date.now,
                    support: support
                });
                jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                    class2type["[object " + name + "]"] = name.toLowerCase();
                });

                function isArraylike(obj) {
                    var length = obj.length,
                        type = jQuery.type(obj);
                    if (type === "function" || jQuery.isWindow(obj)) {
                        return false;
                    }
                    if (obj.nodeType === 1 && length) {
                        return true;
                    }
                    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
                }
                var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
                var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
                    init = jQuery.fn.init = function(selector, context) {
                        var match, elem;
                        if (!selector) {
                            return this;
                        }
                        if (typeof selector === "string") {
                            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                                match = [null, selector, null];
                            } else {
                                match = rquickExpr.exec(selector);
                            }
                            if (match && (match[1] || !context)) {
                                if (match[1]) {
                                    context = context instanceof jQuery ? context[0] : context;
                                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                        for (match in context) {
                                            if (jQuery.isFunction(this[match])) {
                                                this[match](context[match]);
                                            } else {
                                                this.attr(match, context[match]);
                                            }
                                        }
                                    }
                                    return this;
                                } else {
                                    elem = document.getElementById(match[2]);
                                    if (elem && elem.parentNode) {
                                        this.length = 1;
                                        this[0] = elem;
                                    }
                                    this.context = document;
                                    this.selector = selector;
                                    return this;
                                }
                            } else if (!context || context.jquery) {
                                return (context || rootjQuery).find(selector);
                            } else {
                                return this.constructor(context).find(selector);
                            }
                        } else if (selector.nodeType) {
                            this.context = this[0] = selector;
                            this.length = 1;
                            return this;
                        } else if (jQuery.isFunction(selector)) {
                            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
                        }
                        if (selector.selector !== undefined) {
                            this.selector = selector.selector;
                            this.context = selector.context;
                        }
                        return jQuery.makeArray(selector, this);
                    };
                init.prototype = jQuery.fn;
                rootjQuery = jQuery(document);
                var rnotwhite = (/\S+/g);
                var optionsCache = {};

                function createOptions(options) {
                    var object = optionsCache[options] = {};
                    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
                        object[flag] = true;
                    });
                    return object;
                }
                jQuery.Callbacks = function(options) {
                    options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
                    var
                        memory, fired, firing, firingStart, firingLength, firingIndex, list = [],
                        stack = !options.once && [],
                        fire = function(data) {
                            memory = options.memory && data;
                            fired = true;
                            firingIndex = firingStart || 0;
                            firingStart = 0;
                            firingLength = list.length;
                            firing = true;
                            for (; list && firingIndex < firingLength; firingIndex++) {
                                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                                    memory = false;
                                    break;
                                }
                            }
                            firing = false;
                            if (list) {
                                if (stack) {
                                    if (stack.length) {
                                        fire(stack.shift());
                                    }
                                } else if (memory) {
                                    list = [];
                                } else {
                                    self.disable();
                                }
                            }
                        },
                        self = {
                            add: function() {
                                if (list) {
                                    var start = list.length;
                                    (function add(args) {
                                        jQuery.each(args, function(_, arg) {
                                            var type = jQuery.type(arg);
                                            if (type === "function") {
                                                if (!options.unique || !self.has(arg)) {
                                                    list.push(arg);
                                                }
                                            } else if (arg && arg.length && type !== "string") {
                                                add(arg);
                                            }
                                        });
                                    })(arguments);
                                    if (firing) {
                                        firingLength = list.length;
                                    } else if (memory) {
                                        firingStart = start;
                                        fire(memory);
                                    }
                                }
                                return this;
                            },
                            remove: function() {
                                if (list) {
                                    jQuery.each(arguments, function(_, arg) {
                                        var index;
                                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                            list.splice(index, 1);
                                            if (firing) {
                                                if (index <= firingLength) {
                                                    firingLength--;
                                                }
                                                if (index <= firingIndex) {
                                                    firingIndex--;
                                                }
                                            }
                                        }
                                    });
                                }
                                return this;
                            },
                            has: function(fn) {
                                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                            },
                            empty: function() {
                                list = [];
                                firingLength = 0;
                                return this;
                            },
                            disable: function() {
                                list = stack = memory = undefined;
                                return this;
                            },
                            disabled: function() {
                                return !list;
                            },
                            lock: function() {
                                stack = undefined;
                                if (!memory) {
                                    self.disable();
                                }
                                return this;
                            },
                            locked: function() {
                                return !stack;
                            },
                            fireWith: function(context, args) {
                                if (list && (!fired || stack)) {
                                    args = args || [];
                                    args = [context, args.slice ? args.slice() : args];
                                    if (firing) {
                                        stack.push(args);
                                    } else {
                                        fire(args);
                                    }
                                }
                                return this;
                            },
                            fire: function() {
                                self.fireWith(this, arguments);
                                return this;
                            },
                            fired: function() {
                                return !!fired;
                            }
                        };
                    return self;
                };
                jQuery.extend({
                    Deferred: function(func) {
                        var tuples = [
                                ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                                ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                                ["notify", "progress", jQuery.Callbacks("memory")]
                            ],
                            state = "pending",
                            promise = {
                                state: function() {
                                    return state;
                                },
                                always: function() {
                                    deferred.done(arguments).fail(arguments);
                                    return this;
                                },
                                then: function() {
                                    var fns = arguments;
                                    return jQuery.Deferred(function(newDefer) {
                                        jQuery.each(tuples, function(i, tuple) {
                                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                                            deferred[tuple[1]](function() {
                                                var returned = fn && fn.apply(this, arguments);
                                                if (returned && jQuery.isFunction(returned.promise)) {
                                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                                } else {
                                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                                }
                                            });
                                        });
                                        fns = null;
                                    }).promise();
                                },
                                promise: function(obj) {
                                    return obj != null ? jQuery.extend(obj, promise) : promise;
                                }
                            },
                            deferred = {};
                        promise.pipe = promise.then;
                        jQuery.each(tuples, function(i, tuple) {
                            var list = tuple[2],
                                stateString = tuple[3];
                            promise[tuple[1]] = list.add;
                            if (stateString) {
                                list.add(function() {
                                    state = stateString;
                                }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                            }
                            deferred[tuple[0]] = function() {
                                deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                                return this;
                            };
                            deferred[tuple[0] + "With"] = list.fireWith;
                        });
                        promise.promise(deferred);
                        if (func) {
                            func.call(deferred, deferred);
                        }
                        return deferred;
                    },
                    when: function(subordinate) {
                        var i = 0,
                            resolveValues = slice.call(arguments),
                            length = resolveValues.length,
                            remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
                            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                            updateFunc = function(i, contexts, values) {
                                return function(value) {
                                    contexts[i] = this;
                                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                    if (values === progressValues) {
                                        deferred.notifyWith(contexts, values);
                                    } else if (!(--remaining)) {
                                        deferred.resolveWith(contexts, values);
                                    }
                                };
                            },
                            progressValues, progressContexts, resolveContexts;
                        if (length > 1) {
                            progressValues = new Array(length);
                            progressContexts = new Array(length);
                            resolveContexts = new Array(length);
                            for (; i < length; i++) {
                                if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                    resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                                } else {
                                    --remaining;
                                }
                            }
                        }
                        if (!remaining) {
                            deferred.resolveWith(resolveContexts, resolveValues);
                        }
                        return deferred.promise();
                    }
                });
                var readyList;
                jQuery.fn.ready = function(fn) {
                    jQuery.ready.promise().done(fn);
                    return this;
                };
                jQuery.extend({
                    isReady: false,
                    readyWait: 1,
                    holdReady: function(hold) {
                        if (hold) {
                            jQuery.readyWait++;
                        } else {
                            jQuery.ready(true);
                        }
                    },
                    ready: function(wait) {
                        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                            return;
                        }
                        jQuery.isReady = true;
                        if (wait !== true && --jQuery.readyWait > 0) {
                            return;
                        }
                        readyList.resolveWith(document, [jQuery]);
                        if (jQuery.fn.triggerHandler) {
                            jQuery(document).triggerHandler("ready");
                            jQuery(document).off("ready");
                        }
                    }
                });

                function completed() {
                    document.removeEventListener("DOMContentLoaded", completed, false);
                    window.removeEventListener("load", completed, false);
                    jQuery.ready();
                }
                jQuery.ready.promise = function(obj) {
                    if (!readyList) {
                        readyList = jQuery.Deferred();
                        if (document.readyState === "complete") {
                            setTimeout(jQuery.ready);
                        } else {
                            document.addEventListener("DOMContentLoaded", completed, false);
                            window.addEventListener("load", completed, false);
                        }
                    }
                    return readyList.promise(obj);
                };
                jQuery.ready.promise();
                var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                    var i = 0,
                        len = elems.length,
                        bulk = key == null;
                    if (jQuery.type(key) === "object") {
                        chainable = true;
                        for (i in key) {
                            jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                        }
                    } else if (value !== undefined) {
                        chainable = true;
                        if (!jQuery.isFunction(value)) {
                            raw = true;
                        }
                        if (bulk) {
                            if (raw) {
                                fn.call(elems, value);
                                fn = null;
                            } else {
                                bulk = fn;
                                fn = function(elem, key, value) {
                                    return bulk.call(jQuery(elem), value);
                                };
                            }
                        }
                        if (fn) {
                            for (; i < len; i++) {
                                fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                            }
                        }
                    }
                    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
                };
                jQuery.acceptData = function(owner) {
                    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
                };

                function Data() {
                    Object.defineProperty(this.cache = {}, 0, {
                        get: function() {
                            return {};
                        }
                    });
                    this.expando = jQuery.expando + Math.random();
                }
                Data.uid = 1;
                Data.accepts = jQuery.acceptData;
                Data.prototype = {
                    key: function(owner) {
                        if (!Data.accepts(owner)) {
                            return 0;
                        }
                        var descriptor = {},
                            unlock = owner[this.expando];
                        if (!unlock) {
                            unlock = Data.uid++;
                            try {
                                descriptor[this.expando] = {
                                    value: unlock
                                };
                                Object.defineProperties(owner, descriptor);
                            } catch (e) {
                                descriptor[this.expando] = unlock;
                                jQuery.extend(owner, descriptor);
                            }
                        }
                        if (!this.cache[unlock]) {
                            this.cache[unlock] = {};
                        }
                        return unlock;
                    },
                    set: function(owner, data, value) {
                        var prop, unlock = this.key(owner),
                            cache = this.cache[unlock];
                        if (typeof data === "string") {
                            cache[data] = value;
                        } else {
                            if (jQuery.isEmptyObject(cache)) {
                                jQuery.extend(this.cache[unlock], data);
                            } else {
                                for (prop in data) {
                                    cache[prop] = data[prop];
                                }
                            }
                        }
                        return cache;
                    },
                    get: function(owner, key) {
                        var cache = this.cache[this.key(owner)];
                        return key === undefined ? cache : cache[key];
                    },
                    access: function(owner, key, value) {
                        var stored;
                        if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
                            stored = this.get(owner, key);
                            return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
                        }
                        this.set(owner, key, value);
                        return value !== undefined ? value : key;
                    },
                    remove: function(owner, key) {
                        var i, name, camel, unlock = this.key(owner),
                            cache = this.cache[unlock];
                        if (key === undefined) {
                            this.cache[unlock] = {};
                        } else {
                            if (jQuery.isArray(key)) {
                                name = key.concat(key.map(jQuery.camelCase));
                            } else {
                                camel = jQuery.camelCase(key);
                                if (key in cache) {
                                    name = [key, camel];
                                } else {
                                    name = camel;
                                    name = name in cache ? [name] : (name.match(rnotwhite) || []);
                                }
                            }
                            i = name.length;
                            while (i--) {
                                delete cache[name[i]];
                            }
                        }
                    },
                    hasData: function(owner) {
                        return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
                    },
                    discard: function(owner) {
                        if (owner[this.expando]) {
                            delete this.cache[owner[this.expando]];
                        }
                    }
                };
                var data_priv = new Data();
                var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    rmultiDash = /([A-Z])/g;

                function dataAttr(elem, key, data) {
                    var name;
                    if (data === undefined && elem.nodeType === 1) {
                        name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                        data = elem.getAttribute(name);
                        if (typeof data === "string") {
                            try {
                                data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                            } catch (e) {}
                            data_user.set(elem, key, data);
                        } else {
                            data = undefined;
                        }
                    }
                    return data;
                }
                jQuery.extend({
                    hasData: function(elem) {
                        return data_user.hasData(elem) || data_priv.hasData(elem);
                    },
                    data: function(elem, name, data) {
                        return data_user.access(elem, name, data);
                    },
                    removeData: function(elem, name) {
                        data_user.remove(elem, name);
                    },
                    _data: function(elem, name, data) {
                        return data_priv.access(elem, name, data);
                    },
                    _removeData: function(elem, name) {
                        data_priv.remove(elem, name);
                    }
                });
                jQuery.fn.extend({
                    data: function(key, value) {
                        var i, name, data, elem = this[0],
                            attrs = elem && elem.attributes;
                        if (key === undefined) {
                            if (this.length) {
                                data = data_user.get(elem);
                                if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                                    i = attrs.length;
                                    while (i--) {
                                        if (attrs[i]) {
                                            name = attrs[i].name;
                                            if (name.indexOf("data-") === 0) {
                                                name = jQuery.camelCase(name.slice(5));
                                                dataAttr(elem, name, data[name]);
                                            }
                                        }
                                    }
                                    data_priv.set(elem, "hasDataAttrs", true);
                                }
                            }
                            return data;
                        }
                        if (typeof key === "object") {
                            return this.each(function() {
                                data_user.set(this, key);
                            });
                        }
                        return access(this, function(value) {
                            var data, camelKey = jQuery.camelCase(key);
                            if (elem && value === undefined) {
                                data = data_user.get(elem, key);
                                if (data !== undefined) {
                                    return data;
                                }
                                data = data_user.get(elem, camelKey);
                                if (data !== undefined) {
                                    return data;
                                }
                                data = dataAttr(elem, camelKey, undefined);
                                if (data !== undefined) {
                                    return data;
                                }
                                return;
                            }
                            this.each(function() {
                                var data = data_user.get(this, camelKey);
                                data_user.set(this, camelKey, value);
                                if (key.indexOf("-") !== -1 && data !== undefined) {
                                    data_user.set(this, key, value);
                                }
                            });
                        }, null, value, arguments.length > 1, null, true);
                    },
                    removeData: function(key) {
                        return this.each(function() {
                            data_user.remove(this, key);
                        });
                    }
                });
                var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
                var strundefined = typeof undefined;
                var
                    rkeyEvent = /^key/,
                    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
                    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

                function returnTrue() {
                    return true;
                }

                function returnFalse() {
                    return false;
                }

                function safeActiveElement() {
                    try {
                        return document.activeElement;
                    } catch (err) {}
                }
                jQuery.event = {
                    global: {},
                    add: function(elem, types, handler, data, selector) {
                        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                        if (!elemData) {
                            return;
                        }
                        if (handler.handler) {
                            handleObjIn = handler;
                            handler = handleObjIn.handler;
                            selector = handleObjIn.selector;
                        }
                        if (!handler.guid) {
                            handler.guid = jQuery.guid++;
                        }
                        if (!(events = elemData.events)) {
                            events = elemData.events = {};
                        }
                        if (!(eventHandle = elemData.handle)) {
                            eventHandle = elemData.handle = function(e) {
                                return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                            };
                        }
                        types = (types || "").match(rnotwhite) || [""];
                        t = types.length;
                        while (t--) {
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();
                            if (!type) {
                                continue;
                            }
                            special = jQuery.event.special[type] || {};
                            type = (selector ? special.delegateType : special.bindType) || type;
                            special = jQuery.event.special[type] || {};
                            handleObj = jQuery.extend({
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                namespace: namespaces.join(".")
                            }, handleObjIn);
                            if (!(handlers = events[type])) {
                                handlers = events[type] = [];
                                handlers.delegateCount = 0;
                                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                    if (elem.addEventListener) {
                                        elem.addEventListener(type, eventHandle, false);
                                    }
                                }
                            }
                            if (special.add) {
                                special.add.call(elem, handleObj);
                                if (!handleObj.handler.guid) {
                                    handleObj.handler.guid = handler.guid;
                                }
                            }
                            if (selector) {
                                handlers.splice(handlers.delegateCount++, 0, handleObj);
                            } else {
                                handlers.push(handleObj);
                            }
                            jQuery.event.global[type] = true;
                        }
                    },
                    remove: function(elem, types, handler, selector, mappedTypes) {
                        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                        if (!elemData || !(events = elemData.events)) {
                            return;
                        }
                        types = (types || "").match(rnotwhite) || [""];
                        t = types.length;
                        while (t--) {
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();
                            if (!type) {
                                for (type in events) {
                                    jQuery.event.remove(elem, type + types[t], handler, selector, true);
                                }
                                continue;
                            }
                            special = jQuery.event.special[type] || {};
                            type = (selector ? special.delegateType : special.bindType) || type;
                            handlers = events[type] || [];
                            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                            origCount = j = handlers.length;
                            while (j--) {
                                handleObj = handlers[j];
                                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                                    handlers.splice(j, 1);
                                    if (handleObj.selector) {
                                        handlers.delegateCount--;
                                    }
                                    if (special.remove) {
                                        special.remove.call(elem, handleObj);
                                    }
                                }
                            }
                            if (origCount && !handlers.length) {
                                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                    jQuery.removeEvent(elem, type, elemData.handle);
                                }
                                delete events[type];
                            }
                        }
                        if (jQuery.isEmptyObject(events)) {
                            delete elemData.handle;
                            data_priv.remove(elem, "events");
                        }
                    },
                    trigger: function(event, data, elem, onlyHandlers) {
                        var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                            type = hasOwn.call(event, "type") ? event.type : event,
                            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                        cur = tmp = elem = elem || document;
                        if (elem.nodeType === 3 || elem.nodeType === 8) {
                            return;
                        }
                        if (rfocusMorph.test(type + jQuery.event.triggered)) {
                            return;
                        }
                        if (type.indexOf(".") >= 0) {
                            namespaces = type.split(".");
                            type = namespaces.shift();
                            namespaces.sort();
                        }
                        ontype = type.indexOf(":") < 0 && "on" + type;
                        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
                        event.isTrigger = onlyHandlers ? 2 : 3;
                        event.namespace = namespaces.join(".");
                        event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                        event.result = undefined;
                        if (!event.target) {
                            event.target = elem;
                        }
                        data = data == null ? [event] : jQuery.makeArray(data, [event]);
                        special = jQuery.event.special[type] || {};
                        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                            return;
                        }
                        if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                            bubbleType = special.delegateType || type;
                            if (!rfocusMorph.test(bubbleType + type)) {
                                cur = cur.parentNode;
                            }
                            for (; cur; cur = cur.parentNode) {
                                eventPath.push(cur);
                                tmp = cur;
                            }
                            if (tmp === (elem.ownerDocument || document)) {
                                eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                            }
                        }
                        i = 0;
                        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                            event.type = i > 1 ? bubbleType : special.bindType || type;
                            handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                            if (handle) {
                                handle.apply(cur, data);
                            }
                            handle = ontype && cur[ontype];
                            if (handle && handle.apply && jQuery.acceptData(cur)) {
                                event.result = handle.apply(cur, data);
                                if (event.result === false) {
                                    event.preventDefault();
                                }
                            }
                        }
                        event.type = type;
                        if (!onlyHandlers && !event.isDefaultPrevented()) {
                            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                                if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                                    tmp = elem[ontype];
                                    if (tmp) {
                                        elem[ontype] = null;
                                    }
                                    jQuery.event.triggered = type;
                                    elem[type]();
                                    jQuery.event.triggered = undefined;
                                    if (tmp) {
                                        elem[ontype] = tmp;
                                    }
                                }
                            }
                        }
                        return event.result;
                    },
                    dispatch: function(event) {
                        event = jQuery.event.fix(event);
                        var i, j, ret, matched, handleObj, handlerQueue = [],
                            args = slice.call(arguments),
                            handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                            special = jQuery.event.special[event.type] || {};
                        args[0] = event;
                        event.delegateTarget = this;
                        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                            return;
                        }
                        handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                        i = 0;
                        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                            event.currentTarget = matched.elem;
                            j = 0;
                            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                                if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                                    event.handleObj = handleObj;
                                    event.data = handleObj.data;
                                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                                    if (ret !== undefined) {
                                        if ((event.result = ret) === false) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                        }
                                    }
                                }
                            }
                        }
                        if (special.postDispatch) {
                            special.postDispatch.call(this, event);
                        }
                        return event.result;
                    },
                    handlers: function(event, handlers) {
                        var i, matches, sel, handleObj, handlerQueue = [],
                            delegateCount = handlers.delegateCount,
                            cur = event.target;
                        if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                            for (; cur !== this; cur = cur.parentNode || this) {
                                if (cur.disabled !== true || event.type !== "click") {
                                    matches = [];
                                    for (i = 0; i < delegateCount; i++) {
                                        handleObj = handlers[i];
                                        sel = handleObj.selector + " ";
                                        if (matches[sel] === undefined) {
                                            matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                                        }
                                        if (matches[sel]) {
                                            matches.push(handleObj);
                                        }
                                    }
                                    if (matches.length) {
                                        handlerQueue.push({
                                            elem: cur,
                                            handlers: matches
                                        });
                                    }
                                }
                            }
                        }
                        if (delegateCount < handlers.length) {
                            handlerQueue.push({
                                elem: this,
                                handlers: handlers.slice(delegateCount)
                            });
                        }
                        return handlerQueue;
                    },
                    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                    fixHooks: {},
                    keyHooks: {
                        props: "char charCode key keyCode".split(" "),
                        filter: function(event, original) {
                            if (event.which == null) {
                                event.which = original.charCode != null ? original.charCode : original.keyCode;
                            }
                            return event;
                        }
                    },
                    mouseHooks: {
                        props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                        filter: function(event, original) {
                            var eventDoc, doc, body, button = original.button;
                            if (event.pageX == null && original.clientX != null) {
                                eventDoc = event.target.ownerDocument || document;
                                doc = eventDoc.documentElement;
                                body = eventDoc.body;
                                event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                                event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                            }
                            if (!event.which && button !== undefined) {
                                event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                            }
                            return event;
                        }
                    },
                    fix: function(event) {
                        if (event[jQuery.expando]) {
                            return event;
                        }
                        var i, prop, copy, type = event.type,
                            originalEvent = event,
                            fixHook = this.fixHooks[type];
                        if (!fixHook) {
                            this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                        }
                        copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                        event = new jQuery.Event(originalEvent);
                        i = copy.length;
                        while (i--) {
                            prop = copy[i];
                            event[prop] = originalEvent[prop];
                        }
                        if (!event.target) {
                            event.target = document;
                        }
                        if (event.target.nodeType === 3) {
                            event.target = event.target.parentNode;
                        }
                        return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                    },
                    special: {
                        load: {
                            noBubble: true
                        },
                        focus: {
                            trigger: function() {
                                if (this !== safeActiveElement() && this.focus) {
                                    this.focus();
                                    return false;
                                }
                            },
                            delegateType: "focusin"
                        },
                        blur: {
                            trigger: function() {
                                if (this === safeActiveElement() && this.blur) {
                                    this.blur();
                                    return false;
                                }
                            },
                            delegateType: "focusout"
                        },
                        click: {
                            trigger: function() {
                                if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                    this.click();
                                    return false;
                                }
                            },
                            _default: function(event) {
                                return jQuery.nodeName(event.target, "a");
                            }
                        },
                        beforeunload: {
                            postDispatch: function(event) {
                                if (event.result !== undefined && event.originalEvent) {
                                    event.originalEvent.returnValue = event.result;
                                }
                            }
                        }
                    },
                    simulate: function(type, elem, event, bubble) {
                        var e = jQuery.extend(new jQuery.Event(), event, {
                            type: type,
                            isSimulated: true,
                            originalEvent: {}
                        });
                        if (bubble) {
                            jQuery.event.trigger(e, null, elem);
                        } else {
                            jQuery.event.dispatch.call(elem, e);
                        }
                        if (e.isDefaultPrevented()) {
                            event.preventDefault();
                        }
                    }
                };
                jQuery.removeEvent = function(elem, type, handle) {
                    if (elem.removeEventListener) {
                        elem.removeEventListener(type, handle, false);
                    }
                };
                jQuery.Event = function(src, props) {
                    if (!(this instanceof jQuery.Event)) {
                        return new jQuery.Event(src, props);
                    }
                    if (src && src.type) {
                        this.originalEvent = src;
                        this.type = src.type;
                        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
                    } else {
                        this.type = src;
                    }
                    if (props) {
                        jQuery.extend(this, props);
                    }
                    this.timeStamp = src && src.timeStamp || jQuery.now();
                    this[jQuery.expando] = true;
                };
                jQuery.Event.prototype = {
                    isDefaultPrevented: returnFalse,
                    isPropagationStopped: returnFalse,
                    isImmediatePropagationStopped: returnFalse,
                    preventDefault: function() {
                        var e = this.originalEvent;
                        this.isDefaultPrevented = returnTrue;
                        if (e && e.preventDefault) {
                            e.preventDefault();
                        }
                    },
                    stopPropagation: function() {
                        var e = this.originalEvent;
                        this.isPropagationStopped = returnTrue;
                        if (e && e.stopPropagation) {
                            e.stopPropagation();
                        }
                    },
                    stopImmediatePropagation: function() {
                        var e = this.originalEvent;
                        this.isImmediatePropagationStopped = returnTrue;
                        if (e && e.stopImmediatePropagation) {
                            e.stopImmediatePropagation();
                        }
                        this.stopPropagation();
                    }
                };
                jQuery.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function(orig, fix) {
                    jQuery.event.special[orig] = {
                        delegateType: fix,
                        bindType: fix,
                        handle: function(event) {
                            var ret, target = this,
                                related = event.relatedTarget,
                                handleObj = event.handleObj;
                            if (!related || (related !== target && !jQuery.contains(target, related))) {
                                event.type = handleObj.origType;
                                ret = handleObj.handler.apply(this, arguments);
                                event.type = fix;
                            }
                            return ret;
                        }
                    };
                });
                if (!support.focusinBubbles) {
                    jQuery.each({
                        focus: "focusin",
                        blur: "focusout"
                    }, function(orig, fix) {
                        var handler = function(event) {
                            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                        };
                        jQuery.event.special[fix] = {
                            setup: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = data_priv.access(doc, fix);
                                if (!attaches) {
                                    doc.addEventListener(orig, handler, true);
                                }
                                data_priv.access(doc, fix, (attaches || 0) + 1);
                            },
                            teardown: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = data_priv.access(doc, fix) - 1;
                                if (!attaches) {
                                    doc.removeEventListener(orig, handler, true);
                                    data_priv.remove(doc, fix);
                                } else {
                                    data_priv.access(doc, fix, attaches);
                                }
                            }
                        };
                    });
                }
                jQuery.fn.extend({
                    on: function(types, selector, data, fn, one) {
                        var origFn, type;
                        if (typeof types === "object") {
                            if (typeof selector !== "string") {
                                data = data || selector;
                                selector = undefined;
                            }
                            for (type in types) {
                                this.on(type, selector, data, types[type], one);
                            }
                            return this;
                        }
                        if (data == null && fn == null) {
                            fn = selector;
                            data = selector = undefined;
                        } else if (fn == null) {
                            if (typeof selector === "string") {
                                fn = data;
                                data = undefined;
                            } else {
                                fn = data;
                                data = selector;
                                selector = undefined;
                            }
                        }
                        if (fn === false) {
                            fn = returnFalse;
                        } else if (!fn) {
                            return this;
                        }
                        if (one === 1) {
                            origFn = fn;
                            fn = function(event) {
                                jQuery().off(event);
                                return origFn.apply(this, arguments);
                            };
                            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                        }
                        return this.each(function() {
                            jQuery.event.add(this, types, fn, data, selector);
                        });
                    },
                    one: function(types, selector, data, fn) {
                        return this.on(types, selector, data, fn, 1);
                    },
                    off: function(types, selector, fn) {
                        var handleObj, type;
                        if (types && types.preventDefault && types.handleObj) {
                            handleObj = types.handleObj;
                            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                            return this;
                        }
                        if (typeof types === "object") {
                            for (type in types) {
                                this.off(type, selector, types[type]);
                            }
                            return this;
                        }
                        if (selector === false || typeof selector === "function") {
                            fn = selector;
                            selector = undefined;
                        }
                        if (fn === false) {
                            fn = returnFalse;
                        }
                        return this.each(function() {
                            jQuery.event.remove(this, types, fn, selector);
                        });
                    },
                    trigger: function(type, data) {
                        return this.each(function() {
                            jQuery.event.trigger(type, data, this);
                        });
                    },
                    triggerHandler: function(type, data) {
                        var elem = this[0];
                        if (elem) {
                            return jQuery.event.trigger(type, data, elem, true);
                        }
                    }
                });
                var nonce = jQuery.now();
                var rquery = (/\?/);
                jQuery.parseJSON = function(data) {
                    return JSON.parse(data + "");
                };
                jQuery.parseXML = function(data) {
                    var xml, tmp;
                    if (!data || typeof data !== "string") {
                        return null;
                    }
                    try {
                        tmp = new DOMParser();
                        xml = tmp.parseFromString(data, "text/xml");
                    } catch (e) {
                        xml = undefined;
                    }
                    if (!xml || xml.getElementsByTagName("parsererror").length) {
                        jQuery.error("Invalid XML: " + data);
                    }
                    return xml;
                };
                var
                    ajaxLocParts, ajaxLocation, rhash = /#.*$/,
                    rts = /([?&])_=[^&]*/,
                    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
                    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    rnoContent = /^(?:GET|HEAD)$/,
                    rprotocol = /^\/\//,
                    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
                    prefilters = {},
                    transports = {},
                    allTypes = "*/".concat("*");
                try {
                    ajaxLocation = location.href;
                } catch (e) {
                    ajaxLocation = document.createElement("a");
                    ajaxLocation.href = "";
                    ajaxLocation = ajaxLocation.href;
                }
                ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

                function addToPrefiltersOrTransports(structure) {
                    return function(dataTypeExpression, func) {
                        if (typeof dataTypeExpression !== "string") {
                            func = dataTypeExpression;
                            dataTypeExpression = "*";
                        }
                        var dataType, i = 0,
                            dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                        if (jQuery.isFunction(func)) {
                            while ((dataType = dataTypes[i++])) {
                                if (dataType[0] === "+") {
                                    dataType = dataType.slice(1) || "*";
                                    (structure[dataType] = structure[dataType] || []).unshift(func);
                                } else {
                                    (structure[dataType] = structure[dataType] || []).push(func);
                                }
                            }
                        }
                    };
                }

                function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
                    var inspected = {},
                        seekingTransport = (structure === transports);

                    function inspect(dataType) {
                        var selected;
                        inspected[dataType] = true;
                        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                                options.dataTypes.unshift(dataTypeOrTransport);
                                inspect(dataTypeOrTransport);
                                return false;
                            } else if (seekingTransport) {
                                return !(selected = dataTypeOrTransport);
                            }
                        });
                        return selected;
                    }
                    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
                }

                function ajaxExtend(target, src) {
                    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
                    for (key in src) {
                        if (src[key] !== undefined) {
                            (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                        }
                    }
                    if (deep) {
                        jQuery.extend(true, target, deep);
                    }
                    return target;
                }

                function ajaxHandleResponses(s, jqXHR, responses) {
                    var ct, type, finalDataType, firstDataType, contents = s.contents,
                        dataTypes = s.dataTypes;
                    while (dataTypes[0] === "*") {
                        dataTypes.shift();
                        if (ct === undefined) {
                            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                        }
                    }
                    if (ct) {
                        for (type in contents) {
                            if (contents[type] && contents[type].test(ct)) {
                                dataTypes.unshift(type);
                                break;
                            }
                        }
                    }
                    if (dataTypes[0] in responses) {
                        finalDataType = dataTypes[0];
                    } else {
                        for (type in responses) {
                            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                                finalDataType = type;
                                break;
                            }
                            if (!firstDataType) {
                                firstDataType = type;
                            }
                        }
                        finalDataType = finalDataType || firstDataType;
                    }
                    if (finalDataType) {
                        if (finalDataType !== dataTypes[0]) {
                            dataTypes.unshift(finalDataType);
                        }
                        return responses[finalDataType];
                    }
                }

                function ajaxConvert(s, response, jqXHR, isSuccess) {
                    var conv2, current, conv, tmp, prev, converters = {},
                        dataTypes = s.dataTypes.slice();
                    if (dataTypes[1]) {
                        for (conv in s.converters) {
                            converters[conv.toLowerCase()] = s.converters[conv];
                        }
                    }
                    current = dataTypes.shift();
                    while (current) {
                        if (s.responseFields[current]) {
                            jqXHR[s.responseFields[current]] = response;
                        }
                        if (!prev && isSuccess && s.dataFilter) {
                            response = s.dataFilter(response, s.dataType);
                        }
                        prev = current;
                        current = dataTypes.shift();
                        if (current) {
                            if (current === "*") {
                                current = prev;
                            } else if (prev !== "*" && prev !== current) {
                                conv = converters[prev + " " + current] || converters["* " + current];
                                if (!conv) {
                                    for (conv2 in converters) {
                                        tmp = conv2.split(" ");
                                        if (tmp[1] === current) {
                                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                            if (conv) {
                                                if (conv === true) {
                                                    conv = converters[conv2];
                                                } else if (converters[conv2] !== true) {
                                                    current = tmp[0];
                                                    dataTypes.unshift(tmp[1]);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (conv !== true) {
                                    if (conv && s["throws"]) {
                                        response = conv(response);
                                    } else {
                                        try {
                                            response = conv(response);
                                        } catch (e) {
                                            return {
                                                state: "parsererror",
                                                error: conv ? e : "No conversion from " + prev + " to " + current
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return {
                        state: "success",
                        data: response
                    };
                }
                jQuery.extend({
                    active: 0,
                    lastModified: {},
                    etag: {},
                    ajaxSettings: {
                        url: ajaxLocation,
                        type: "GET",
                        isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                        global: true,
                        processData: true,
                        async: true,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        accepts: {
                            "*": allTypes,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        contents: {
                            xml: /xml/,
                            html: /html/,
                            json: /json/
                        },
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        converters: {
                            "* text": String,
                            "text html": true,
                            "text json": jQuery.parseJSON,
                            "text xml": jQuery.parseXML
                        },
                        flatOptions: {
                            url: true,
                            context: true
                        }
                    },
                    ajaxSetup: function(target, settings) {
                        return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
                    },
                    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                    ajaxTransport: addToPrefiltersOrTransports(transports),
                    ajax: function(url, options) {
                        if (typeof url === "object") {
                            options = url;
                            url = undefined;
                        }
                        options = options || {};
                        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options),
                            callbackContext = s.context || s,
                            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                            deferred = jQuery.Deferred(),
                            completeDeferred = jQuery.Callbacks("once memory"),
                            statusCode = s.statusCode || {},
                            requestHeaders = {},
                            requestHeadersNames = {},
                            state = 0,
                            strAbort = "canceled",
                            jqXHR = {
                                readyState: 0,
                                getResponseHeader: function(key) {
                                    var match;
                                    if (state === 2) {
                                        if (!responseHeaders) {
                                            responseHeaders = {};
                                            while ((match = rheaders.exec(responseHeadersString))) {
                                                responseHeaders[match[1].toLowerCase()] = match[2];
                                            }
                                        }
                                        match = responseHeaders[key.toLowerCase()];
                                    }
                                    return match == null ? null : match;
                                },
                                getAllResponseHeaders: function() {
                                    return state === 2 ? responseHeadersString : null;
                                },
                                setRequestHeader: function(name, value) {
                                    var lname = name.toLowerCase();
                                    if (!state) {
                                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                        requestHeaders[name] = value;
                                    }
                                    return this;
                                },
                                overrideMimeType: function(type) {
                                    if (!state) {
                                        s.mimeType = type;
                                    }
                                    return this;
                                },
                                statusCode: function(map) {
                                    var code;
                                    if (map) {
                                        if (state < 2) {
                                            for (code in map) {
                                                statusCode[code] = [statusCode[code], map[code]];
                                            }
                                        } else {
                                            jqXHR.always(map[jqXHR.status]);
                                        }
                                    }
                                    return this;
                                },
                                abort: function(statusText) {
                                    var finalText = statusText || strAbort;
                                    if (transport) {
                                        transport.abort(finalText);
                                    }
                                    done(0, finalText);
                                    return this;
                                }
                            };
                        deferred.promise(jqXHR).complete = completeDeferred.add;
                        jqXHR.success = jqXHR.done;
                        jqXHR.error = jqXHR.fail;
                        s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
                        s.type = options.method || options.type || s.method || s.type;
                        s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
                        if (s.crossDomain == null) {
                            parts = rurl.exec(s.url.toLowerCase());
                            s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
                        }
                        if (s.data && s.processData && typeof s.data !== "string") {
                            s.data = jQuery.param(s.data, s.traditional);
                        }
                        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                        if (state === 2) {
                            return jqXHR;
                        }
                        fireGlobals = s.global;
                        if (fireGlobals && jQuery.active++ === 0) {
                            jQuery.event.trigger("ajaxStart");
                        }
                        s.type = s.type.toUpperCase();
                        s.hasContent = !rnoContent.test(s.type);
                        cacheURL = s.url;
                        if (!s.hasContent) {
                            if (s.data) {
                                cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
                                delete s.data;
                            }
                            if (s.cache === false) {
                                s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                            }
                        }
                        if (s.ifModified) {
                            if (jQuery.lastModified[cacheURL]) {
                                jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                            }
                            if (jQuery.etag[cacheURL]) {
                                jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                            }
                        }
                        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                            jqXHR.setRequestHeader("Content-Type", s.contentType);
                        }
                        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                        for (i in s.headers) {
                            jqXHR.setRequestHeader(i, s.headers[i]);
                        }
                        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                            return jqXHR.abort();
                        }
                        strAbort = "abort";
                        for (i in {
                                success: 1,
                                error: 1,
                                complete: 1
                            }) {
                            jqXHR[i](s[i]);
                        }
                        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                        if (!transport) {
                            done(-1, "No Transport");
                        } else {
                            jqXHR.readyState = 1;
                            if (fireGlobals) {
                                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                            }
                            if (s.async && s.timeout > 0) {
                                timeoutTimer = setTimeout(function() {
                                    jqXHR.abort("timeout");
                                }, s.timeout);
                            }
                            try {
                                state = 1;
                                transport.send(requestHeaders, done);
                            } catch (e) {
                                if (state < 2) {
                                    done(-1, e);
                                } else {
                                    throw e;
                                }
                            }
                        }

                        function done(status, nativeStatusText, responses, headers) {
                            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                            if (state === 2) {
                                return;
                            }
                            state = 2;
                            if (timeoutTimer) {
                                clearTimeout(timeoutTimer);
                            }
                            transport = undefined;
                            responseHeadersString = headers || "";
                            jqXHR.readyState = status > 0 ? 4 : 0;
                            isSuccess = status >= 200 && status < 300 || status === 304;
                            if (responses) {
                                response = ajaxHandleResponses(s, jqXHR, responses);
                            }
                            response = ajaxConvert(s, response, jqXHR, isSuccess);
                            if (isSuccess) {
                                if (s.ifModified) {
                                    modified = jqXHR.getResponseHeader("Last-Modified");
                                    if (modified) {
                                        jQuery.lastModified[cacheURL] = modified;
                                    }
                                    modified = jqXHR.getResponseHeader("etag");
                                    if (modified) {
                                        jQuery.etag[cacheURL] = modified;
                                    }
                                }
                                if (status === 204 || s.type === "HEAD") {
                                    statusText = "nocontent";
                                } else if (status === 304) {
                                    statusText = "notmodified";
                                } else {
                                    statusText = response.state;
                                    success = response.data;
                                    error = response.error;
                                    isSuccess = !error;
                                }
                            } else {
                                error = statusText;
                                if (status || !statusText) {
                                    statusText = "error";
                                    if (status < 0) {
                                        status = 0;
                                    }
                                }
                            }
                            jqXHR.status = status;
                            jqXHR.statusText = (nativeStatusText || statusText) + "";
                            if (isSuccess) {
                                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                            } else {
                                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                            }
                            jqXHR.statusCode(statusCode);
                            statusCode = undefined;
                            if (fireGlobals) {
                                globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                            }
                            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                            if (fireGlobals) {
                                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                                if (!(--jQuery.active)) {
                                    jQuery.event.trigger("ajaxStop");
                                }
                            }
                        }
                        return jqXHR;
                    },
                    getJSON: function(url, data, callback) {
                        return jQuery.get(url, data, callback, "json");
                    },
                    getScript: function(url, callback) {
                        return jQuery.get(url, undefined, callback, "script");
                    }
                });
                jQuery.each(["get", "post"], function(i, method) {
                    jQuery[method] = function(url, data, callback, type) {
                        if (jQuery.isFunction(data)) {
                            type = type || callback;
                            callback = data;
                            data = undefined;
                        }
                        return jQuery.ajax({
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        });
                    };
                });
                jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
                    jQuery.fn[type] = function(fn) {
                        return this.on(type, fn);
                    };
                });
                var r20 = /%20/g,
                    rbracket = /\[\]$/,
                    rCRLF = /\r?\n/g,
                    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                    rsubmittable = /^(?:input|select|textarea|keygen)/i;

                function buildParams(prefix, obj, traditional, add) {
                    var name;
                    if (jQuery.isArray(obj)) {
                        jQuery.each(obj, function(i, v) {
                            if (traditional || rbracket.test(prefix)) {
                                add(prefix, v);
                            } else {
                                buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                            }
                        });
                    } else if (!traditional && jQuery.type(obj) === "object") {
                        for (name in obj) {
                            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                        }
                    } else {
                        add(prefix, obj);
                    }
                }
                jQuery.param = function(a, traditional) {
                    var prefix, s = [],
                        add = function(key, value) {
                            value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                        };
                    if (traditional === undefined) {
                        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                    }
                    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                        jQuery.each(a, function() {
                            add(this.name, this.value);
                        });
                    } else {
                        for (prefix in a) {
                            buildParams(prefix, a[prefix], traditional, add);
                        }
                    }
                    return s.join("&").replace(r20, "+");
                };
                jQuery.fn.extend({
                    serialize: function() {
                        return jQuery.param(this.serializeArray());
                    },
                    serializeArray: function() {
                        return this.map(function() {
                            var elements = jQuery.prop(this, "elements");
                            return elements ? jQuery.makeArray(elements) : this;
                        }).filter(function() {
                            var type = this.type;
                            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                        }).map(function(i, elem) {
                            var val = jQuery(this).val();
                            return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                                return {
                                    name: elem.name,
                                    value: val.replace(rCRLF, "\r\n")
                                };
                            }) : {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            };
                        }).get();
                    }
                });
                jQuery.ajaxSettings.xhr = function() {
                    try {
                        return new XMLHttpRequest();
                    } catch (e) {}
                };
                var xhrId = 0,
                    xhrCallbacks = {},
                    xhrSuccessStatus = {
                        0: 200,
                        1223: 204
                    },
                    xhrSupported = jQuery.ajaxSettings.xhr();
                if (window.ActiveXObject) {
                    jQuery(window).on("unload", function() {
                        for (var key in xhrCallbacks) {
                            xhrCallbacks[key]();
                        }
                    });
                }
                support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
                support.ajax = xhrSupported = !!xhrSupported;
                jQuery.ajaxTransport(function(options) {
                    var callback;
                    if (support.cors || xhrSupported && !options.crossDomain) {
                        return {
                            send: function(headers, complete) {
                                var i, xhr = options.xhr(),
                                    id = ++xhrId;
                                xhr.open(options.type, options.url, options.async, options.username, options.password);
                                if (options.xhrFields) {
                                    for (i in options.xhrFields) {
                                        xhr[i] = options.xhrFields[i];
                                    }
                                }
                                if (options.mimeType && xhr.overrideMimeType) {
                                    xhr.overrideMimeType(options.mimeType);
                                }
                                if (!options.crossDomain && !headers["X-Requested-With"]) {
                                    headers["X-Requested-With"] = "XMLHttpRequest";
                                }
                                for (i in headers) {
                                    xhr.setRequestHeader(i, headers[i]);
                                }
                                callback = function(type) {
                                    return function() {
                                        if (callback) {
                                            delete xhrCallbacks[id];
                                            callback = xhr.onload = xhr.onerror = null;
                                            if (type === "abort") {
                                                xhr.abort();
                                            } else if (type === "error") {
                                                complete(xhr.status, xhr.statusText);
                                            } else {
                                                complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                                    text: xhr.responseText
                                                } : undefined, xhr.getAllResponseHeaders());
                                            }
                                        }
                                    };
                                };
                                xhr.onload = callback();
                                xhr.onerror = callback("error");
                                callback = xhrCallbacks[id] = callback("abort");
                                try {
                                    xhr.send(options.hasContent && options.data || null);
                                } catch (e) {
                                    if (callback) {
                                        throw e;
                                    }
                                }
                            },
                            abort: function() {
                                if (callback) {
                                    callback();
                                }
                            }
                        };
                    }
                });
                jQuery.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /(?:java|ecma)script/
                    },
                    converters: {
                        "text script": function(text) {
                            jQuery.globalEval(text);
                            return text;
                        }
                    }
                });
                jQuery.ajaxPrefilter("script", function(s) {
                    if (s.cache === undefined) {
                        s.cache = false;
                    }
                    if (s.crossDomain) {
                        s.type = "GET";
                    }
                });
                jQuery.ajaxTransport("script", function(s) {
                    if (s.crossDomain) {
                        var script, callback;
                        return {
                            send: function(_, complete) {
                                script = jQuery("<script>").prop({
                                    async: true,
                                    charset: s.scriptCharset,
                                    src: s.url
                                }).on("load error", callback = function(evt) {
                                    script.remove();
                                    callback = null;
                                    if (evt) {
                                        complete(evt.type === "error" ? 404 : 200, evt.type);
                                    }
                                });
                                document.head.appendChild(script[0]);
                            },
                            abort: function() {
                                if (callback) {
                                    callback();
                                }
                            }
                        };
                    }
                });
                var oldCallbacks = [],
                    rjsonp = /(=)\?(?=&|$)|\?\?/;
                jQuery.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                        this[callback] = true;
                        return callback;
                    }
                });
                jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
                    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
                    if (jsonProp || s.dataTypes[0] === "jsonp") {
                        callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                        if (jsonProp) {
                            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                        } else if (s.jsonp !== false) {
                            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                        }
                        s.converters["script json"] = function() {
                            if (!responseContainer) {
                                jQuery.error(callbackName + " was not called");
                            }
                            return responseContainer[0];
                        };
                        s.dataTypes[0] = "json";
                        overwritten = window[callbackName];
                        window[callbackName] = function() {
                            responseContainer = arguments;
                        };
                        jqXHR.always(function() {
                            window[callbackName] = overwritten;
                            if (s[callbackName]) {
                                s.jsonpCallback = originalSettings.jsonpCallback;
                                oldCallbacks.push(callbackName);
                            }
                            if (responseContainer && jQuery.isFunction(overwritten)) {
                                overwritten(responseContainer[0]);
                            }
                            responseContainer = overwritten = undefined;
                        });
                        return "script";
                    }
                });
                jQuery.parseHTML = function(data, context, keepScripts) {
                    if (!data || typeof data !== "string") {
                        return null;
                    }
                    if (typeof context === "boolean") {
                        keepScripts = context;
                        context = false;
                    }
                    context = context || document;
                    var parsed = rsingleTag.exec(data),
                        scripts = !keepScripts && [];
                    if (parsed) {
                        return [context.createElement(parsed[1])];
                    }
                    parsed = jQuery.buildFragment([data], context, scripts);
                    if (scripts && scripts.length) {
                        jQuery(scripts).remove();
                    }
                    return jQuery.merge([], parsed.childNodes);
                };
                var _load = jQuery.fn.load;
                jQuery.fn.load = function(url, params, callback) {
                    if (typeof url !== "string" && _load) {
                        return _load.apply(this, arguments);
                    }
                    var selector, type, response, self = this,
                        off = url.indexOf(" ");
                    if (off >= 0) {
                        selector = jQuery.trim(url.slice(off));
                        url = url.slice(0, off);
                    }
                    if (jQuery.isFunction(params)) {
                        callback = params;
                        params = undefined;
                    } else if (params && typeof params === "object") {
                        type = "POST";
                    }
                    if (self.length > 0) {
                        jQuery.ajax({
                            url: url,
                            type: type,
                            dataType: "html",
                            data: params
                        }).done(function(responseText) {
                            response = arguments;
                            self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                        }).complete(callback && function(jqXHR, status) {
                            self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                        });
                    }
                    return this;
                };
                jQuery.noConflict = function() {};
                return jQuery;
                return jQuery;
            }));
        }, {}],
        12: [function(require, module, exports) {
            "use strict";
            module.exports = function(document) {
                return {
                    reload: function() {
                        return document.location.reload();
                    },
                    getHash: function() {
                        return document.location.hash;
                    },
                    setHash: function(newHash) {
                        return document.location.hash = newHash;
                    },
                    changeHref: function(newLocation) {
                        return document.location.href = newLocation;
                    }
                };
            };
        }, {}],
        13: [function(require, module, exports) {
            "use strict";
            var useCache;
            useCache = function(callback) {
                var cacheobj;
                cacheobj = localStorage.getItem('oauthio_cache');
                if (cacheobj) {
                    cacheobj = JSON.parse(cacheobj);
                } else {
                    cacheobj = {};
                }
                return callback(cacheobj, function() {
                    return localStorage.setItem('oauthio_cache', JSON.stringify(cacheobj));
                });
            };
            module.exports = {
                init: function(config, document) {
                    this.config = config;
                    return this.document = document;
                },
                active: function() {
                    return typeof localStorage !== "undefined" && localStorage !== null;
                },
                create: function(name, value, expires) {
                    var date;
                    this.erase(name);
                    date = new Date();
                    localStorage.setItem(name, value);
                    useCache(function(cacheobj, cacheupdate) {
                        cacheobj[name] = expires ? date.getTime() + (expires || 1200) * 1000 : false;
                        return cacheupdate();
                    });
                },
                read: function(name) {
                    return useCache(function(cacheobj, cacheupdate) {
                        if (cacheobj[name] == null) {
                            return null;
                        }
                        if (cacheobj[name] === false) {
                            return localStorage.getItem(name);
                        } else if ((new Date()).getTime() < cacheobj[name]) {
                            localStorage.removeItem(name);
                            delete cacheobj[name];
                            cacheupdate();
                            return null;
                        } else {
                            return localStorage.getItem(name);
                        }
                    });
                },
                erase: function(name) {
                    return useCache(function(cacheobj, cacheupdate) {
                        localStorage.removeItem(name);
                        delete cacheobj[name];
                        return cacheupdate();
                    });
                },
                eraseFrom: function(prefix) {
                    useCache(function(cacheobj, cacheupdate) {
                        var cachenames, i, len, name;
                        cachenames = Object.keys(cacheobj);
                        for (i = 0, len = cachenames.length; i < len; i++) {
                            name = cachenames[i];
                            if (name.substr(0, prefix.length) === prefix) {
                                localStorage.removeItem(name);
                                delete cacheobj[name];
                            }
                        }
                        return cacheupdate();
                    });
                }
            };
        }, {}],
        14: [function(require, module, exports) {
            var b64pad, hexcase;
            hexcase = 0;
            b64pad = "";
            module.exports = {
                hex_sha1: function(s) {
                    return this.rstr2hex(this.rstr_sha1(this.str2rstr_utf8(s)));
                },
                b64_sha1: function(s) {
                    return this.rstr2b64(this.rstr_sha1(this.str2rstr_utf8(s)));
                },
                any_sha1: function(s, e) {
                    return this.rstr2any(this.rstr_sha1(this.str2rstr_utf8(s)), e);
                },
                hex_hmac_sha1: function(k, d) {
                    return this.rstr2hex(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
                },
                b64_hmac_sha1: function(k, d) {
                    return this.rstr2b64(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
                },
                any_hmac_sha1: function(k, d, e) {
                    return this.rstr2any(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)), e);
                },
                sha1_vm_test: function() {
                    return thishex_sha1("abc").toLowerCase() === "a9993e364706816aba3e25717850c26c9cd0d89d";
                },
                rstr_sha1: function(s) {
                    return this.binb2rstr(this.binb_sha1(this.rstr2binb(s), s.length * 8));
                },
                rstr_hmac_sha1: function(key, data) {
                    var bkey, hash, i, ipad, opad;
                    bkey = this.rstr2binb(key);
                    if (bkey.length > 16) {
                        bkey = this.binb_sha1(bkey, key.length * 8);
                    }
                    ipad = Array(16);
                    opad = Array(16);
                    i = 0;
                    while (i < 16) {
                        ipad[i] = bkey[i] ^ 0x36363636;
                        opad[i] = bkey[i] ^ 0x5C5C5C5C;
                        i++;
                    }
                    hash = this.binb_sha1(ipad.concat(this.rstr2binb(data)), 512 + data.length * 8);
                    return this.binb2rstr(this.binb_sha1(opad.concat(hash), 512 + 160));
                },
                rstr2hex: function(input) {
                    var e, hex_tab, i, output, x;
                    try {
                        hexcase;
                    } catch (_error) {
                        e = _error;
                        hexcase = 0;
                    }
                    hex_tab = (hexcase ? "0123456789ABCDEF" : "0123456789abcdef");
                    output = "";
                    x = void 0;
                    i = 0;
                    while (i < input.length) {
                        x = input.charCodeAt(i);
                        output += hex_tab.charAt((x >>> 4) & 0x0F) + hex_tab.charAt(x & 0x0F);
                        i++;
                    }
                    return output;
                },
                rstr2b64: function(input) {
                    var e, i, j, len, output, tab, triplet;
                    try {
                        b64pad;
                    } catch (_error) {
                        e = _error;
                        b64pad = "";
                    }
                    tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    output = "";
                    len = input.length;
                    i = 0;
                    while (i < len) {
                        triplet = (input.charCodeAt(i) << 16) | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
                        j = 0;
                        while (j < 4) {
                            if (i * 8 + j * 6 > input.length * 8) {
                                output += b64pad;
                            } else {
                                output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
                            }
                            j++;
                        }
                        i += 3;
                    }
                    return output;
                },
                rstr2any: function(input, encoding) {
                    var dividend, divisor, full_length, i, output, q, quotient, remainders, x;
                    divisor = encoding.length;
                    remainders = Array();
                    i = void 0;
                    q = void 0;
                    x = void 0;
                    quotient = void 0;
                    dividend = Array(Math.ceil(input.length / 2));
                    i = 0;
                    while (i < dividend.length) {
                        dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
                        i++;
                    }
                    while (dividend.length > 0) {
                        quotient = Array();
                        x = 0;
                        i = 0;
                        while (i < dividend.length) {
                            x = (x << 16) + dividend[i];
                            q = Math.floor(x / divisor);
                            x -= q * divisor;
                            if (quotient.length > 0 || q > 0) {
                                quotient[quotient.length] = q;
                            }
                            i++;
                        }
                        remainders[remainders.length] = x;
                        dividend = quotient;
                    }
                    output = "";
                    i = remainders.length - 1;
                    while (i >= 0) {
                        output += encoding.charAt(remainders[i]);
                        i--;
                    }
                    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
                    i = output.length;
                    while (i < full_length) {
                        output = encoding[0] + output;
                        i++;
                    }
                    return output;
                },
                str2rstr_utf8: function(input) {
                    var i, output, x, y;
                    output = "";
                    i = -1;
                    x = void 0;
                    y = void 0;
                    while (++i < input.length) {
                        x = input.charCodeAt(i);
                        y = (i + 1 < input.length ? input.charCodeAt(i + 1) : 0);
                        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
                            x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
                            i++;
                        }
                        if (x <= 0x7F) {
                            output += String.fromCharCode(x);
                        } else if (x <= 0x7FF) {
                            output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F), 0x80 | (x & 0x3F));
                        } else if (x <= 0xFFFF) {
                            output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
                        } else {
                            if (x <= 0x1FFFFF) {
                                output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07), 0x80 | ((x >>> 12) & 0x3F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
                            }
                        }
                    }
                    return output;
                },
                str2rstr_utf16le: function(input) {
                    var i, output;
                    output = "";
                    i = 0;
                    while (i < input.length) {
                        output += String.fromCharCode(input.charCodeAt(i) & 0xFF, (input.charCodeAt(i) >>> 8) & 0xFF);
                        i++;
                    }
                    return output;
                },
                str2rstr_utf16be: function(input) {
                    var i, output;
                    output = "";
                    i = 0;
                    while (i < input.length) {
                        output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF, input.charCodeAt(i) & 0xFF);
                        i++;
                    }
                    return output;
                },
                rstr2binb: function(input) {
                    var i, output;
                    output = Array(input.length >> 2);
                    i = 0;
                    while (i < output.length) {
                        output[i] = 0;
                        i++;
                    }
                    i = 0;
                    while (i < input.length * 8) {
                        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
                        i += 8;
                    }
                    return output;
                },
                binb2rstr: function(input) {
                    var i, output;
                    output = "";
                    i = 0;
                    while (i < input.length * 32) {
                        output += String.fromCharCode((input[i >> 5] >>> (24 - i % 32)) & 0xFF);
                        i += 8;
                    }
                    return output;
                },
                binb_sha1: function(x, len) {
                    var a, b, c, d, e, i, j, olda, oldb, oldc, oldd, olde, t, w;
                    x[len >> 5] |= 0x80 << (24 - len % 32);
                    x[((len + 64 >> 9) << 4) + 15] = len;
                    w = Array(80);
                    a = 1732584193;
                    b = -271733879;
                    c = -1732584194;
                    d = 271733878;
                    e = -1009589776;
                    i = 0;
                    while (i < x.length) {
                        olda = a;
                        oldb = b;
                        oldc = c;
                        oldd = d;
                        olde = e;
                        j = 0;
                        while (j < 80) {
                            if (j < 16) {
                                w[j] = x[i + j];
                            } else {
                                w[j] = this.bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                            }
                            t = this.safe_add(this.safe_add(this.bit_rol(a, 5), this.sha1_ft(j, b, c, d)), this.safe_add(this.safe_add(e, w[j]), this.sha1_kt(j)));
                            e = d;
                            d = c;
                            c = this.bit_rol(b, 30);
                            b = a;
                            a = t;
                            j++;
                        }
                        a = this.safe_add(a, olda);
                        b = this.safe_add(b, oldb);
                        c = this.safe_add(c, oldc);
                        d = this.safe_add(d, oldd);
                        e = this.safe_add(e, olde);
                        i += 16;
                    }
                    return Array(a, b, c, d, e);
                },
                sha1_ft: function(t, b, c, d) {
                    if (t < 20) {
                        return (b & c) | ((~b) & d);
                    }
                    if (t < 40) {
                        return b ^ c ^ d;
                    }
                    if (t < 60) {
                        return (b & c) | (b & d) | (c & d);
                    }
                    return b ^ c ^ d;
                },
                sha1_kt: function(t) {
                    if (t < 20) {
                        return 1518500249;
                    } else {
                        if (t < 40) {
                            return 1859775393;
                        } else {
                            if (t < 60) {
                                return -1894007588;
                            } else {
                                return -899497514;
                            }
                        }
                    }
                },
                safe_add: function(x, y) {
                    var lsw, msw;
                    lsw = (x & 0xFFFF) + (y & 0xFFFF);
                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                    return (msw << 16) | (lsw & 0xFFFF);
                },
                bit_rol: function(num, cnt) {
                    return (num << cnt) | (num >>> (32 - cnt));
                },
                create_hash: function() {
                    var hash;
                    hash = this.b64_sha1((new Date()).getTime() + ":" + Math.floor(Math.random() * 9999999));
                    return hash.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=+$/, "");
                }
            };
        }, {}],
        15: [function(require, module, exports) {
            module.exports = function(document) {
                return {
                    getAbsUrl: function(url) {
                        var base_url;
                        if (url.match(/^.{2,5}:\/\//)) {
                            return url;
                        }
                        if (url[0] === "/") {
                            return document.location.protocol + "//" + document.location.host + url;
                        }
                        base_url = document.location.protocol + "//" + document.location.host + document.location.pathname;
                        if (base_url[base_url.length - 1] !== "/" && url[0] !== "#") {
                            return base_url + "/" + url;
                        }
                        return base_url + url;
                    },
                    replaceParam: function(param, rep, rep2) {
                        param = param.replace(/\{\{(.*?)\}\}/g, function(m, v) {
                            return rep[v] || "";
                        });
                        if (rep2) {
                            param = param.replace(/\{(.*?)\}/g, function(m, v) {
                                return rep2[v] || "";
                            });
                        }
                        return param;
                    }
                };
            };
        }, {}]
    }, {}, [8])(8)
});;

function Share() {
    this.image = '';
    this.count = 0;
    this.sharing_text = '';
}
Share.prototype.fbShare = function(ev, obj, component) {
    var event = window.event || ev;
    event.preventDefault();
    var pic = abs_path + this.image;
    var name = editor.selectedLanguage.check_it_out;
    $(".success_for_facebook_share").hide();
    var auto_scroll_down = $('#' + component).parents('.auto_scroll_down');
    FB.ui({
        method: 'feed',
        link: share_path,
        caption: 'WordCounter.net',
        name: name,
        description: share.sharing_text,
        picture: pic
    }, function(response) {
        $(obj).css({
            'pointer-events': 'fill',
            'opacity': '1'
        });
        if (response && response.post_id) {
            $(".success_for_facebook_share").html('<div class="alert alert-success" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.post_was_published_successfully + '</div>');
            $(".success_for_facebook_share").show();
            auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
            setTimeout(function() {
                $(".success_for_facebook_share").hide();
            }, 10000);
        } else {
            $(".success_for_facebook_share").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.post_was_not_published + '</div>');
            $(".success_for_facebook_share").show();
            auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
            setTimeout(function() {
                $(".success_for_facebook_share").hide();
            }, 10000);
        }
    });
};
Share.prototype.twitterShare = function(ev, obj, component) {
    var event = window.event || ev;
    event.preventDefault();
    var image_base64 = '';
    var blob_image = '';
    var auto_scroll_down = $('#' + component).parents('.auto_scroll_down');
    if (this.count != 0 || component != 'details_panel1') {
        $(obj).css({
            'pointer-events': 'none',
            'opacity': '0.5'
        });
        $(".success_for_facebook_share").html('<h3 style="color: #31b0d5; text-align: center"><span class="glyphicon glyphicon-refresh glyphicon-spin" style="margin-left: 0"></span><span style="margin-left: 10px">' + editor.selectedLanguage.share_is_processing + '</span></h3>').show();
        auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
        if (component == 'details_panel1')
            this.sharing_text = $('#text_for_details_sharing').val();
        else if (component == 'kwd-density1') {
            this.sharing_text = $('#text_for_keyword_density_sharing').val();
        } else {
            this.sharing_text = $('#sharing_text').val();
        }
        html2canvas(document.getElementById(component), {
            onrendered: function(canvas) {
                image_base64 = canvas.toDataURL("image/png");
                $.ajax({
                    type: "POST",
                    url: "site/tweet-image",
                    data: {
                        connect: 'twitter',
                        img_url: image_base64,
                        text: share.sharing_text
                    },
                    success: function(response) {
                        if (response.success) {
                            var width = 575,
                                height = 400,
                                left = ($(window).width() - width) / 2,
                                top = ($(window).height() - height) / 2,
                                opts = 'toolbar=yes, scrollbars=yes, resizable=yes, status=1' + ',width=' + width + ',height=' + height + ',top=' + top + ',left=' + left;
                            var twitter_popup_window = window.open(response.url, "twitter", opts);
                            $(".success_for_facebook_share").hide();
                            var interval = setInterval(function() {
                                try {
                                    if (twitter_popup_window == null || twitter_popup_window.closed) {
                                        clearInterval(interval);
                                        $(".success_for_facebook_share").html('<div class="alert alert-success" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.success + '</strong> ' + editor.selectedLanguage.post_was_published_successfully + '</div>');
                                        $(".success_for_facebook_share").show();
                                        auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
                                        setTimeout(function() {
                                            $(".success_for_facebook_share").hide();
                                        }, 10000);
                                    }
                                } catch (e) {}
                            }, 1000);
                        } else {
                            $(".success_for_facebook_share").hide();
                            $(".success_for_facebook_share").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong>' + response.error + '</div>');
                            $(".success_for_facebook_share").show();
                            auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
                            setTimeout(function() {
                                $(".success_for_facebook_share").hide();
                            }, 10000);
                        }
                        $(obj).css({
                            'pointer-events': 'fill',
                            'opacity': '1'
                        });
                    }
                });
            }
        });
    } else {
        $(".success_for_facebook_share").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + editor.selectedLanguage.you_should_check_at_least_one_component_for_share + '</div>');
        $(".success_for_facebook_share").show();
        auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
        setTimeout(function() {
            $(".success_for_facebook_share").hide();
        }, 10000);
    }
};
Share.prototype.setGoalBadge = function() {
    $('#goal1').show();
    $('#speed1').hide();
    var cookieGoal = editor.optionsObject.buttons['goalViewBox'];
    var goalTypeText = $("#goalType option[value='" + cookieGoal.type + "']").data('value');
    var goal_text = goalTypeText.toLowerCase().replace(' ', '_');
    $('#sharing_text').val(editor.selectedLanguage.i_reached_my_word_count_goal_of + ' ' + cookieGoal.qty + ' ' + editor.selectedLanguage[goal_text] + ' ' + editor.selectedLanguage.at + ' ' + abs_path + ' #wordcount @wordcounter_net');
    $('#share_to_facebook a').attr('onclick', 'share.shareImageToFb(event, this, "goal1")');
    $('#share_to_twitter a').attr('onclick', 'share.twitterShare(event, this, "goal1")');
};
Share.prototype.setSpeedBadge = function() {
    $('#goal1').hide();
    $('#speed1').show();
    $('#sharing_text').val(editor.selectedLanguage.my_writing_speed_is + ' ' + $('#wpm').text() + ' ' + editor.selectedLanguage.words_per_minute + ' ' + editor.selectedLanguage.at + ' ' + abs_path + ' #wordcount @wordcounter_net');
    $('#share_to_facebook a').attr('onclick', 'share.shareImageToFb(event, this, "speed1")');
    $('#share_to_twitter a').attr('onclick', 'share.twitterShare(event, this, "speed1")');
};
Share.prototype.countCheckedDetails = function() {
    this.count = 0;
    $('#share-details-modal .chk_share_component:checked').each(function(index, value) {
        share.count++;
    });
    console.log(this.count);
};
Share.prototype.checkShareComponent = function(obj) {
    var data = $(obj).data('detail');
    var data1 = data.slice(0, data.length - 1);
    if ($(obj).prop('checked')) {
        if (!editor.optionsObject.details[data1]) {
            var savedObject = {
                'details': {}
            };
            savedObject.details[data1] = true;
            editor.changeOption(savedObject);
            editor.wordCountInternational();
        }
        $('#' + data).parent().show();
        this.count++;
    } else {
        $('#' + data).parent().hide();
        this.count--;
    }
    this.createDownloadLink('download-details-panel-link', 'details_panel1');
};
Share.prototype.checkShareComponentAtTheBeginning = function() {
    var data, data1, savedObject = {
        'details': {}
    };
    this.count = 0;
    var obj = editor.optionsObject.details;
    for (var key in obj) {
        $('#share-details-modal .chk_share_component[data-detail="' + key + '1' + '"]').prop('checked', obj[key]);
    }
    $('#details_panel1 .list-group-item').hide();
    $('#share-details-modal .chk_share_component:checked').each(function(index, value) {
        share.count++;
        data = $(value).data('detail');
        $('#' + data).parent().show();
    });
    editor.wordCountInternational();
};
Share.prototype.createDownloadLink = function(id, component) {
    var download_link = document.getElementById(id);
    if ($(download_link).find('span').length == 0) {
        $(download_link).append('<span class="glyphicon glyphicon-refresh glyphicon-spin" style="margin: 0 0 0 5px"></span>');
        $(download_link).css({
            'pointer-events': 'none',
            'opacity': '0.7'
        });
    }
    var image_base64 = '';
    setTimeout(function() {
        html2canvas(document.getElementById(component), {
            onrendered: function(canvas) {
                image_base64 = canvas.toDataURL("image/png");
                download_link.href = image_base64;
                download_link.download = component + '.png';
                $(download_link).css({
                    'pointer-events': 'fill',
                    'opacity': '1'
                });
                $(download_link).find('span').remove();
            }
        });
    }, 500);
};
Share.prototype.createDownloadAsPDFLink = function(obj, ev, component) {
    ev.preventDefault();
    var download_component;
    if (!component) {
        if ($('#goal1').css('display') != 'none') {
            download_component = 'goal1';
        } else {
            download_component = 'speed1';
        }
    } else {
        download_component = component;
    }
    if ($(obj).find('span').length == 0) {
        $(obj).append('<span class="glyphicon glyphicon-refresh glyphicon-spin" style="margin: 0 0 0 5px"></span>');
        $(obj).css({
            'pointer-events': 'none',
            'opacity': '0.7'
        });
    }
    var image_base64 = '';
    html2canvas(document.getElementById(download_component), {
        onrendered: function(canvas) {
            image_base64 = canvas.toDataURL("image/png");
            var doc = new jsPDF('p', 'mm');
            doc.addImage(image_base64, 'PNG', 10, 10);
            doc.save(download_component + '.pdf');
            $(obj).css({
                'pointer-events': 'fill',
                'opacity': '1'
            });
            $(obj).find('span').remove();
        }
    });
};
Share.prototype.shareImageToFb = function(ev, obj, components) {
    var event = window.event || ev;
    event.preventDefault();
    var image_base64 = '';
    var auto_scroll_down = $('#' + components).parents('.auto_scroll_down');
    if (this.count != 0 || components != 'details_panel1') {
        $(obj).css({
            'pointer-events': 'none',
            'opacity': '0.5'
        });
        $(".success_for_facebook_share").html('<h3 style="color: #2a6597; text-align: center"><span class="glyphicon glyphicon-refresh glyphicon-spin" style="margin-left: 0"></span><span style="margin-left: 10px">' + editor.selectedLanguage.share_is_processing + '</span></h3>').show();
        auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
        if (components == 'details_panel1')
            this.sharing_text = $('#text_for_details_sharing').val();
        else if (components == 'kwd-density1') {
            this.sharing_text = $('#text_for_keyword_density_sharing').val();
        } else {
            this.sharing_text = $('#sharing_text').val();
        }
        html2canvas(document.getElementById(components), {
            onrendered: function(canvas) {
                image_base64 = canvas.toDataURL("image/png");
                $.ajax({
                    type: "POST",
                    url: "site/save-image",
                    data: {
                        img_url: image_base64
                    },
                    success: function(data) {
                        if (data.success) {
                            share.image = data.file;
                            share.fbShare(ev, obj, components);
                        } else {
                            $(".success_for_facebook_share").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> ' + data.error + '</div>');
                            $(".success_for_facebook_share").show();
                            auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
                            setTimeout(function() {
                                $(".success_for_facebook_share").hide();
                            }, 10000);
                        }
                    }
                });
            }
        });
    } else {
        $(".success_for_facebook_share").html('<div class="alert alert-warning" style="text-align: left">' + '<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>' + ' <strong>' + editor.selectedLanguage.warning + '</strong> <span data-tr-detail="you_should_check_at_least_one_component_for_share">You should check at least one component for share.</span></div>');
        $(".success_for_facebook_share").show();
        auto_scroll_down.scrollTop(auto_scroll_down[0].scrollHeight);
        setTimeout(function() {
            $(".success_for_facebook_share").hide();
        }, 10000);
    }
};
Share.prototype.getKeywordDensity = function() {
    $('#keywords_for_share').empty();
    $('#kwd-accordion-data a').each(function(index, value) {
        $('#keywords_for_share').append('<li class="list-group-item">' + $(value).find('span.word').text() + '<span class="badge">' + $(value).find('span.badge').text() + '</span>' + '</li>');
    });
};
var share = new Share();;
/*!
 * jQuery Upload File Plugin
 * version: 4.0.10
 * @requires jQuery v1.5 or later & form plugin
 * Copyright (c) 2013 Ravishanker Kusuma
 * http://hayageek.com/
 */
! function(e) {
    void 0 == e.fn.ajaxForm && e.getScript(("https:" == document.location.protocol ? "https://" : "http://") + "cdnjs.cloudflare.com/ajax/libs/jquery.form/4.2.2/jquery.form.min.js");
    var a = {};
    a.fileapi = void 0 !== e("<input type='file'/>").get(0).files, a.formdata = void 0 !== window.FormData, e.fn.uploadFile = function(t) {
        function r() {
            S || (S = !0, function e() {
                if (w.sequential || (w.sequentialCount = 99999), 0 == x.length && 0 == D.length) w.afterUploadAll && w.afterUploadAll(C), S = !1;
                else {
                    if (D.length < w.sequentialCount) {
                        var a = x.shift();
                        void 0 != a && (D.push(a), a.removeClass(C.formGroup), a.submit())
                    }
                    window.setTimeout(e, 100)
                }
            }())
        }

        function o(a, t, r) {
            r.on("dragenter", function(a) {
                a.stopPropagation(), a.preventDefault(), e(this).addClass(t.dragDropHoverClass)
            }), r.on("dragover", function(a) {
                a.stopPropagation(), a.preventDefault();
                var r = e(this);
                r.hasClass(t.dragDropContainerClass) && !r.hasClass(t.dragDropHoverClass) && r.addClass(t.dragDropHoverClass)
            }), r.on("drop", function(r) {
                r.preventDefault(), e(this).removeClass(t.dragDropHoverClass), a.errorLog.html("");
                var o = r.originalEvent.dataTransfer.files;
                return !t.multiple && o.length > 1 ? void(t.showError && e("<div class='" + t.errorClass + "'>" + t.multiDragErrorStr + "</div>").appendTo(a.errorLog)) : void(0 != t.onSelect(o) && l(t, a, o))
            }), r.on("dragleave", function(a) {
                e(this).removeClass(t.dragDropHoverClass)
            }), e(document).on("dragenter", function(e) {
                e.stopPropagation(), e.preventDefault()
            }), e(document).on("dragover", function(a) {
                a.stopPropagation(), a.preventDefault();
                var r = e(this);
                r.hasClass(t.dragDropContainerClass) || r.removeClass(t.dragDropHoverClass)
            }), e(document).on("drop", function(a) {
                a.stopPropagation(), a.preventDefault(), e(this).removeClass(t.dragDropHoverClass)
            })
        }

        function s(e) {
            var a = "",
                t = e / 1024;
            if (parseInt(t) > 1024) {
                var r = t / 1024;
                a = r.toFixed(2) + " MB"
            } else a = t.toFixed(2) + " KB";
            return a
        }

        function i(a) {
            var t = [];
            t = "string" == jQuery.type(a) ? a.split("&") : e.param(a).split("&");
            var r, o, s = t.length,
                i = [];
            for (r = 0; s > r; r++) t[r] = t[r].replace(/\+/g, " "), o = t[r].split("="), i.push([decodeURIComponent(o[0]), decodeURIComponent(o[1])]);
            return i
        }

        function l(a, t, r) {
            for (var o = 0; o < r.length; o++)
                if (n(t, a, r[o].name))
                    if (a.allowDuplicates || !d(t, r[o].name))
                        if (-1 != a.maxFileSize && r[o].size > a.maxFileSize) a.showError && e("<div class='" + a.errorClass + "'><b>" + r[o].name + "</b> " + a.sizeErrorStr + s(a.maxFileSize) + "</div>").appendTo(t.errorLog);
                        else if (-1 != a.maxFileCount && t.selectedFiles >= a.maxFileCount) a.showError && e("<div class='" + a.errorClass + "'><b>" + r[o].name + "</b> " + a.maxFileCountErrorStr + a.maxFileCount + "</div>").appendTo(t.errorLog);
            else {
                t.selectedFiles++, t.existingFileNames.push(r[o].name);
                var l = a,
                    p = new FormData,
                    u = a.fileName.replace("[]", "");
                p.append(u, r[o]);
                var c = a.formData;
                if (c)
                    for (var h = i(c), f = 0; f < h.length; f++) h[f] && p.append(h[f][0], h[f][1]);
                l.fileData = p;
                var w = new m(t, a),
                    g = "";
                g = a.showFileCounter ? t.fileCounter + a.fileCounterStyle + r[o].name : r[o].name, a.showFileSize && (g += " (" + s(r[o].size) + ")"), w.filename.html(g);
                var C = e("<form style='display:block; position:absolute;left: 150px;' class='" + t.formGroup + "' method='" + a.method + "' action='" + a.url + "' enctype='" + a.enctype + "'></form>");
                C.appendTo("body");
                var b = [];
                b.push(r[o].name), v(C, l, w, b, t, r[o]), t.fileCounter++
            } else a.showError && e("<div class='" + a.errorClass + "'><b>" + r[o].name + "</b> " + a.duplicateErrorStr + "</div>").appendTo(t.errorLog);
            else a.showError && e("<div class='" + a.errorClass + "'><b>" + r[o].name + "</b> " + a.extErrorStr + a.allowedTypes + "</div>").appendTo(t.errorLog)
        }

        function n(e, a, t) {
            var r = a.allowedTypes.toLowerCase().split(/[\s,]+/g),
                o = t.split(".").pop().toLowerCase();
            return "*" != a.allowedTypes && jQuery.inArray(o, r) < 0 ? !1 : !0
        }

        function d(e, a) {
            var t = !1;
            if (e.existingFileNames.length)
                for (var r = 0; r < e.existingFileNames.length; r++)(e.existingFileNames[r] == a || w.duplicateStrict && e.existingFileNames[r].toLowerCase() == a.toLowerCase()) && (t = !0);
            return t
        }

        function p(e, a) {
            if (e.existingFileNames.length)
                for (var t = 0; t < a.length; t++) {
                    var r = e.existingFileNames.indexOf(a[t]); - 1 != r && e.existingFileNames.splice(r, 1)
                }
        }

        function u(e, a) {
            if (e) {
                a.show();
                var t = new FileReader;
                t.onload = function(e) {
                    a.attr("src", e.target.result)
                }, t.readAsDataURL(e)
            }
        }

        function c(a, t) {
            if (a.showFileCounter) {
                var r = e(t.container).find(".ajax-file-upload-filename").length;
                t.fileCounter = r + 1, e(t.container).find(".ajax-file-upload-filename").each(function(t, o) {
                    var s = e(this).html().split(a.fileCounterStyle),
                        i = (parseInt(s[0]) - 1, r + a.fileCounterStyle + s[1]);
                    e(this).html(i), r--
                })
            }
        }

        function h(t, r, o, s) {
            var i = "ajax-upload-id-" + (new Date).getTime(),
                d = e("<form method='" + o.method + "' action='" + o.url + "' enctype='" + o.enctype + "'></form>"),
                p = "<input type='file' id='" + i + "' name='" + o.fileName + "' accept='" + o.acceptFiles + "'/>";
            o.multiple && (o.fileName.indexOf("[]") != o.fileName.length - 2 && (o.fileName += "[]"), p = "<input type='file' id='" + i + "' name='" + o.fileName + "' accept='" + o.acceptFiles + "' multiple/>");
            var u = e(p).appendTo(d);
            u.change(function() {
                t.errorLog.html("");
                var i = (o.allowedTypes.toLowerCase().split(","), []);
                if (this.files) {
                    for (g = 0; g < this.files.length; g++) i.push(this.files[g].name);
                    if (0 == o.onSelect(this.files)) return
                } else {
                    var p = e(this).val(),
                        u = [];
                    if (i.push(p), !n(t, o, p)) return void(o.showError && e("<div class='" + o.errorClass + "'><b>" + p + "</b> " + o.extErrorStr + o.allowedTypes + "</div>").appendTo(t.errorLog));
                    if (u.push({
                            name: p,
                            size: "NA"
                        }), 0 == o.onSelect(u)) return
                }
                if (c(o, t), s.unbind("click"), d.hide(), h(t, r, o, s), d.addClass(r), o.serialize && a.fileapi && a.formdata) {
                    d.removeClass(r);
                    var f = this.files;
                    d.remove(), l(o, t, f)
                } else {
                    for (var w = "", g = 0; g < i.length; g++) w += o.showFileCounter ? t.fileCounter + o.fileCounterStyle + i[g] + "<br>" : i[g] + "<br>", t.fileCounter++;
                    if (-1 != o.maxFileCount && t.selectedFiles + i.length > o.maxFileCount) return void(o.showError && e("<div class='" + o.errorClass + "'><b>" + w + "</b> " + o.maxFileCountErrorStr + o.maxFileCount + "</div>").appendTo(t.errorLog));
                    t.selectedFiles += i.length;
                    var C = new m(t, o);
                    C.filename.html(w), v(d, o, C, i, t, null)
                }
            }), o.nestedForms ? (d.css({
                margin: 0,
                padding: 0
            }), s.css({
                position: "relative",
                overflow: "hidden",
                cursor: "default"
            }), u.css({
                position: "absolute",
                cursor: "pointer",
                top: "0px",
                width: "100%",
                height: "100%",
                left: "0px",
                "z-index": "100",
                opacity: "0.0",
                filter: "alpha(opacity=0)",
                "-ms-filter": "alpha(opacity=0)",
                "-khtml-opacity": "0.0",
                "-moz-opacity": "0.0"
            }), d.appendTo(s)) : (d.appendTo(e("body")), d.css({
                margin: 0,
                padding: 0,
                display: "block",
                position: "absolute",
                left: "-250px"
            }), -1 != navigator.appVersion.indexOf("MSIE ") ? s.attr("for", i) : s.click(function() {
                u.click()
            }))
        }

        function f(a, t) {
            return this.statusbar = e("<div class='ajax-file-upload-statusbar'></div>").width(t.statusBarWidth), this.preview = e("<img class='ajax-file-upload-preview' />").width(t.previewWidth).height(t.previewHeight).appendTo(this.statusbar).hide(), this.filename = e("<div class='ajax-file-upload-filename'></div>").appendTo(this.statusbar), this.progressDiv = e("<div class='ajax-file-upload-progress'>").appendTo(this.statusbar).hide(), this.progressbar = e("<div class='ajax-file-upload-bar'></div>").appendTo(this.progressDiv), this.abort = e("<div>" + t.abortStr + "</div>").appendTo(this.statusbar).hide(), this.cancel = e("<div>" + t.cancelStr + "</div>").appendTo(this.statusbar).hide(), this.done = e("<div>" + t.doneStr + "</div>").appendTo(this.statusbar).hide(), this.download = e("<div>" + t.downloadStr + "</div>").appendTo(this.statusbar).hide(), this.del = e("<div>" + t.deletelStr + "</div>").appendTo(this.statusbar).hide(), this.abort.addClass("ajax-file-upload-red"), this.done.addClass("ajax-file-upload-green"), this.download.addClass("ajax-file-upload-green"), this.cancel.addClass("ajax-file-upload-red"), this.del.addClass("ajax-file-upload-red"), this
        }

        function m(a, t) {
            var r = null;
            return r = t.customProgressBar ? new t.customProgressBar(a, t) : new f(a, t), r.abort.addClass(a.formGroup), r.abort.addClass(t.abortButtonClass), r.cancel.addClass(a.formGroup), r.cancel.addClass(t.cancelButtonClass), t.extraHTML && (r.extraHTML = e("<div class='extrahtml'>" + t.extraHTML() + "</div>").insertAfter(r.filename)), "bottom" == t.uploadQueueOrder ? e(a.container).append(r.statusbar) : e(a.container).prepend(r.statusbar), r
        }

        function v(t, o, s, l, n, d) {
            var h = {
                cache: !1,
                contentType: !1,
                processData: !1,
                forceSync: !1,
                type: o.method,
                data: o.formData,
                formData: o.fileData,
                dataType: o.returnType,
                beforeSubmit: function(a, r, d) {
                    if (0 != o.onSubmit.call(this, l)) {
                        if (o.dynamicFormData) {
                            var u = i(o.dynamicFormData());
                            if (u)
                                for (var h = 0; h < u.length; h++) u[h] && (void 0 != o.fileData ? d.formData.append(u[h][0], u[h][1]) : d.data[u[h][0]] = u[h][1])
                        }
                        return o.extraHTML && e(s.extraHTML).find("input,select,textarea").each(function(a, t) {
                            void 0 != o.fileData ? d.formData.append(e(this).attr("name"), e(this).val()) : d.data[e(this).attr("name")] = e(this).val()
                        }), !0
                    }
                    return s.statusbar.append("<div class='" + o.errorClass + "'>" + o.uploadErrorStr + "</div>"), s.cancel.show(), t.remove(), s.cancel.click(function() {
                        x.splice(x.indexOf(t), 1), p(n, l), s.statusbar.remove(), o.onCancel.call(n, l, s), n.selectedFiles -= l.length, c(o, n)
                    }), !1
                },
                beforeSend: function(e, t) {
                    s.progressDiv.show(), s.cancel.hide(), s.done.hide(), o.showAbort && (s.abort.show(), s.abort.click(function() {
                        p(n, l), e.abort(), n.selectedFiles -= l.length, o.onAbort.call(n, l, s)
                    })), a.formdata ? s.progressbar.width("1%") : s.progressbar.width("5%")
                },
                uploadProgress: function(e, a, t, r) {
                    r > 98 && (r = 98);
                    var i = r + "%";
                    r > 1 && s.progressbar.width(i), o.showProgress && (s.progressbar.html(i), s.progressbar.css("text-align", "center"))
                },
                success: function(a, r, i) {
                    if (s.cancel.remove(), D.pop(), "json" == o.returnType && "object" == e.type(a) && a.hasOwnProperty(o.customErrorKeyStr)) {
                        s.abort.hide();
                        var d = a[o.customErrorKeyStr];
                        return o.onError.call(this, l, 200, d, s), o.showStatusAfterError ? (s.progressDiv.hide(), s.statusbar.append("<span class='" + o.errorClass + "'>ERROR: " + d + "</span>")) : (s.statusbar.hide(), s.statusbar.remove()), n.selectedFiles -= l.length, void t.remove()
                    }
                    n.responses.push(a), s.progressbar.width("100%"), o.showProgress && (s.progressbar.html("100%"), s.progressbar.css("text-align", "center")), s.abort.hide(), o.onSuccess.call(this, l, a, i, s), o.showStatusAfterSuccess ? (o.showDone ? (s.done.show(), s.done.click(function() {
                        s.statusbar.hide("slow"), s.statusbar.remove()
                    })) : s.done.hide(), o.showDelete ? (s.del.show(), s.del.click(function() {
                        p(n, l), s.statusbar.hide().remove(), o.deleteCallback && o.deleteCallback.call(this, a, s), n.selectedFiles -= l.length, c(o, n)
                    })) : s.del.hide()) : (s.statusbar.hide("slow"), s.statusbar.remove()), o.showDownload && (s.download.show(), s.download.click(function() {
                        o.downloadCallback && o.downloadCallback(a)
                    })), t.remove()
                },
                error: function(e, a, r) {
                    s.cancel.remove(), D.pop(), s.abort.hide(), "abort" == e.statusText ? (s.statusbar.hide("slow").remove(), c(o, n)) : (o.onError.call(this, l, a, r, s), o.showStatusAfterError ? (s.progressDiv.hide(), s.statusbar.append("<span class='" + o.errorClass + "'>ERROR: " + r + "</span>")) : (s.statusbar.hide(), s.statusbar.remove()), n.selectedFiles -= l.length), t.remove()
                }
            };
            o.showPreview && null != d && "image" == d.type.toLowerCase().split("/").shift() && u(d, s.preview), o.autoSubmit ? (t.ajaxForm(h), x.push(t), r()) : (o.showCancel && (s.cancel.show(), s.cancel.click(function() {
                x.splice(x.indexOf(t), 1), p(n, l), t.remove(), s.statusbar.remove(), o.onCancel.call(n, l, s), n.selectedFiles -= l.length, c(o, n)
            })), t.ajaxForm(h))
        }
        var w = e.extend({
            url: "",
            method: "POST",
            enctype: "multipart/form-data",
            returnType: null,
            allowDuplicates: !0,
            duplicateStrict: !1,
            allowedTypes: "*",
            acceptFiles: "*",
            fileName: "file",
            formData: !1,
            dynamicFormData: !1,
            maxFileSize: -1,
            maxFileCount: -1,
            multiple: !0,
            dragDrop: !0,
            autoSubmit: !0,
            showCancel: !0,
            showAbort: !0,
            showDone: !1,
            showDelete: !1,
            showError: !0,
            showStatusAfterSuccess: !0,
            showStatusAfterError: !0,
            showFileCounter: !0,
            fileCounterStyle: "). ",
            showFileSize: !0,
            showProgress: !1,
            nestedForms: !0,
            showDownload: !1,
            onLoad: function(e) {},
            onSelect: function(e) {
                return !0
            },
            onSubmit: function(e, a) {},
            onSuccess: function(e, a, t, r) {},
            onError: function(e, a, t, r) {},
            onCancel: function(e, a) {},
            onAbort: function(e, a) {},
            downloadCallback: !1,
            deleteCallback: !1,
            afterUploadAll: !1,
            serialize: !0,
            sequential: !1,
            sequentialCount: 2,
            customProgressBar: !1,
            abortButtonClass: "ajax-file-upload-abort",
            cancelButtonClass: "ajax-file-upload-cancel",
            dragDropContainerClass: "ajax-upload-dragdrop",
            dragDropHoverClass: "state-hover",
            errorClass: "ajax-file-upload-error",
            uploadButtonClass: "ajax-file-upload",
            dragDropStr: "<span><b>Drag &amp; Drop Files</b></span>",
            uploadStr: "Select File",
            abortStr: "Abort",
            cancelStr: "Cancel",
            deletelStr: "Delete",
            doneStr: "Done",
            multiDragErrorStr: "Multiple File Drag &amp; Drop is not allowed.",
            extErrorStr: "is not allowed. Allowed extensions: ",
            duplicateErrorStr: "is not allowed. File already exists.",
            sizeErrorStr: "is not allowed. Allowed Max size: ",
            uploadErrorStr: "Upload is not allowed",
            maxFileCountErrorStr: " is not allowed. Maximum allowed files are:",
            downloadStr: "Download",
            customErrorKeyStr: "jquery-upload-file-error",
            showQueueDiv: !1,
            statusBarWidth: 400,
            dragdropWidth: 400,
            showPreview: !1,
            previewHeight: "auto",
            previewWidth: "100%",
            extraHTML: !1,
            uploadQueueOrder: "top"
        }, t);
        this.fileCounter = 1, this.selectedFiles = 0;
        var g = "ajax-file-upload-" + (new Date).getTime();
        this.formGroup = g, this.errorLog = e("<div></div>"), this.responses = [], this.existingFileNames = [], a.formdata || (w.dragDrop = !1), a.formdata || (w.multiple = !1), e(this).html("");
        var C = this,
            b = e("<div>" + w.uploadStr + "</div>");
        e(b).addClass(w.uploadButtonClass),
            function F() {
                if (e.fn.ajaxForm) {
                    if (w.dragDrop) {
                        var a = e('<div class="' + w.dragDropContainerClass + '" style="vertical-align:top;"></div>').width(w.dragdropWidth);
                        e(C).append(a), e(a).append(b), e(a).append(e(w.dragDropStr)), o(C, w, a)
                    } else e(C).append(b);
                    e(C).append(C.errorLog), w.showQueueDiv ? C.container = e("#" + w.showQueueDiv) : C.container = e("<div class='ajax-file-upload-container'></div>").insertAfter(e(C)), w.onLoad.call(this, C), h(C, g, w, b)
                } else window.setTimeout(F, 10)
            }(), this.startUpload = function() {
                e("form").each(function(a, t) {
                    e(this).hasClass(C.formGroup) && x.push(e(this))
                }), x.length >= 1 && r()
            }, this.getFileCount = function() {
                return C.selectedFiles
            }, this.stopUpload = function() {
                e("." + w.abortButtonClass).each(function(a, t) {
                    e(this).hasClass(C.formGroup) && e(this).click()
                }), e("." + w.cancelButtonClass).each(function(a, t) {
                    e(this).hasClass(C.formGroup) && e(this).click()
                })
            }, this.cancelAll = function() {
                e("." + w.cancelButtonClass).each(function(a, t) {
                    e(this).hasClass(C.formGroup) && e(this).click()
                })
            }, this.update = function(a) {
                w = e.extend(w, a)
            }, this.reset = function(e) {
                C.fileCounter = 1, C.selectedFiles = 0, C.errorLog.html(""), 0 != e && C.container.html("")
            }, this.remove = function() {
                C.container.html(""), e(C).remove()
            }, this.createProgress = function(e, a, t) {
                var r = new m(this, w);
                r.progressDiv.show(), r.progressbar.width("100%");
                var o = "";
                return o = w.showFileCounter ? C.fileCounter + w.fileCounterStyle + e : e, w.showFileSize && (o += " (" + s(t) + ")"), r.filename.html(o), C.fileCounter++, C.selectedFiles++, w.showPreview && (r.preview.attr("src", a), r.preview.show()), w.showDownload && (r.download.show(), r.download.click(function() {
                    w.downloadCallback && w.downloadCallback.call(C, [e])
                })), w.showDelete && (r.del.show(), r.del.click(function() {
                    r.statusbar.hide().remove();
                    var a = [e];
                    w.deleteCallback && w.deleteCallback.call(this, a, r), C.selectedFiles -= 1, c(w, C)
                })), r
            }, this.getResponses = function() {
                return this.responses
            };
        var x = [],
            D = [],
            S = !1;
        return this
    }
}(jQuery);;
var jsPDF = (function(global) {
    'use strict';
    var pdfVersion = '1.3',
        pageFormats = {
            'a0': [2383.94, 3370.39],
            'a1': [1683.78, 2383.94],
            'a2': [1190.55, 1683.78],
            'a3': [841.89, 1190.55],
            'a4': [595.28, 841.89],
            'a5': [419.53, 595.28],
            'a6': [297.64, 419.53],
            'a7': [209.76, 297.64],
            'a8': [147.40, 209.76],
            'a9': [104.88, 147.40],
            'a10': [73.70, 104.88],
            'b0': [2834.65, 4008.19],
            'b1': [2004.09, 2834.65],
            'b2': [1417.32, 2004.09],
            'b3': [1000.63, 1417.32],
            'b4': [708.66, 1000.63],
            'b5': [498.90, 708.66],
            'b6': [354.33, 498.90],
            'b7': [249.45, 354.33],
            'b8': [175.75, 249.45],
            'b9': [124.72, 175.75],
            'b10': [87.87, 124.72],
            'c0': [2599.37, 3676.54],
            'c1': [1836.85, 2599.37],
            'c2': [1298.27, 1836.85],
            'c3': [918.43, 1298.27],
            'c4': [649.13, 918.43],
            'c5': [459.21, 649.13],
            'c6': [323.15, 459.21],
            'c7': [229.61, 323.15],
            'c8': [161.57, 229.61],
            'c9': [113.39, 161.57],
            'c10': [79.37, 113.39],
            'dl': [311.81, 623.62],
            'letter': [612, 792],
            'government-letter': [576, 756],
            'legal': [612, 1008],
            'junior-legal': [576, 360],
            'ledger': [1224, 792],
            'tabloid': [792, 1224],
            'credit-card': [153, 243]
        };

    function PubSub(context) {
        var topics = {};
        this.subscribe = function(topic, callback, once) {
            if (typeof callback !== 'function') {
                return false;
            }
            if (!topics.hasOwnProperty(topic)) {
                topics[topic] = {};
            }
            var id = Math.random().toString(35);
            topics[topic][id] = [callback, !!once];
            return id;
        };
        this.unsubscribe = function(token) {
            for (var topic in topics) {
                if (topics[topic][token]) {
                    delete topics[topic][token];
                    return true;
                }
            }
            return false;
        };
        this.publish = function(topic) {
            if (topics.hasOwnProperty(topic)) {
                var args = Array.prototype.slice.call(arguments, 1),
                    idr = [];
                for (var id in topics[topic]) {
                    var sub = topics[topic][id];
                    try {
                        sub[0].apply(context, args);
                    } catch (ex) {
                        if (global.console) {
                            console.error('jsPDF PubSub Error', ex.message, ex);
                        }
                    }
                    if (sub[1]) idr.push(id);
                }
                if (idr.length) idr.forEach(this.unsubscribe);
            }
        };
    }

    function jsPDF(orientation, unit, format, compressPdf) {
        var options = {};
        if (typeof orientation === 'object') {
            options = orientation;
            orientation = options.orientation;
            unit = options.unit || unit;
            format = options.format || format;
            compressPdf = options.compress || options.compressPdf || compressPdf;
        }
        unit = unit || 'mm';
        format = format || 'a4';
        orientation = ('' + (orientation || 'P')).toLowerCase();
        var format_as_string = ('' + format).toLowerCase(),
            compress = !!compressPdf && typeof Uint8Array === 'function',
            textColor = options.textColor || '0 g',
            drawColor = options.drawColor || '0 G',
            activeFontSize = options.fontSize || 16,
            lineHeightProportion = options.lineHeight || 1.15,
            lineWidth = options.lineWidth || 0.200025,
            objectNumber = 2,
            outToPages = !1,
            offsets = [],
            fonts = {},
            fontmap = {},
            activeFontKey, k, tmp, page = 0,
            currentPage, pages = [],
            pagedim = {},
            content = [],
            lineCapID = 0,
            lineJoinID = 0,
            content_length = 0,
            pageWidth, pageHeight, pageMode, zoomMode, layoutMode, documentProperties = {
                'title': '',
                'subject': '',
                'author': '',
                'keywords': '',
                'creator': ''
            },
            API = {},
            events = new PubSub(API),
            f2 = function(number) {
                return number.toFixed(2);
            },
            f3 = function(number) {
                return number.toFixed(3);
            },
            padd2 = function(number) {
                return ('0' + parseInt(number)).slice(-2);
            },
            out = function(string) {
                if (outToPages) {
                    pages[currentPage].push(string);
                } else {
                    content_length += string.length + 1;
                    content.push(string);
                }
            },
            newObject = function() {
                objectNumber++;
                offsets[objectNumber] = content_length;
                out(objectNumber + ' 0 obj');
                return objectNumber;
            },
            putStream = function(str) {
                out('stream');
                out(str);
                out('endstream');
            },
            putPages = function() {
                var n, p, arr, i, deflater, adler32, adler32cs, wPt, hPt;
                adler32cs = global.adler32cs || jsPDF.adler32cs;
                if (compress && typeof adler32cs === 'undefined') {
                    compress = false;
                }
                for (n = 1; n <= page; n++) {
                    newObject();
                    wPt = (pageWidth = pagedim[n].width) * k;
                    hPt = (pageHeight = pagedim[n].height) * k;
                    out('<</Type /Page');
                    out('/Parent 1 0 R');
                    out('/Resources 2 0 R');
                    out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
                    out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
                    out('endobj');
                    p = pages[n].join('\n');
                    newObject();
                    if (compress) {
                        arr = [];
                        i = p.length;
                        while (i--) {
                            arr[i] = p.charCodeAt(i);
                        }
                        adler32 = adler32cs.from(p);
                        deflater = new Deflater(6);
                        deflater.append(new Uint8Array(arr));
                        p = deflater.flush();
                        arr = new Uint8Array(p.length + 6);
                        arr.set(new Uint8Array([120, 156])), arr.set(p, 2);
                        arr.set(new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF]), p.length + 2);
                        p = String.fromCharCode.apply(null, arr);
                        out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
                    } else {
                        out('<</Length ' + p.length + '>>');
                    }
                    putStream(p);
                    out('endobj');
                }
                offsets[1] = content_length;
                out('1 0 obj');
                out('<</Type /Pages');
                var kids = '/Kids [';
                for (i = 0; i < page; i++) {
                    kids += (3 + 2 * i) + ' 0 R ';
                }
                out(kids + ']');
                out('/Count ' + page);
                out('>>');
                out('endobj');
            },
            putFont = function(font) {
                font.objectNumber = newObject();
                out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
                if (typeof font.encoding === 'string') {
                    out('/Encoding/' + font.encoding);
                }
                out('/Subtype/Type1>>');
                out('endobj');
            },
            putFonts = function() {
                for (var fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        putFont(fonts[fontKey]);
                    }
                }
            },
            putXobjectDict = function() {
                events.publish('putXobjectDict');
            },
            putResourceDictionary = function() {
                out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
                out('/Font <<');
                for (var fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
                    }
                }
                out('>>');
                out('/XObject <<');
                putXobjectDict();
                out('>>');
            },
            putResources = function() {
                putFonts();
                events.publish('putResources');
                offsets[2] = content_length;
                out('2 0 obj');
                out('<<');
                putResourceDictionary();
                out('>>');
                out('endobj');
                events.publish('postPutResources');
            },
            addToFontDictionary = function(fontKey, fontName, fontStyle) {
                if (!fontmap.hasOwnProperty(fontName)) {
                    fontmap[fontName] = {};
                }
                fontmap[fontName][fontStyle] = fontKey;
            },
            addFont = function(PostScriptName, fontName, fontStyle, encoding) {
                var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),
                    font = fonts[fontKey] = {
                        'id': fontKey,
                        'PostScriptName': PostScriptName,
                        'fontName': fontName,
                        'fontStyle': fontStyle,
                        'encoding': encoding,
                        'metadata': {}
                    };
                addToFontDictionary(fontKey, fontName, fontStyle);
                events.publish('addFont', font);
                return fontKey;
            },
            addFonts = function() {
                var HELVETICA = "helvetica",
                    TIMES = "times",
                    COURIER = "courier",
                    NORMAL = "normal",
                    BOLD = "bold",
                    ITALIC = "italic",
                    BOLD_ITALIC = "bolditalic",
                    encoding = 'StandardEncoding',
                    standardFonts = [
                        ['Helvetica', HELVETICA, NORMAL],
                        ['Helvetica-Bold', HELVETICA, BOLD],
                        ['Helvetica-Oblique', HELVETICA, ITALIC],
                        ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
                        ['Courier', COURIER, NORMAL],
                        ['Courier-Bold', COURIER, BOLD],
                        ['Courier-Oblique', COURIER, ITALIC],
                        ['Courier-BoldOblique', COURIER, BOLD_ITALIC],
                        ['Times-Roman', TIMES, NORMAL],
                        ['Times-Bold', TIMES, BOLD],
                        ['Times-Italic', TIMES, ITALIC],
                        ['Times-BoldItalic', TIMES, BOLD_ITALIC]
                    ];
                for (var i = 0, l = standardFonts.length; i < l; i++) {
                    var fontKey = addFont(standardFonts[i][0], standardFonts[i][1], standardFonts[i][2], encoding);
                    var parts = standardFonts[i][0].split('-');
                    addToFontDictionary(fontKey, parts[0], parts[1] || '');
                }
                events.publish('addFonts', {
                    fonts: fonts,
                    dictionary: fontmap
                });
            },
            SAFE = function __safeCall(fn) {
                fn.foo = function __safeCallWrapper() {
                    try {
                        return fn.apply(this, arguments);
                    } catch (e) {
                        var stack = e.stack || '';
                        if (~stack.indexOf(' at ')) stack = stack.split(" at ")[1];
                        var m = "Error in function " + stack.split("\n")[0].split('<')[0] + ": " + e.message;
                        if (global.console) {
                            global.console.error(m, e);
                            if (global.alert) alert(m);
                        } else {
                            throw new Error(m);
                        }
                    }
                };
                fn.foo.bar = fn;
                return fn.foo;
            },
            to8bitStream = function(text, flags) {
                var i, l, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;
                flags = flags || {};
                sourceEncoding = flags.sourceEncoding || 'Unicode';
                outputEncoding = flags.outputEncoding;
                if ((flags.autoencode || outputEncoding) && fonts[activeFontKey].metadata && fonts[activeFontKey].metadata[sourceEncoding] && fonts[activeFontKey].metadata[sourceEncoding].encoding) {
                    encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;
                    if (!outputEncoding && fonts[activeFontKey].encoding) {
                        outputEncoding = fonts[activeFontKey].encoding;
                    }
                    if (!outputEncoding && encodingBlock.codePages) {
                        outputEncoding = encodingBlock.codePages[0];
                    }
                    if (typeof outputEncoding === 'string') {
                        outputEncoding = encodingBlock[outputEncoding];
                    }
                    if (outputEncoding) {
                        isUnicode = false;
                        newtext = [];
                        for (i = 0, l = text.length; i < l; i++) {
                            ch = outputEncoding[text.charCodeAt(i)];
                            if (ch) {
                                newtext.push(String.fromCharCode(ch));
                            } else {
                                newtext.push(text[i]);
                            }
                            if (newtext[i].charCodeAt(0) >> 8) {
                                isUnicode = true;
                            }
                        }
                        text = newtext.join('');
                    }
                }
                i = text.length;
                while (isUnicode === undefined && i !== 0) {
                    if (text.charCodeAt(i - 1) >> 8) {
                        isUnicode = true;
                    }
                    i--;
                }
                if (!isUnicode) {
                    return text;
                }
                newtext = flags.noBOM ? [] : [254, 255];
                for (i = 0, l = text.length; i < l; i++) {
                    ch = text.charCodeAt(i);
                    bch = ch >> 8;
                    if (bch >> 8) {
                        throw new Error("Character at position " + i + " of string '" +
                            text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                    }
                    newtext.push(bch);
                    newtext.push(ch - (bch << 8));
                }
                return String.fromCharCode.apply(undefined, newtext);
            },
            pdfEscape = function(text, flags) {
                return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            },
            putInfo = function() {
                out('/Producer (jsPDF ' + jsPDF.version + ')');
                for (var key in documentProperties) {
                    if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {
                        out('/' + key.substr(0, 1).toUpperCase() + key.substr(1) +
                            ' (' + pdfEscape(documentProperties[key]) + ')');
                    }
                }
                var created = new Date(),
                    tzoffset = created.getTimezoneOffset(),
                    tzsign = tzoffset < 0 ? '+' : '-',
                    tzhour = Math.floor(Math.abs(tzoffset / 60)),
                    tzmin = Math.abs(tzoffset % 60),
                    tzstr = [tzsign, padd2(tzhour), "'", padd2(tzmin), "'"].join('');
                out(['/CreationDate (D:', created.getFullYear(), padd2(created.getMonth() + 1), padd2(created.getDate()), padd2(created.getHours()), padd2(created.getMinutes()), padd2(created.getSeconds()), tzstr, ')'].join(''));
            },
            putCatalog = function() {
                out('/Type /Catalog');
                out('/Pages 1 0 R');
                if (!zoomMode) zoomMode = 'fullwidth';
                switch (zoomMode) {
                    case 'fullwidth':
                        out('/OpenAction [3 0 R /FitH null]');
                        break;
                    case 'fullheight':
                        out('/OpenAction [3 0 R /FitV null]');
                        break;
                    case 'fullpage':
                        out('/OpenAction [3 0 R /Fit]');
                        break;
                    case 'original':
                        out('/OpenAction [3 0 R /XYZ null null 1]');
                        break;
                    default:
                        var pcn = '' + zoomMode;
                        if (pcn.substr(pcn.length - 1) === '%')
                            zoomMode = parseInt(zoomMode) / 100;
                        if (typeof zoomMode === 'number') {
                            out('/OpenAction [3 0 R /XYZ null null ' + f2(zoomMode) + ']');
                        }
                }
                if (!layoutMode) layoutMode = 'continuous';
                switch (layoutMode) {
                    case 'continuous':
                        out('/PageLayout /OneColumn');
                        break;
                    case 'single':
                        out('/PageLayout /SinglePage');
                        break;
                    case 'two':
                    case 'twoleft':
                        out('/PageLayout /TwoColumnLeft');
                        break;
                    case 'tworight':
                        out('/PageLayout /TwoColumnRight');
                        break;
                }
                if (pageMode) {
                    out('/PageMode /' + pageMode);
                }
                events.publish('putCatalog');
            },
            putTrailer = function() {
                out('/Size ' + (objectNumber + 1));
                out('/Root ' + objectNumber + ' 0 R');
                out('/Info ' + (objectNumber - 1) + ' 0 R');
            },
            beginPage = function(width, height) {
                var orientation = typeof height === 'string' && height.toLowerCase();
                if (typeof width === 'string') {
                    var format = width.toLowerCase();
                    if (pageFormats.hasOwnProperty(format)) {
                        width = pageFormats[format][0] / k;
                        height = pageFormats[format][1] / k;
                    }
                }
                if (Array.isArray(width)) {
                    height = width[1];
                    width = width[0];
                }
                if (orientation) {
                    switch (orientation.substr(0, 1)) {
                        case 'l':
                            if (height > width) orientation = 's';
                            break;
                        case 'p':
                            if (width > height) orientation = 's';
                            break;
                    }
                    if (orientation === 's') {
                        tmp = width;
                        width = height;
                        height = tmp;
                    }
                }
                outToPages = true;
                pages[++page] = [];
                pagedim[page] = {
                    width: Number(width) || pageWidth,
                    height: Number(height) || pageHeight
                };
                _setPage(page);
            },
            _addPage = function() {
                beginPage.apply(this, arguments);
                out(f2(lineWidth * k) + ' w');
                out(drawColor);
                if (lineCapID !== 0) {
                    out(lineCapID + ' J');
                }
                if (lineJoinID !== 0) {
                    out(lineJoinID + ' j');
                }
                events.publish('addPage', {
                    pageNumber: page
                });
            },
            _setPage = function(n) {
                if (n > 0 && n <= page) {
                    currentPage = n;
                    pageWidth = pagedim[n].width;
                    pageHeight = pagedim[n].height;
                }
            },
            getFont = function(fontName, fontStyle) {
                var key;
                fontName = fontName !== undefined ? fontName : fonts[activeFontKey].fontName;
                fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;
                try {
                    key = fontmap[fontName][fontStyle];
                } catch (e) {}
                if (!key) {
                    throw new Error("Unable to look up font label for font '" + fontName + "', '" +
                        fontStyle + "'. Refer to getFontList() for available fonts.");
                }
                return key;
            },
            buildDocument = function() {
                outToPages = false;
                objectNumber = 2;
                content = [];
                offsets = [];
                out('%PDF-' + pdfVersion);
                putPages();
                putResources();
                newObject();
                out('<<');
                putInfo();
                out('>>');
                out('endobj');
                newObject();
                out('<<');
                putCatalog();
                out('>>');
                out('endobj');
                var o = content_length,
                    i, p = "0000000000";
                out('xref');
                out('0 ' + (objectNumber + 1));
                out(p + ' 65535 f ');
                for (i = 1; i <= objectNumber; i++) {
                    out((p + offsets[i]).slice(-10) + ' 00000 n ');
                }
                out('trailer');
                out('<<');
                putTrailer();
                out('>>');
                out('startxref');
                out(o);
                out('%%EOF');
                outToPages = true;
                return content.join('\n');
            },
            getStyle = function(style) {
                var op = 'S';
                if (style === 'F') {
                    op = 'f';
                } else if (style === 'FD' || style === 'DF') {
                    op = 'B';
                } else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {
                    op = style;
                }
                return op;
            },
            getArrayBuffer = function() {
                var data = buildDocument(),
                    len = data.length,
                    ab = new ArrayBuffer(len),
                    u8 = new Uint8Array(ab);
                while (len--) u8[len] = data.charCodeAt(len);
                return ab;
            },
            getBlob = function() {
                return new Blob([getArrayBuffer()], {
                    type: "application/pdf"
                });
            },
            output = SAFE(function(type, options) {
                var datauri = ('' + type).substr(0, 6) === 'dataur' ? 'data:application/pdf;base64,' + btoa(buildDocument()) : 0;
                switch (type) {
                    case undefined:
                        return buildDocument();
                    case 'save':
                        if (navigator.getUserMedia) {
                            if (global.URL === undefined || global.URL.createObjectURL === undefined) {
                                return API.output('dataurlnewwindow');
                            }
                        }
                        saveAs(getBlob(), options);
                        if (typeof saveAs.unload === 'function') {
                            if (global.setTimeout) {
                                setTimeout(saveAs.unload, 911);
                            }
                        }
                        break;
                    case 'arraybuffer':
                        return getArrayBuffer();
                    case 'blob':
                        return getBlob();
                    case 'bloburi':
                    case 'bloburl':
                        return global.URL && global.URL.createObjectURL(getBlob()) || void 0;
                    case 'datauristring':
                    case 'dataurlstring':
                        return datauri;
                    case 'dataurlnewwindow':
                        var nW = global.open(datauri);
                        if (nW || typeof safari === "undefined") return nW;
                    case 'datauri':
                    case 'dataurl':
                        return global.document.location.href = datauri;
                    default:
                        throw new Error('Output type "' + type + '" is not supported.');
                }
            });
        switch (unit) {
            case 'pt':
                k = 1;
                break;
            case 'mm':
                k = 72 / 25.4;
                break;
            case 'cm':
                k = 72 / 2.54;
                break;
            case 'in':
                k = 72;
                break;
            case 'px':
                k = 96 / 72;
                break;
            case 'pc':
                k = 12;
                break;
            case 'em':
                k = 12;
                break;
            case 'ex':
                k = 6;
                break;
            default:
                throw ('Invalid unit: ' + unit);
        }
        API.internal = {
            'pdfEscape': pdfEscape,
            'getStyle': getStyle,
            'getFont': function() {
                return fonts[getFont.apply(API, arguments)];
            },
            'getFontSize': function() {
                return activeFontSize;
            },
            'getLineHeight': function() {
                return activeFontSize * lineHeightProportion;
            },
            'write': function(string1) {
                out(arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' '));
            },
            'getCoordinateString': function(value) {
                return f2(value * k);
            },
            'getVerticalCoordinateString': function(value) {
                return f2((pageHeight - value) * k);
            },
            'collections': {},
            'newObject': newObject,
            'putStream': putStream,
            'events': events,
            'scaleFactor': k,
            'pageSize': {
                get width() {
                    return pageWidth
                },
                get height() {
                    return pageHeight
                }
            },
            'output': function(type, options) {
                return output(type, options);
            },
            'getNumberOfPages': function() {
                return pages.length - 1;
            },
            'pages': pages
        };
        API.addPage = function() {
            _addPage.apply(this, arguments);
            return this;
        };
        API.setPage = function() {
            _setPage.apply(this, arguments);
            return this;
        };
        API.setDisplayMode = function(zoom, layout, pmode) {
            zoomMode = zoom;
            layoutMode = layout;
            pageMode = pmode;
            return this;
        }, API.text = function(text, x, y, flags, angle) {
            function ESC(s) {
                s = s.split("\t").join(Array(options.TabLen || 9).join(" "));
                return pdfEscape(s, flags);
            }
            if (typeof text === 'number') {
                tmp = y;
                y = x;
                x = text;
                text = tmp;
            }
            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }
            if (typeof flags === 'number') {
                angle = flags;
                flags = null;
            }
            var xtra = '',
                mode = 'Td',
                todo;
            if (angle) {
                angle *= (Math.PI / 180);
                var c = Math.cos(angle),
                    s = Math.sin(angle);
                xtra = [f2(c), f2(s), f2(s * -1), f2(c), ''].join(" ");
                mode = 'Tm';
            }
            flags = flags || {};
            if (!('noBOM' in flags))
                flags.noBOM = true;
            if (!('autoencode' in flags))
                flags.autoencode = true;
            if (typeof text === 'string') {
                text = ESC(text);
            } else if (text instanceof Array) {
                var sa = text.concat(),
                    da = [],
                    len = sa.length;
                while (len--) {
                    da.push(ESC(sa.shift()));
                }
                var linesLeft = Math.ceil((pageHeight - y) * k / (activeFontSize * lineHeightProportion));
                if (0 <= linesLeft && linesLeft < da.length + 1) {
                    todo = da.splice(linesLeft - 1);
                }
                text = da.join(") Tj\nT* (");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            out('BT\n/' +
                activeFontKey + ' ' + activeFontSize + ' Tf\n' +
                (activeFontSize * lineHeightProportion) + ' TL\n' +
                textColor + '\n' + xtra + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' ' + mode + '\n(' +
                text + ') Tj\nET');
            if (todo) {
                this.addPage();
                this.text(todo, x, activeFontSize * 1.7 / k);
            }
            return this;
        };
        API.lstext = function(text, x, y, spacing) {
            for (var i = 0, len = text.length; i < len; i++, x += spacing) this.text(text[i], x, y);
        };
        API.line = function(x1, y1, x2, y2) {
            return this.lines([
                [x2 - x1, y2 - y1]
            ], x1, y1);
        };
        API.clip = function() {
            out('W')
            out('S')
        };
        API.lines = function(lines, x, y, scale, style, closed) {
            var scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;
            if (typeof lines === 'number') {
                tmp = y;
                y = x;
                x = lines;
                lines = tmp;
            }
            scale = scale || [1, 1];
            out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');
            scalex = scale[0];
            scaley = scale[1];
            l = lines.length;
            x4 = x;
            y4 = y;
            for (i = 0; i < l; i++) {
                leg = lines[i];
                if (leg.length === 2) {
                    x4 = leg[0] * scalex + x4;
                    y4 = leg[1] * scaley + y4;
                    out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
                } else {
                    x2 = leg[0] * scalex + x4;
                    y2 = leg[1] * scaley + y4;
                    x3 = leg[2] * scalex + x4;
                    y3 = leg[3] * scaley + y4;
                    x4 = leg[4] * scalex + x4;
                    y4 = leg[5] * scaley + y4;
                    out(f3(x2 * k) + ' ' +
                        f3((pageHeight - y2) * k) + ' ' +
                        f3(x3 * k) + ' ' +
                        f3((pageHeight - y3) * k) + ' ' +
                        f3(x4 * k) + ' ' +
                        f3((pageHeight - y4) * k) + ' c');
                }
            }
            if (closed) {
                out(' h');
            }
            if (style !== null) {
                out(getStyle(style));
            }
            return this;
        };
        API.rect = function(x, y, w, h, style) {
            var op = getStyle(style);
            out([f2(x * k), f2((pageHeight - y) * k), f2(w * k), f2(-h * k), 're'].join(' '));
            if (style !== null) {
                out(getStyle(style));
            }
            return this;
        };
        API.triangle = function(x1, y1, x2, y2, x3, y3, style) {
            this.lines([
                [x2 - x1, y2 - y1],
                [x3 - x2, y3 - y2],
                [x1 - x3, y1 - y3]
            ], x1, y1, [1, 1], style, true);
            return this;
        };
        API.roundedRect = function(x, y, w, h, rx, ry, style) {
            var MyArc = 4 / 3 * (Math.SQRT2 - 1);
            this.lines([
                [(w - 2 * rx), 0],
                [(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],
                [0, (h - 2 * ry)],
                [0, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                [(-w + 2 * rx), 0],
                [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],
                [0, (-h + 2 * ry)],
                [0, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
            ], x + rx, y, [1, 1], style);
            return this;
        };
        API.ellipse = function(x, y, rx, ry, style) {
            var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
                ly = 4 / 3 * (Math.SQRT2 - 1) * ry;
            out([f2((x + rx) * k), f2((pageHeight - y) * k), 'm', f2((x + rx) * k), f2((pageHeight - (y - ly)) * k), f2((x + lx) * k), f2((pageHeight - (y - ry)) * k), f2(x * k), f2((pageHeight - (y - ry)) * k), 'c'].join(' '));
            out([f2((x - lx) * k), f2((pageHeight - (y - ry)) * k), f2((x - rx) * k), f2((pageHeight - (y - ly)) * k), f2((x - rx) * k), f2((pageHeight - y) * k), 'c'].join(' '));
            out([f2((x - rx) * k), f2((pageHeight - (y + ly)) * k), f2((x - lx) * k), f2((pageHeight - (y + ry)) * k), f2(x * k), f2((pageHeight - (y + ry)) * k), 'c'].join(' '));
            out([f2((x + lx) * k), f2((pageHeight - (y + ry)) * k), f2((x + rx) * k), f2((pageHeight - (y + ly)) * k), f2((x + rx) * k), f2((pageHeight - y) * k), 'c'].join(' '));
            if (style !== null) {
                out(getStyle(style));
            }
            return this;
        };
        API.circle = function(x, y, r, style) {
            return this.ellipse(x, y, r, r, style);
        };
        API.setProperties = function(properties) {
            for (var property in documentProperties) {
                if (documentProperties.hasOwnProperty(property) && properties[property]) {
                    documentProperties[property] = properties[property];
                }
            }
            return this;
        };
        API.setFontSize = function(size) {
            activeFontSize = size;
            return this;
        };
        API.setFont = function(fontName, fontStyle) {
            activeFontKey = getFont(fontName, fontStyle);
            return this;
        };
        API.setFontStyle = API.setFontType = function(style) {
            activeFontKey = getFont(undefined, style);
            return this;
        };
        API.getFontList = function() {
            var list = {},
                fontName, fontStyle, tmp;
            for (fontName in fontmap) {
                if (fontmap.hasOwnProperty(fontName)) {
                    list[fontName] = tmp = [];
                    for (fontStyle in fontmap[fontName]) {
                        if (fontmap[fontName].hasOwnProperty(fontStyle)) {
                            tmp.push(fontStyle);
                        }
                    }
                }
            }
            return list;
        };
        API.setLineWidth = function(width) {
            out((width * k).toFixed(2) + ' w');
            return this;
        };
        API.setDrawColor = function(ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                if (typeof ch1 === 'string') {
                    color = ch1 + ' G';
                } else {
                    color = f2(ch1 / 255) + ' G';
                }
            } else if (ch4 === undefined) {
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'RG'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
                }
            } else {
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
                }
            }
            out(color);
            return this;
        };
        API.setFillColor = function(ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                if (typeof ch1 === 'string') {
                    color = ch1 + ' g';
                } else {
                    color = f2(ch1 / 255) + ' g';
                }
            } else if (ch4 === undefined) {
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'rg'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
                }
            } else {
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
                }
            }
            out(color);
            return this;
        };
        API.setTextColor = function(r, g, b) {
            if ((typeof r === 'string') && /^#[0-9A-Fa-f]{6}$/.test(r)) {
                var hex = parseInt(r.substr(1), 16);
                r = (hex >> 16) & 255;
                g = (hex >> 8) & 255;
                b = (hex & 255);
            }
            if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
                textColor = f3(r / 255) + ' g';
            } else {
                textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
            }
            return this;
        };
        API.CapJoinStyles = {
            0: 0,
            'butt': 0,
            'but': 0,
            'miter': 0,
            1: 1,
            'round': 1,
            'rounded': 1,
            'circle': 1,
            2: 2,
            'projecting': 2,
            'project': 2,
            'square': 2,
            'bevel': 2
        };
        API.setLineCap = function(style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineCapID = id;
            out(id + ' J');
            return this;
        };
        API.setLineJoin = function(style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineJoinID = id;
            out(id + ' j');
            return this;
        };
        API.output = output;
        API.save = function(filename) {
            API.output('save', filename);
        };
        for (var plugin in jsPDF.API) {
            if (jsPDF.API.hasOwnProperty(plugin)) {
                if (plugin === 'events' && jsPDF.API.events.length) {
                    (function(events, newEvents) {
                        var eventname, handler_and_args, i;
                        for (i = newEvents.length - 1; i !== -1; i--) {
                            eventname = newEvents[i][0];
                            handler_and_args = newEvents[i][1];
                            events.subscribe.apply(events, [eventname].concat(typeof handler_and_args === 'function' ? [handler_and_args] : handler_and_args));
                        }
                    }(events, jsPDF.API.events));
                } else {
                    API[plugin] = jsPDF.API[plugin];
                }
            }
        }
        addFonts();
        activeFontKey = 'F1';
        _addPage(format, orientation);
        events.publish('initialized');
        return API;
    }
    jsPDF.API = {
        events: []
    };
    jsPDF.version = "1.0.272-debug 2014-09-29T15:09:diegocr";
    if (typeof define === 'function' && define.amd) {
        define('jsPDF', function() {
            return jsPDF;
        });
    } else {
        global.jsPDF = jsPDF;
    }
    return jsPDF;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this));
(function(jsPDFAPI) {
    'use strict';
    jsPDFAPI.addHTML = function(element, x, y, options, callback) {
        'use strict';
        if (typeof html2canvas === 'undefined' && typeof rasterizeHTML === 'undefined')
            throw new Error('You need either ' +
                'https://github.com/niklasvh/html2canvas' +
                ' or https://github.com/cburgmer/rasterizeHTML.js');
        if (typeof x !== 'number') {
            options = x;
            callback = y;
        }
        if (typeof options === 'function') {
            callback = options;
            options = null;
        }
        var I = this.internal,
            K = I.scaleFactor,
            W = I.pageSize.width,
            H = I.pageSize.height;
        options = options || {};
        options.onrendered = function(obj) {
            x = parseInt(x) || 0;
            y = parseInt(y) || 0;
            var dim = options.dim || {};
            var h = dim.h || 0;
            var w = dim.w || Math.min(W, obj.width / K) - x;
            var format = 'JPEG';
            if (options.format)
                format = options.format;
            if (obj.height > H && options.pagesplit) {
                var crop = function() {
                    var cy = 0;
                    while (1) {
                        var canvas = document.createElement('canvas');
                        canvas.width = Math.min(W * K, obj.width);
                        canvas.height = Math.min(H * K, obj.height - cy);
                        var ctx = canvas.getContext('2d');
                        ctx.drawImage(obj, 0, cy, obj.width, canvas.height, 0, 0, canvas.width, canvas.height);
                        var args = [canvas, x, cy ? 0 : y, canvas.width / K, canvas.height / K, format, null, 'SLOW'];
                        this.addImage.apply(this, args);
                        cy += canvas.height;
                        if (cy >= obj.height) break;
                        this.addPage();
                    }
                    callback(w, cy, null, args);
                }.bind(this);
                if (obj.nodeName === 'CANVAS') {
                    var img = new Image();
                    img.onload = crop;
                    img.src = obj.toDataURL("image/png");
                    obj = img;
                } else {
                    crop();
                }
            } else {
                var alias = Math.random().toString(35);
                var args = [obj, x, y, w, h, format, alias, 'SLOW'];
                this.addImage.apply(this, args);
                callback(w, h, alias, args);
            }
        }.bind(this);
        if (typeof html2canvas !== 'undefined' && !options.rstz) {
            return html2canvas(element, options);
        }
        if (typeof rasterizeHTML !== 'undefined') {
            var meth = 'drawDocument';
            if (typeof element === 'string') {
                meth = /^http/.test(element) ? 'drawURL' : 'drawHTML';
            }
            options.width = options.width || (W * K);
            return rasterizeHTML[meth](element, void 0, options).then(function(r) {
                options.onrendered(r.image);
            }, function(e) {
                callback(null, e);
            });
        }
        return null;
    };
})(jsPDF.API);;
(function(jsPDFAPI) {
    'use strict'
    var namespace = 'addImage_',
        supported_image_types = ['jpeg', 'jpg', 'png'];
    var putImage = function(img) {
            var objectNumber = this.internal.newObject(),
                out = this.internal.write,
                putStream = this.internal.putStream
            img['n'] = objectNumber
            out('<</Type /XObject')
            out('/Subtype /Image')
            out('/Width ' + img['w'])
            out('/Height ' + img['h'])
            if (img['cs'] === this.color_spaces.INDEXED) {
                out('/ColorSpace [/Indexed /DeviceRGB ' +
                    (img['pal'].length / 3 - 1) + ' ' + ('smask' in img ? objectNumber + 2 : objectNumber + 1) +
                    ' 0 R]');
            } else {
                out('/ColorSpace /' + img['cs']);
                if (img['cs'] === this.color_spaces.DEVICE_CMYK) {
                    out('/Decode [1 0 1 0 1 0 1 0]');
                }
            }
            out('/BitsPerComponent ' + img['bpc']);
            if ('f' in img) {
                out('/Filter /' + img['f']);
            }
            if ('dp' in img) {
                out('/DecodeParms <<' + img['dp'] + '>>');
            }
            if ('trns' in img && img['trns'].constructor == Array) {
                var trns = '',
                    i = 0,
                    len = img['trns'].length;
                for (; i < len; i++)
                    trns += (img['trns'][i] + ' ' + img['trns'][i] + ' ');
                out('/Mask [' + trns + ']');
            }
            if ('smask' in img) {
                out('/SMask ' + (objectNumber + 1) + ' 0 R');
            }
            out('/Length ' + img['data'].length + '>>');
            putStream(img['data']);
            out('endobj');
            if ('smask' in img) {
                var dp = '/Predictor 15 /Colors 1 /BitsPerComponent ' + img['bpc'] + ' /Columns ' + img['w'];
                var smask = {
                    'w': img['w'],
                    'h': img['h'],
                    'cs': 'DeviceGray',
                    'bpc': img['bpc'],
                    'dp': dp,
                    'data': img['smask']
                };
                if ('f' in img)
                    smask.f = img['f'];
                putImage.call(this, smask);
            }
            if (img['cs'] === this.color_spaces.INDEXED) {
                this.internal.newObject();
                out('<< /Length ' + img['pal'].length + '>>');
                putStream(this.arrayBufferToBinaryString(new Uint8Array(img['pal'])));
                out('endobj');
            }
        },
        putResourcesCallback = function() {
            var images = this.internal.collections[namespace + 'images']
            for (var i in images) {
                putImage.call(this, images[i])
            }
        },
        putXObjectsDictCallback = function() {
            var images = this.internal.collections[namespace + 'images'],
                out = this.internal.write,
                image
            for (var i in images) {
                image = images[i]
                out('/I' + image['i'], image['n'], '0', 'R')
            }
        },
        checkCompressValue = function(value) {
            if (value && typeof value === 'string')
                value = value.toUpperCase();
            return value in jsPDFAPI.image_compression ? value : jsPDFAPI.image_compression.NONE;
        },
        getImages = function() {
            var images = this.internal.collections[namespace + 'images'];
            if (!images) {
                this.internal.collections[namespace + 'images'] = images = {};
                this.internal.events.subscribe('putResources', putResourcesCallback);
                this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback);
            }
            return images;
        },
        getImageIndex = function(images) {
            var imageIndex = 0;
            if (images) {
                imageIndex = Object.keys ? Object.keys(images).length : (function(o) {
                    var i = 0
                    for (var e in o) {
                        if (o.hasOwnProperty(e)) {
                            i++
                        }
                    }
                    return i
                })(images)
            }
            return imageIndex;
        },
        notDefined = function(value) {
            return typeof value === 'undefined' || value === null;
        },
        generateAliasFromData = function(data) {
            return typeof data === 'string' && jsPDFAPI.sHashCode(data);
        },
        doesNotSupportImageType = function(type) {
            return supported_image_types.indexOf(type) === -1;
        },
        processMethodNotEnabled = function(type) {
            return typeof jsPDFAPI['process' + type.toUpperCase()] !== 'function';
        },
        isDOMElement = function(object) {
            return typeof object === 'object' && object.nodeType === 1;
        },
        createDataURIFromElement = function(element, format, angle) {
            if (element.nodeName === 'IMG' && element.hasAttribute('src')) {
                var src = '' + element.getAttribute('src');
                if (!angle && src.indexOf('data:image/') === 0) return src;
                if (!format && /\.png(?:[?#].*)?$/i.test(src)) format = 'png';
            }
            if (element.nodeName === 'CANVAS') {
                var canvas = element;
            } else {
                var canvas = document.createElement('canvas');
                canvas.width = element.clientWidth || element.width;
                canvas.height = element.clientHeight || element.height;
                var ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw ('addImage requires canvas to be supported by browser.');
                }
                if (angle) {
                    var x, y, b, c, s, w, h, to_radians = Math.PI / 180,
                        angleInRadians;
                    if (typeof angle === 'object') {
                        x = angle.x;
                        y = angle.y;
                        b = angle.bg;
                        angle = angle.angle;
                    }
                    angleInRadians = angle * to_radians;
                    c = Math.abs(Math.cos(angleInRadians));
                    s = Math.abs(Math.sin(angleInRadians));
                    w = canvas.width;
                    h = canvas.height;
                    canvas.width = h * s + w * c;
                    canvas.height = h * c + w * s;
                    if (isNaN(x)) x = canvas.width / 2;
                    if (isNaN(y)) y = canvas.height / 2;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = b || 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angleInRadians);
                    ctx.drawImage(element, -(w / 2), -(h / 2));
                    ctx.rotate(-angleInRadians);
                    ctx.translate(-x, -y);
                    ctx.restore();
                } else {
                    ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
                }
            }
            return canvas.toDataURL(('' + format).toLowerCase() == 'png' ? 'image/png' : 'image/jpeg');
        },
        checkImagesForAlias = function(alias, images) {
            var cached_info;
            if (images) {
                for (var e in images) {
                    if (alias === images[e].alias) {
                        cached_info = images[e];
                        break;
                    }
                }
            }
            return cached_info;
        },
        determineWidthAndHeight = function(w, h, info) {
            if (!w && !h) {
                w = -96;
                h = -96;
            }
            if (w < 0) {
                w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
            }
            if (h < 0) {
                h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
            }
            if (w === 0) {
                w = h * info['w'] / info['h'];
            }
            if (h === 0) {
                h = w * info['h'] / info['w'];
            }
            return [w, h];
        },
        writeImageToPDF = function(x, y, w, h, info, index, images) {
            var dims = determineWidthAndHeight.call(this, w, h, info),
                coord = this.internal.getCoordinateString,
                vcoord = this.internal.getVerticalCoordinateString;
            w = dims[0];
            h = dims[1];
            images[index] = info;
            this.internal.write('q', coord(w), '0 0', coord(h), coord(x), vcoord(y + h), 'cm /I' + info['i'], 'Do Q')
        };
    jsPDFAPI.color_spaces = {
        DEVICE_RGB: 'DeviceRGB',
        DEVICE_GRAY: 'DeviceGray',
        DEVICE_CMYK: 'DeviceCMYK',
        CAL_GREY: 'CalGray',
        CAL_RGB: 'CalRGB',
        LAB: 'Lab',
        ICC_BASED: 'ICCBased',
        INDEXED: 'Indexed',
        PATTERN: 'Pattern',
        SEPERATION: 'Seperation',
        DEVICE_N: 'DeviceN'
    };
    jsPDFAPI.decode = {
        DCT_DECODE: 'DCTDecode',
        FLATE_DECODE: 'FlateDecode',
        LZW_DECODE: 'LZWDecode',
        JPX_DECODE: 'JPXDecode',
        JBIG2_DECODE: 'JBIG2Decode',
        ASCII85_DECODE: 'ASCII85Decode',
        ASCII_HEX_DECODE: 'ASCIIHexDecode',
        RUN_LENGTH_DECODE: 'RunLengthDecode',
        CCITT_FAX_DECODE: 'CCITTFaxDecode'
    };
    jsPDFAPI.image_compression = {
        NONE: 'NONE',
        FAST: 'FAST',
        MEDIUM: 'MEDIUM',
        SLOW: 'SLOW'
    };
    jsPDFAPI.sHashCode = function(str) {
        return Array.prototype.reduce && str.split("").reduce(function(a, b) {
            a = ((a << 5) - a) + b.charCodeAt(0);
            return a & a
        }, 0);
    };
    jsPDFAPI.isString = function(object) {
        return typeof object === 'string';
    };
    jsPDFAPI.extractInfoFromBase64DataURI = function(dataURI) {
        return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(dataURI);
    };
    jsPDFAPI.supportsArrayBuffer = function() {
        return typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';
    };
    jsPDFAPI.isArrayBuffer = function(object) {
        if (!this.supportsArrayBuffer())
            return false;
        return object instanceof ArrayBuffer;
    };
    jsPDFAPI.isArrayBufferView = function(object) {
        if (!this.supportsArrayBuffer())
            return false;
        if (typeof Uint32Array === 'undefined')
            return false;
        return (object instanceof Int8Array || object instanceof Uint8Array || (typeof Uint8ClampedArray !== 'undefined' && object instanceof Uint8ClampedArray) || object instanceof Int16Array || object instanceof Uint16Array || object instanceof Int32Array || object instanceof Uint32Array || object instanceof Float32Array || object instanceof Float64Array);
    };
    jsPDFAPI.binaryStringToUint8Array = function(binary_string) {
        var len = binary_string.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    };
    jsPDFAPI.arrayBufferToBinaryString = function(buffer) {
        if (this.isArrayBuffer(buffer))
            buffer = new Uint8Array(buffer);
        var binary_string = '';
        var len = buffer.byteLength;
        for (var i = 0; i < len; i++) {
            binary_string += String.fromCharCode(buffer[i]);
        }
        return binary_string;
    };
    jsPDFAPI.arrayBufferToBase64 = function(arrayBuffer) {
        var base64 = ''
        var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        var bytes = new Uint8Array(arrayBuffer)
        var byteLength = bytes.byteLength
        var byteRemainder = byteLength % 3
        var mainLength = byteLength - byteRemainder
        var a, b, c, d
        var chunk
        for (var i = 0; i < mainLength; i = i + 3) {
            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]
            a = (chunk & 16515072) >> 18
            b = (chunk & 258048) >> 12
            c = (chunk & 4032) >> 6
            d = chunk & 63
            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
        }
        if (byteRemainder == 1) {
            chunk = bytes[mainLength]
            a = (chunk & 252) >> 2
            b = (chunk & 3) << 4
            base64 += encodings[a] + encodings[b] + '=='
        } else if (byteRemainder == 2) {
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]
            a = (chunk & 64512) >> 10
            b = (chunk & 1008) >> 4
            c = (chunk & 15) << 2
            base64 += encodings[a] + encodings[b] + encodings[c] + '='
        }
        return base64
    };
    jsPDFAPI.createImageInfo = function(data, wd, ht, cs, bpc, f, imageIndex, alias, dp, trns, pal, smask) {
        var info = {
            alias: alias,
            w: wd,
            h: ht,
            cs: cs,
            bpc: bpc,
            i: imageIndex,
            data: data
        };
        if (f) info.f = f;
        if (dp) info.dp = dp;
        if (trns) info.trns = trns;
        if (pal) info.pal = pal;
        if (smask) info.smask = smask;
        return info;
    };
    jsPDFAPI.addImage = function(imageData, format, x, y, w, h, alias, compression, rotation) {
        'use strict'
        if (typeof format !== 'string') {
            var tmp = h;
            h = w;
            w = y;
            y = x;
            x = format;
            format = tmp;
        }
        if (typeof imageData === 'object' && !isDOMElement(imageData) && "imageData" in imageData) {
            var options = imageData;
            imageData = options.imageData;
            format = options.format || format;
            x = options.x || x || 0;
            y = options.y || y || 0;
            w = options.w || w;
            h = options.h || h;
            alias = options.alias || alias;
            compression = options.compression || compression;
            rotation = options.rotation || options.angle || rotation;
        }
        if (isNaN(x) || isNaN(y)) {
            console.error('jsPDF.addImage: Invalid coordinates', arguments);
            throw new Error('Invalid coordinates passed to jsPDF.addImage');
        }
        var images = getImages.call(this),
            info;
        if (!(info = checkImagesForAlias(imageData, images))) {
            var dataAsBinaryString;
            if (isDOMElement(imageData))
                imageData = createDataURIFromElement(imageData, format, rotation);
            if (notDefined(alias))
                alias = generateAliasFromData(imageData);
            if (!(info = checkImagesForAlias(alias, images))) {
                if (this.isString(imageData)) {
                    var base64Info = this.extractInfoFromBase64DataURI(imageData);
                    if (base64Info) {
                        format = base64Info[2];
                        imageData = atob(base64Info[3]);
                    } else {
                        if (imageData.charCodeAt(0) === 0x89 && imageData.charCodeAt(1) === 0x50 && imageData.charCodeAt(2) === 0x4e && imageData.charCodeAt(3) === 0x47) format = 'png';
                    }
                }
                format = (format || 'JPEG').toLowerCase();
                if (doesNotSupportImageType(format))
                    throw new Error('addImage currently only supports formats ' + supported_image_types + ', not \'' + format + '\'');
                if (processMethodNotEnabled(format))
                    throw new Error('please ensure that the plugin for \'' + format + '\' support is added');
                if (this.supportsArrayBuffer()) {
                    dataAsBinaryString = imageData;
                    imageData = this.binaryStringToUint8Array(imageData);
                }
                info = this['process' + format.toUpperCase()](imageData, getImageIndex(images), alias, checkCompressValue(compression), dataAsBinaryString);
                if (!info)
                    throw new Error('An unkwown error occurred whilst processing the image');
            }
        }
        writeImageToPDF.call(this, x, y, w, h, info, info.i, images);
        return this
    };
    var getJpegSize = function(imgData) {
            'use strict'
            var width, height, numcomponents;
            if (!imgData.charCodeAt(0) === 0xff || !imgData.charCodeAt(1) === 0xd8 || !imgData.charCodeAt(2) === 0xff || !imgData.charCodeAt(3) === 0xe0 || !imgData.charCodeAt(6) === 'J'.charCodeAt(0) || !imgData.charCodeAt(7) === 'F'.charCodeAt(0) || !imgData.charCodeAt(8) === 'I'.charCodeAt(0) || !imgData.charCodeAt(9) === 'F'.charCodeAt(0) || !imgData.charCodeAt(10) === 0x00) {
                throw new Error('getJpegSize requires a binary string jpeg file')
            }
            var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
            var i = 4,
                len = imgData.length;
            while (i < len) {
                i += blockLength;
                if (imgData.charCodeAt(i) !== 0xff) {
                    throw new Error('getJpegSize could not find the size of the image');
                }
                if (imgData.charCodeAt(i + 1) === 0xc0 || imgData.charCodeAt(i + 1) === 0xc1 || imgData.charCodeAt(i + 1) === 0xc2 || imgData.charCodeAt(i + 1) === 0xc3 || imgData.charCodeAt(i + 1) === 0xc4 || imgData.charCodeAt(i + 1) === 0xc5 || imgData.charCodeAt(i + 1) === 0xc6 || imgData.charCodeAt(i + 1) === 0xc7) {
                    height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);
                    width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);
                    numcomponents = imgData.charCodeAt(i + 9);
                    return [width, height, numcomponents];
                } else {
                    i += 2;
                    blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1)
                }
            }
        },
        getJpegSizeFromBytes = function(data) {
            var hdr = (data[0] << 8) | data[1];
            if (hdr !== 0xFFD8)
                throw new Error('Supplied data is not a JPEG');
            var len = data.length,
                block = (data[4] << 8) + data[5],
                pos = 4,
                bytes, width, height, numcomponents;
            while (pos < len) {
                pos += block;
                bytes = readBytes(data, pos);
                block = (bytes[2] << 8) + bytes[3];
                if ((bytes[1] === 0xC0 || bytes[1] === 0xC2) && bytes[0] === 0xFF && block > 7) {
                    bytes = readBytes(data, pos + 5);
                    width = (bytes[2] << 8) + bytes[3];
                    height = (bytes[0] << 8) + bytes[1];
                    numcomponents = bytes[4];
                    return {
                        width: width,
                        height: height,
                        numcomponents: numcomponents
                    };
                }
                pos += 2;
            }
            throw new Error('getJpegSizeFromBytes could not find the size of the image');
        },
        readBytes = function(data, offset) {
            return data.subarray(offset, offset + 5);
        };
    jsPDFAPI.processJPEG = function(data, index, alias, compression, dataAsBinaryString) {
        'use strict'
        var colorSpace = this.color_spaces.DEVICE_RGB,
            filter = this.decode.DCT_DECODE,
            bpc = 8,
            dims;
        if (this.isString(data)) {
            dims = getJpegSize(data);
            return this.createImageInfo(data, dims[0], dims[1], dims[3] == 1 ? this.color_spaces.DEVICE_GRAY : colorSpace, bpc, filter, index, alias);
        }
        if (this.isArrayBuffer(data))
            data = new Uint8Array(data);
        if (this.isArrayBufferView(data)) {
            dims = getJpegSizeFromBytes(data);
            data = dataAsBinaryString || this.arrayBufferToBinaryString(data);
            return this.createImageInfo(data, dims.width, dims.height, dims.numcomponents == 1 ? this.color_spaces.DEVICE_GRAY : colorSpace, bpc, filter, index, alias);
        }
        return null;
    };
    jsPDFAPI.processJPG = function() {
        return this.processJPEG.apply(this, arguments);
    }
})(jsPDF.API);
(function(jsPDFAPI) {
    'use strict';
    jsPDFAPI.autoPrint = function() {
        'use strict'
        var refAutoPrintTag;
        this.internal.events.subscribe('postPutResources', function() {
            refAutoPrintTag = this.internal.newObject()
            this.internal.write("<< /S/Named /Type/Action /N/Print >>", "endobj");
        });
        this.internal.events.subscribe("putCatalog", function() {
            this.internal.write("/OpenAction " + refAutoPrintTag + " 0" + " R");
        });
        return this;
    };
})(jsPDF.API);
(function(jsPDFAPI) {
    'use strict';
    var fontName, fontSize, fontStyle, padding = 3,
        margin = 13,
        headerFunction, lastCellPos = {
            x: undefined,
            y: undefined,
            w: undefined,
            h: undefined,
            ln: undefined
        },
        pages = 1,
        setLastCellPosition = function(x, y, w, h, ln) {
            lastCellPos = {
                'x': x,
                'y': y,
                'w': w,
                'h': h,
                'ln': ln
            };
        },
        getLastCellPosition = function() {
            return lastCellPos;
        },
        NO_MARGINS = {
            left: 0,
            top: 0,
            bottom: 0
        };
    jsPDFAPI.setHeaderFunction = function(func) {
        headerFunction = func;
    };
    jsPDFAPI.getTextDimensions = function(txt) {
        fontName = this.internal.getFont().fontName;
        fontSize = this.table_font_size || this.internal.getFontSize();
        fontStyle = this.internal.getFont().fontStyle;
        var px2pt = 0.264583 * 72 / 25.4,
            dimensions, text;
        text = document.createElement('font');
        text.id = "jsPDFCell";
        text.style.fontStyle = fontStyle;
        text.style.fontName = fontName;
        text.style.fontSize = fontSize + 'pt';
        text.textContent = txt;
        document.body.appendChild(text);
        dimensions = {
            w: (text.offsetWidth + 1) * px2pt,
            h: (text.offsetHeight + 1) * px2pt
        };
        document.body.removeChild(text);
        return dimensions;
    };
    jsPDFAPI.cellAddPage = function() {
        var margins = this.margins || NO_MARGINS;
        this.addPage();
        setLastCellPosition(margins.left, margins.top, undefined, undefined);
        pages += 1;
    };
    jsPDFAPI.cellInitialize = function() {
        lastCellPos = {
            x: undefined,
            y: undefined,
            w: undefined,
            h: undefined,
            ln: undefined
        };
        pages = 1;
    };
    jsPDFAPI.cell = function(x, y, w, h, txt, ln, align) {
        var curCell = getLastCellPosition();
        if (curCell.ln !== undefined) {
            if (curCell.ln === ln) {
                x = curCell.x + curCell.w;
                y = curCell.y;
            } else {
                var margins = this.margins || NO_MARGINS;
                if ((curCell.y + curCell.h + h + margin) >= this.internal.pageSize.height - margins.bottom) {
                    this.cellAddPage();
                    if (this.printHeaders && this.tableHeaderRow) {
                        this.printHeaderRow(ln, true);
                    }
                }
                y = (getLastCellPosition().y + getLastCellPosition().h);
            }
        }
        if (txt[0] !== undefined) {
            if (this.printingHeaderRow) {
                this.rect(x, y, w, h, 'FD');
            } else {
                this.rect(x, y, w, h);
            }
            if (align === 'right') {
                if (txt instanceof Array) {
                    for (var i = 0; i < txt.length; i++) {
                        var currentLine = txt[i];
                        var textSize = this.getStringUnitWidth(currentLine) * this.internal.getFontSize();
                        this.text(currentLine, x + w - textSize - padding, y + this.internal.getLineHeight() * (i + 1));
                    }
                }
            } else {
                this.text(txt, x + padding, y + this.internal.getLineHeight());
            }
        }
        setLastCellPosition(x, y, w, h, ln);
        return this;
    };
    jsPDFAPI.arrayMax = function(array, comparisonFn) {
        var max = array[0],
            i, ln, item;
        for (i = 0, ln = array.length; i < ln; i += 1) {
            item = array[i];
            if (comparisonFn) {
                if (comparisonFn(max, item) === -1) {
                    max = item;
                }
            } else {
                if (item > max) {
                    max = item;
                }
            }
        }
        return max;
    };
    jsPDFAPI.table = function(x, y, data, headers, config) {
        if (!data) {
            throw 'No data for PDF table';
        }
        var headerNames = [],
            headerPrompts = [],
            header, i, ln, cln, columnMatrix = {},
            columnWidths = {},
            columnData, column, columnMinWidths = [],
            j, tableHeaderConfigs = [],
            model, jln, func, autoSize = false,
            printHeaders = true,
            fontSize = 12,
            margins = NO_MARGINS;
        margins.width = this.internal.pageSize.width;
        if (config) {
            if (config.autoSize === true) {
                autoSize = true;
            }
            if (config.printHeaders === false) {
                printHeaders = false;
            }
            if (config.fontSize) {
                fontSize = config.fontSize;
            }
            if (config.margins) {
                margins = config.margins;
            }
        }
        this.lnMod = 0;
        lastCellPos = {
            x: undefined,
            y: undefined,
            w: undefined,
            h: undefined,
            ln: undefined
        }, pages = 1;
        this.printHeaders = printHeaders;
        this.margins = margins;
        this.setFontSize(fontSize);
        this.table_font_size = fontSize;
        if (headers === undefined || (headers === null)) {
            headerNames = Object.keys(data[0]);
        } else if (headers[0] && (typeof headers[0] !== 'string')) {
            var px2pt = 0.264583 * 72 / 25.4;
            for (i = 0, ln = headers.length; i < ln; i += 1) {
                header = headers[i];
                headerNames.push(header.name);
                headerPrompts.push(header.prompt);
                columnWidths[header.name] = header.width * px2pt;
            }
        } else {
            headerNames = headers;
        }
        if (autoSize) {
            func = function(rec) {
                return rec[header];
            };
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];
                columnMatrix[header] = data.map(func);
                columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header).w);
                column = columnMatrix[header];
                for (j = 0, cln = column.length; j < cln; j += 1) {
                    columnData = column[j];
                    columnMinWidths.push(this.getTextDimensions(columnData).w);
                }
                columnWidths[header] = jsPDFAPI.arrayMax(columnMinWidths);
            }
        }
        if (printHeaders) {
            var lineHeight = this.calculateLineHeight(headerNames, columnWidths, headerPrompts.length ? headerPrompts : headerNames);
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];
                tableHeaderConfigs.push([x, y, columnWidths[header], lineHeight, String(headerPrompts.length ? headerPrompts[i] : header)]);
            }
            this.setTableHeaderRow(tableHeaderConfigs);
            this.printHeaderRow(1, false);
        }
        for (i = 0, ln = data.length; i < ln; i += 1) {
            var lineHeight;
            model = data[i];
            lineHeight = this.calculateLineHeight(headerNames, columnWidths, model);
            for (j = 0, jln = headerNames.length; j < jln; j += 1) {
                header = headerNames[j];
                this.cell(x, y, columnWidths[header], lineHeight, model[header], i + 2, header.align);
            }
        }
        this.lastCellPos = lastCellPos;
        this.table_x = x;
        this.table_y = y;
        return this;
    };
    jsPDFAPI.calculateLineHeight = function(headerNames, columnWidths, model) {
        var header, lineHeight = 0;
        for (var j = 0; j < headerNames.length; j++) {
            header = headerNames[j];
            model[header] = this.splitTextToSize(String(model[header]), columnWidths[header] - padding);
            var h = this.internal.getLineHeight() * model[header].length + padding;
            if (h > lineHeight)
                lineHeight = h;
        }
        return lineHeight;
    };
    jsPDFAPI.setTableHeaderRow = function(config) {
        this.tableHeaderRow = config;
    };
    jsPDFAPI.printHeaderRow = function(lineNumber, new_page) {
        if (!this.tableHeaderRow) {
            throw 'Property tableHeaderRow does not exist.';
        }
        var tableHeaderCell, tmpArray, i, ln;
        this.printingHeaderRow = true;
        if (headerFunction !== undefined) {
            var position = headerFunction(this, pages);
            setLastCellPosition(position[0], position[1], position[2], position[3], -1);
        }
        this.setFontStyle('bold');
        var tempHeaderConf = [];
        for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {
            this.setFillColor(200, 200, 200);
            tableHeaderCell = this.tableHeaderRow[i];
            if (new_page) {
                tableHeaderCell[1] = this.margins && this.margins.top || 0;
                tempHeaderConf.push(tableHeaderCell);
            }
            tmpArray = [].concat(tableHeaderCell);
            this.cell.apply(this, tmpArray.concat(lineNumber));
        }
        if (tempHeaderConf.length > 0) {
            this.setTableHeaderRow(tempHeaderConf);
        }
        this.setFontStyle('normal');
        this.printingHeaderRow = false;
    };
})(jsPDF.API);
(function(jsPDFAPI) {
    var clone, DrillForContent, FontNameDB, FontStyleMap, FontWeightMap, FloatMap, ClearMap, GetCSS, PurgeWhiteSpace, Renderer, ResolveFont, ResolveUnitedNumber, UnitedNumberMap, elementHandledElsewhere, images, loadImgs, checkForFooter, process, tableToJson;
    clone = (function() {
        return function(obj) {
            Clone.prototype = obj;
            return new Clone()
        };

        function Clone() {}
    })();
    PurgeWhiteSpace = function(array) {
        var fragment, i, l, lTrimmed, r, rTrimmed, trailingSpace;
        i = 0;
        l = array.length;
        fragment = void 0;
        lTrimmed = false;
        rTrimmed = false;
        while (!lTrimmed && i !== l) {
            fragment = array[i] = array[i].trimLeft();
            if (fragment) {
                lTrimmed = true;
            }
            i++;
        }
        i = l - 1;
        while (l && !rTrimmed && i !== -1) {
            fragment = array[i] = array[i].trimRight();
            if (fragment) {
                rTrimmed = true;
            }
            i--;
        }
        r = /\s+$/g;
        trailingSpace = true;
        i = 0;
        while (i !== l) {
            fragment = array[i].replace(/\s+/g, " ");
            if (trailingSpace) {
                fragment = fragment.trimLeft();
            }
            if (fragment) {
                trailingSpace = r.test(fragment);
            }
            array[i] = fragment;
            i++;
        }
        return array;
    };
    Renderer = function(pdf, x, y, settings) {
        this.pdf = pdf;
        this.x = x;
        this.y = y;
        this.settings = settings;
        this.watchFunctions = [];
        this.init();
        return this;
    };
    ResolveFont = function(css_font_family_string) {
        var name, part, parts;
        name = void 0;
        parts = css_font_family_string.split(",");
        part = parts.shift();
        while (!name && part) {
            name = FontNameDB[part.trim().toLowerCase()];
            part = parts.shift();
        }
        return name;
    };
    ResolveUnitedNumber = function(css_line_height_string) {
        css_line_height_string = css_line_height_string === "auto" ? "0px" : css_line_height_string;
        if (css_line_height_string.indexOf("em") > -1 && !isNaN(Number(css_line_height_string.replace("em", "")))) {
            css_line_height_string = Number(css_line_height_string.replace("em", "")) * 18.719 + "px";
        }
        if (css_line_height_string.indexOf("pt") > -1 && !isNaN(Number(css_line_height_string.replace("pt", "")))) {
            css_line_height_string = Number(css_line_height_string.replace("pt", "")) * 1.333 + "px";
        }
        var normal, undef, value;
        undef = void 0;
        normal = 16.00;
        value = UnitedNumberMap[css_line_height_string];
        if (value) {
            return value;
        }
        value = {
            "xx-small": 9,
            "x-small": 11,
            small: 13,
            medium: 16,
            large: 19,
            "x-large": 23,
            "xx-large": 28,
            auto: 0
        }[{
            css_line_height_string: css_line_height_string
        }];
        if (value !== undef) {
            return UnitedNumberMap[css_line_height_string] = value / normal;
        }
        if (value = parseFloat(css_line_height_string)) {
            return UnitedNumberMap[css_line_height_string] = value / normal;
        }
        value = css_line_height_string.match(/([\d\.]+)(px)/);
        if (value.length === 3) {
            return UnitedNumberMap[css_line_height_string] = parseFloat(value[1]) / normal;
        }
        return UnitedNumberMap[css_line_height_string] = 1;
    };
    GetCSS = function(element) {
        var css, tmp, computedCSSElement;
        computedCSSElement = (function(el) {
            var compCSS;
            compCSS = (function(el) {
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    return document.defaultView.getComputedStyle(el, null);
                } else if (el.currentStyle) {
                    return el.currentStyle;
                } else {
                    return el.style;
                }
            })(el);
            return function(prop) {
                prop = prop.replace(/-\D/g, function(match) {
                    return match.charAt(1).toUpperCase();
                });
                return compCSS[prop];
            };
        })(element);
        css = {};
        tmp = void 0;
        css["font-family"] = ResolveFont(computedCSSElement("font-family")) || "times";
        css["font-style"] = FontStyleMap[computedCSSElement("font-style")] || "normal";
        css["text-align"] = TextAlignMap[computedCSSElement("text-align")] || "left";
        tmp = FontWeightMap[computedCSSElement("font-weight")] || "normal";
        if (tmp === "bold") {
            if (css["font-style"] === "normal") {
                css["font-style"] = tmp;
            } else {
                css["font-style"] = tmp + css["font-style"];
            }
        }
        css["font-size"] = ResolveUnitedNumber(computedCSSElement("font-size")) || 1;
        css["line-height"] = ResolveUnitedNumber(computedCSSElement("line-height")) || 1;
        css["display"] = (computedCSSElement("display") === "inline" ? "inline" : "block");
        tmp = (css["display"] === "block");
        css["margin-top"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-top")) || 0;
        css["margin-bottom"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-bottom")) || 0;
        css["padding-top"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-top")) || 0;
        css["padding-bottom"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-bottom")) || 0;
        css["margin-left"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-left")) || 0;
        css["margin-right"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-right")) || 0;
        css["padding-left"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-left")) || 0;
        css["padding-right"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-right")) || 0;
        css["float"] = FloatMap[computedCSSElement("cssFloat")] || "none";
        css["clear"] = ClearMap[computedCSSElement("clear")] || "none";
        return css;
    };
    elementHandledElsewhere = function(element, renderer, elementHandlers) {
        var handlers, i, isHandledElsewhere, l, t;
        isHandledElsewhere = false;
        i = void 0;
        l = void 0;
        t = void 0;
        handlers = elementHandlers["#" + element.id];
        if (handlers) {
            if (typeof handlers === "function") {
                isHandledElsewhere = handlers(element, renderer);
            } else {
                i = 0;
                l = handlers.length;
                while (!isHandledElsewhere && i !== l) {
                    isHandledElsewhere = handlers[i](element, renderer);
                    i++;
                }
            }
        }
        handlers = elementHandlers[element.nodeName];
        if (!isHandledElsewhere && handlers) {
            if (typeof handlers === "function") {
                isHandledElsewhere = handlers(element, renderer);
            } else {
                i = 0;
                l = handlers.length;
                while (!isHandledElsewhere && i !== l) {
                    isHandledElsewhere = handlers[i](element, renderer);
                    i++;
                }
            }
        }
        return isHandledElsewhere;
    };
    tableToJson = function(table, renderer) {
        var data, headers, i, j, rowData, tableRow, table_obj, table_with, cell, l;
        data = [];
        headers = [];
        i = 0;
        l = table.rows[0].cells.length;
        table_with = table.clientWidth;
        while (i < l) {
            cell = table.rows[0].cells[i];
            headers[i] = {
                name: cell.textContent.toLowerCase().replace(/\s+/g, ''),
                prompt: cell.textContent.replace(/\r?\n/g, ''),
                width: (cell.clientWidth / table_with) * renderer.pdf.internal.pageSize.width
            };
            i++;
        }
        i = 1;
        while (i < table.rows.length) {
            tableRow = table.rows[i];
            rowData = {};
            j = 0;
            while (j < tableRow.cells.length) {
                rowData[headers[j].name] = tableRow.cells[j].textContent.replace(/\r?\n/g, '');
                j++;
            }
            data.push(rowData);
            i++;
        }
        return table_obj = {
            rows: data,
            headers: headers
        };
    };
    var SkipNode = {
        SCRIPT: 1,
        STYLE: 1,
        NOSCRIPT: 1,
        OBJECT: 1,
        EMBED: 1,
        SELECT: 1
    };
    var listCount = 1;
    DrillForContent = function(element, renderer, elementHandlers) {
        var cn, cns, fragmentCSS, i, isBlock, l, px2pt, table2json, cb;
        cns = element.childNodes;
        cn = void 0;
        fragmentCSS = GetCSS(element);
        isBlock = fragmentCSS.display === "block";
        if (isBlock) {
            renderer.setBlockBoundary();
            renderer.setBlockStyle(fragmentCSS);
        }
        px2pt = 0.264583 * 72 / 25.4;
        i = 0;
        l = cns.length;
        while (i < l) {
            cn = cns[i];
            if (typeof cn === "object") {
                renderer.executeWatchFunctions(cn);
                if (cn.nodeType === 1 && cn.nodeName === 'HEADER') {
                    var header = cn;
                    var oldMarginTop = renderer.pdf.margins_doc.top;
                    renderer.pdf.internal.events.subscribe('addPage', function(pageInfo) {
                        renderer.y = oldMarginTop;
                        DrillForContent(header, renderer, elementHandlers);
                        renderer.pdf.margins_doc.top = renderer.y + 10;
                        renderer.y += 10;
                    }, false);
                }
                if (cn.nodeType === 8 && cn.nodeName === "#comment") {
                    if (~cn.textContent.indexOf("ADD_PAGE")) {
                        renderer.pdf.addPage();
                        renderer.y = renderer.pdf.margins_doc.top;
                    }
                } else if (cn.nodeType === 1 && !SkipNode[cn.nodeName]) {
                    var cached_image;
                    if (cn.nodeName === "IMG") {
                        var url = cn.getAttribute("src");
                        cached_image = images[renderer.pdf.sHashCode(url) || url];
                    }
                    if (cached_image) {
                        if ((renderer.pdf.internal.pageSize.height - renderer.pdf.margins_doc.bottom < renderer.y + cn.height) && (renderer.y > renderer.pdf.margins_doc.top)) {
                            renderer.pdf.addPage();
                            renderer.y = renderer.pdf.margins_doc.top;
                            renderer.executeWatchFunctions(cn);
                        }
                        var imagesCSS = GetCSS(cn);
                        var imageX = renderer.x;
                        var fontToUnitRatio = 12 / renderer.pdf.internal.scaleFactor;
                        var additionalSpaceLeft = (imagesCSS["margin-left"] + imagesCSS["padding-left"]) * fontToUnitRatio;
                        var additionalSpaceRight = (imagesCSS["margin-right"] + imagesCSS["padding-right"]) * fontToUnitRatio;
                        var additionalSpaceTop = (imagesCSS["margin-top"] + imagesCSS["padding-top"]) * fontToUnitRatio;
                        var additionalSpaceBottom = (imagesCSS["margin-bottom"] + imagesCSS["padding-bottom"]) * fontToUnitRatio;
                        if (imagesCSS['float'] !== undefined && imagesCSS['float'] === 'right') {
                            imageX += renderer.settings.width - cn.width - additionalSpaceRight;
                        } else {
                            imageX += additionalSpaceLeft;
                        }
                        renderer.pdf.addImage(cached_image, imageX, renderer.y + additionalSpaceTop, cn.width, cn.height);
                        cached_image = undefined;
                        if (imagesCSS['float'] === 'right' || imagesCSS['float'] === 'left') {
                            renderer.watchFunctions.push((function(diffX, thresholdY, diffWidth, el) {
                                if (renderer.y >= thresholdY) {
                                    renderer.x += diffX;
                                    renderer.settings.width += diffWidth;
                                    return true;
                                } else if (el && el.nodeType === 1 && !SkipNode[el.nodeName] && renderer.x + el.width > (renderer.pdf.margins_doc.left + renderer.pdf.margins_doc.width)) {
                                    renderer.x += diffX;
                                    renderer.y = thresholdY;
                                    renderer.settings.width += diffWidth;
                                    return true;
                                } else {
                                    return false;
                                }
                            }).bind(this, (imagesCSS['float'] === 'left') ? -cn.width - additionalSpaceLeft - additionalSpaceRight : 0, renderer.y + cn.height + additionalSpaceTop + additionalSpaceBottom, cn.width));
                            renderer.watchFunctions.push((function(yPositionAfterFloating, pages, el) {
                                if (renderer.y < yPositionAfterFloating && pages === renderer.pdf.internal.getNumberOfPages()) {
                                    if (el.nodeType === 1 && GetCSS(el).clear === 'both') {
                                        renderer.y = yPositionAfterFloating;
                                        return true;
                                    } else {
                                        return false;
                                    }
                                } else {
                                    return true;
                                }
                            }).bind(this, renderer.y + cn.height, renderer.pdf.internal.getNumberOfPages()));
                            renderer.settings.width -= cn.width + additionalSpaceLeft + additionalSpaceRight;
                            if (imagesCSS['float'] === 'left') {
                                renderer.x += cn.width + additionalSpaceLeft + additionalSpaceRight;
                            }
                        } else {
                            renderer.y += cn.height + additionalSpaceBottom;
                        }
                    } else if (cn.nodeName === "TABLE") {
                        table2json = tableToJson(cn, renderer);
                        renderer.y += 10;
                        renderer.pdf.table(renderer.x, renderer.y, table2json.rows, table2json.headers, {
                            autoSize: false,
                            printHeaders: true,
                            margins: renderer.pdf.margins_doc
                        });
                        renderer.y = renderer.pdf.lastCellPos.y + renderer.pdf.lastCellPos.h + 20;
                    } else if (cn.nodeName === "OL" || cn.nodeName === "UL") {
                        listCount = 1;
                        if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
                            DrillForContent(cn, renderer, elementHandlers);
                        }
                        renderer.y += 10;
                    } else if (cn.nodeName === "LI") {
                        var temp = renderer.x;
                        renderer.x += cn.parentNode.nodeName === "UL" ? 22 : 10;
                        renderer.y += 3;
                        if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
                            DrillForContent(cn, renderer, elementHandlers);
                        }
                        renderer.x = temp;
                    } else if (cn.nodeName === "BR") {
                        renderer.y += fragmentCSS["font-size"] * renderer.pdf.internal.scaleFactor;
                    } else {
                        if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
                            DrillForContent(cn, renderer, elementHandlers);
                        }
                    }
                } else if (cn.nodeType === 3) {
                    var value = cn.nodeValue;
                    if (cn.nodeValue && cn.parentNode.nodeName === "LI") {
                        if (cn.parentNode.parentNode.nodeName === "OL") {
                            value = listCount++ + '. ' + value;
                        } else {
                            var fontPx = fragmentCSS["font-size"] * 16;
                            var radius = 2;
                            if (fontPx > 20) {
                                radius = 3;
                            }
                            cb = function(x, y) {
                                this.pdf.circle(x, y, radius, 'FD');
                            };
                        }
                    }
                    renderer.addText(value, fragmentCSS);
                } else if (typeof cn === "string") {
                    renderer.addText(cn, fragmentCSS);
                }
            }
            i++;
        }
        if (isBlock) {
            return renderer.setBlockBoundary(cb);
        }
    };
    images = {};
    loadImgs = function(element, renderer, elementHandlers, cb) {
        var imgs = element.getElementsByTagName('img'),
            l = imgs.length,
            found_images, x = 0;

        function done() {
            renderer.pdf.internal.events.publish('imagesLoaded');
            cb(found_images);
        }

        function loadImage(url, width, height) {
            if (!url)
                return;
            var img = new Image();
            found_images = ++x;
            img.crossOrigin = '';
            img.onerror = img.onload = function() {
                if (img.complete) {
                    if (img.src.indexOf('data:image/') === 0) {
                        img.width = width || img.width || 0;
                        img.height = height || img.height || 0;
                    }
                    if (img.width + img.height) {
                        var hash = renderer.pdf.sHashCode(url) || url;
                        images[hash] = images[hash] || img;
                    }
                }
                if (!--x) {
                    done();
                }
            };
            img.src = url;
        }
        while (l--)
            loadImage(imgs[l].getAttribute("src"), imgs[l].width, imgs[l].height);
        return x || done();
    };
    checkForFooter = function(elem, renderer, elementHandlers) {
        var footer = elem.getElementsByTagName("footer");
        if (footer.length > 0) {
            footer = footer[0];
            var oldOut = renderer.pdf.internal.write;
            var oldY = renderer.y;
            renderer.pdf.internal.write = function() {};
            DrillForContent(footer, renderer, elementHandlers);
            var footerHeight = Math.ceil(renderer.y - oldY) + 5;
            renderer.y = oldY;
            renderer.pdf.internal.write = oldOut;
            renderer.pdf.margins_doc.bottom += footerHeight;
            var renderFooter = function(pageInfo) {
                var pageNumber = pageInfo !== undefined ? pageInfo.pageNumber : 1;
                var oldPosition = renderer.y;
                renderer.y = renderer.pdf.internal.pageSize.height - renderer.pdf.margins_doc.bottom;
                renderer.pdf.margins_doc.bottom -= footerHeight;
                var spans = footer.getElementsByTagName('span');
                for (var i = 0; i < spans.length; ++i) {
                    if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") > -1) {
                        spans[i].innerHTML = pageNumber;
                    }
                    if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {
                        spans[i].innerHTML = '###jsPDFVarTotalPages###';
                    }
                }
                DrillForContent(footer, renderer, elementHandlers);
                renderer.pdf.margins_doc.bottom += footerHeight;
                renderer.y = oldPosition;
            };
            var spans = footer.getElementsByTagName('span');
            for (var i = 0; i < spans.length; ++i) {
                if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {
                    renderer.pdf.internal.events.subscribe('htmlRenderingFinished', renderer.pdf.putTotalPages.bind(renderer.pdf, '###jsPDFVarTotalPages###'), true);
                }
            }
            renderer.pdf.internal.events.subscribe('addPage', renderFooter, false);
            renderFooter();
            SkipNode['FOOTER'] = 1;
        }
    };
    process = function(pdf, element, x, y, settings, callback) {
        if (!element)
            return false;
        if (typeof element !== "string" && !element.parentNode)
            element = '' + element.innerHTML;
        if (typeof element === "string") {
            element = (function(element) {
                var $frame, $hiddendiv, framename, visuallyhidden;
                framename = "jsPDFhtmlText" + Date.now().toString() + (Math.random() * 1000).toFixed(0);
                visuallyhidden = "position: absolute !important;" + "clip: rect(1px 1px 1px 1px); /* IE6, IE7 */" + "clip: rect(1px, 1px, 1px, 1px);" + "padding:0 !important;" + "border:0 !important;" + "height: 1px !important;" + "width: 1px !important; " + "top:auto;" + "left:-100px;" + "overflow: hidden;";
                $hiddendiv = document.createElement('div');
                $hiddendiv.style.cssText = visuallyhidden;
                $hiddendiv.innerHTML = "<iframe style=\"height:1px;width:1px\" name=\"" + framename + "\" />";
                document.body.appendChild($hiddendiv);
                $frame = window.frames[framename];
                $frame.document.body.innerHTML = element;
                return $frame.document.body;
            })(element.replace(/<\/?script[^>]*?>/gi, ''));
        }
        var r = new Renderer(pdf, x, y, settings),
            out;
        loadImgs.call(this, element, r, settings.elementHandlers, function(found_images) {
            checkForFooter(element, r, settings.elementHandlers);
            DrillForContent(element, r, settings.elementHandlers);
            r.pdf.internal.events.publish('htmlRenderingFinished');
            out = r.dispose();
            if (typeof callback === 'function') callback(out);
            else if (found_images) console.error('jsPDF Warning: rendering issues? provide a callback to fromHTML!');
        });
        return out || {
            x: r.x,
            y: r.y
        };
    };
    Renderer.prototype.init = function() {
        this.paragraph = {
            text: [],
            style: []
        };
        return this.pdf.internal.write("q");
    };
    Renderer.prototype.dispose = function() {
        this.pdf.internal.write("Q");
        return {
            x: this.x,
            y: this.y,
            ready: true
        };
    };
    Renderer.prototype.executeWatchFunctions = function(el) {
        var ret = false;
        var narray = [];
        if (this.watchFunctions.length > 0) {
            for (var i = 0; i < this.watchFunctions.length; ++i) {
                if (this.watchFunctions[i](el) === true) {
                    ret = true;
                } else {
                    narray.push(this.watchFunctions[i]);
                }
            }
            this.watchFunctions = narray;
        }
        return ret;
    };
    Renderer.prototype.splitFragmentsIntoLines = function(fragments, styles) {
        var currentLineLength, defaultFontSize, ff, fontMetrics, fontMetricsCache, fragment, fragmentChopped, fragmentLength, fragmentSpecificMetrics, fs, k, line, lines, maxLineLength, style;
        defaultFontSize = 12;
        k = this.pdf.internal.scaleFactor;
        fontMetricsCache = {};
        ff = void 0;
        fs = void 0;
        fontMetrics = void 0;
        fragment = void 0;
        style = void 0;
        fragmentSpecificMetrics = void 0;
        fragmentLength = void 0;
        fragmentChopped = void 0;
        line = [];
        lines = [line];
        currentLineLength = 0;
        maxLineLength = this.settings.width;
        while (fragments.length) {
            fragment = fragments.shift();
            style = styles.shift();
            if (fragment) {
                ff = style["font-family"];
                fs = style["font-style"];
                fontMetrics = fontMetricsCache[ff + fs];
                if (!fontMetrics) {
                    fontMetrics = this.pdf.internal.getFont(ff, fs).metadata.Unicode;
                    fontMetricsCache[ff + fs] = fontMetrics;
                }
                fragmentSpecificMetrics = {
                    widths: fontMetrics.widths,
                    kerning: fontMetrics.kerning,
                    fontSize: style["font-size"] * defaultFontSize,
                    textIndent: currentLineLength
                };
                fragmentLength = this.pdf.getStringUnitWidth(fragment, fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
                if (currentLineLength + fragmentLength > maxLineLength) {
                    fragmentChopped = this.pdf.splitTextToSize(fragment, maxLineLength, fragmentSpecificMetrics);
                    line.push([fragmentChopped.shift(), style]);
                    while (fragmentChopped.length) {
                        line = [
                            [fragmentChopped.shift(), style]
                        ];
                        lines.push(line);
                    }
                    currentLineLength = this.pdf.getStringUnitWidth(line[0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
                } else {
                    line.push([fragment, style]);
                    currentLineLength += fragmentLength;
                }
            }
        }
        if (style['text-align'] !== undefined && (style['text-align'] === 'center' || style['text-align'] === 'right' || style['text-align'] === 'justify')) {
            for (var i = 0; i < lines.length; ++i) {
                var length = this.pdf.getStringUnitWidth(lines[i][0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
                if (i > 0) {
                    lines[i][0][1] = clone(lines[i][0][1]);
                }
                var space = (maxLineLength - length);
                if (style['text-align'] === 'right') {
                    lines[i][0][1]['margin-left'] = space;
                } else if (style['text-align'] === 'center') {
                    lines[i][0][1]['margin-left'] = space / 2;
                } else if (style['text-align'] === 'justify') {
                    var countSpaces = lines[i][0][0].split(' ').length - 1;
                    lines[i][0][1]['word-spacing'] = space / countSpaces;
                    if (i === (lines.length - 1)) {
                        lines[i][0][1]['word-spacing'] = 0;
                    }
                }
            }
        }
        return lines;
    };
    Renderer.prototype.RenderTextFragment = function(text, style) {
        var defaultFontSize, font, maxLineHeight;
        maxLineHeight = 0;
        defaultFontSize = 12;
        if (this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize()) {
            this.pdf.internal.write("ET", "Q");
            this.pdf.addPage();
            this.y = this.pdf.margins_doc.top;
            this.pdf.internal.write("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
            maxLineHeight = Math.max(maxLineHeight, style["line-height"], style["font-size"]);
            this.pdf.internal.write(0, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");
        }
        font = this.pdf.internal.getFont(style["font-family"], style["font-style"]);
        if (style['word-spacing'] !== undefined && style['word-spacing'] > 0) {
            this.pdf.internal.write(style['word-spacing'].toFixed(2), "Tw");
        }
        this.pdf.internal.write("/" + font.id, (defaultFontSize * style["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(text) + ") Tj");
        if (style['word-spacing'] !== undefined) {
            this.pdf.internal.write(0, "Tw");
        }
    };
    Renderer.prototype.renderParagraph = function(cb) {
        var blockstyle, defaultFontSize, fontToUnitRatio, fragments, i, l, line, lines, maxLineHeight, out, paragraphspacing_after, paragraphspacing_before, priorblockstype, styles, fontSize;
        fragments = PurgeWhiteSpace(this.paragraph.text);
        styles = this.paragraph.style;
        blockstyle = this.paragraph.blockstyle;
        priorblockstype = this.paragraph.blockstyle || {};
        this.paragraph = {
            text: [],
            style: [],
            blockstyle: {},
            priorblockstyle: blockstyle
        };
        if (!fragments.join("").trim()) {
            return;
        }
        lines = this.splitFragmentsIntoLines(fragments, styles);
        line = void 0;
        maxLineHeight = void 0;
        defaultFontSize = 12;
        fontToUnitRatio = defaultFontSize / this.pdf.internal.scaleFactor;
        paragraphspacing_before = (Math.max((blockstyle["margin-top"] || 0) - (priorblockstype["margin-bottom"] || 0), 0) + (blockstyle["padding-top"] || 0)) * fontToUnitRatio;
        paragraphspacing_after = ((blockstyle["margin-bottom"] || 0) + (blockstyle["padding-bottom"] || 0)) * fontToUnitRatio;
        out = this.pdf.internal.write;
        i = void 0;
        l = void 0;
        this.y += paragraphspacing_before;
        out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
        var currentIndent = 0;
        while (lines.length) {
            line = lines.shift();
            maxLineHeight = 0;
            i = 0;
            l = line.length;
            while (i !== l) {
                if (line[i][0].trim()) {
                    maxLineHeight = Math.max(maxLineHeight, line[i][1]["line-height"], line[i][1]["font-size"]);
                    fontSize = line[i][1]["font-size"] * 7;
                }
                i++;
            }
            var indentMove = 0;
            if (line[0][1]["margin-left"] !== undefined && line[0][1]["margin-left"] > 0) {
                wantedIndent = this.pdf.internal.getCoordinateString(line[0][1]["margin-left"]);
                indentMove = wantedIndent - currentIndent;
                currentIndent = wantedIndent;
            }
            out(indentMove, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");
            i = 0;
            l = line.length;
            while (i !== l) {
                if (line[i][0]) {
                    this.RenderTextFragment(line[i][0], line[i][1]);
                }
                i++;
            }
            this.y += maxLineHeight * fontToUnitRatio;
            if (this.executeWatchFunctions(line[0][1]) && lines.length > 0) {
                var localFragments = [];
                var localStyles = [];
                lines.forEach(function(localLine) {
                    var i = 0;
                    var l = localLine.length;
                    while (i !== l) {
                        if (localLine[i][0]) {
                            localFragments.push(localLine[i][0] + ' ');
                            localStyles.push(localLine[i][1]);
                        }
                        ++i;
                    }
                });
                lines = this.splitFragmentsIntoLines(PurgeWhiteSpace(localFragments), localStyles);
                out("ET", "Q");
                out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
            }
        }
        if (cb && typeof cb === "function") {
            cb.call(this, this.x - 9, this.y - fontSize / 2);
        }
        out("ET", "Q");
        return this.y += paragraphspacing_after;
    };
    Renderer.prototype.setBlockBoundary = function(cb) {
        return this.renderParagraph(cb);
    };
    Renderer.prototype.setBlockStyle = function(css) {
        return this.paragraph.blockstyle = css;
    };
    Renderer.prototype.addText = function(text, css) {
        this.paragraph.text.push(text);
        return this.paragraph.style.push(css);
    };
    FontNameDB = {
        helvetica: "helvetica",
        "sans-serif": "helvetica",
        "times new roman": "times",
        serif: "times",
        times: "times",
        monospace: "courier",
        courier: "courier"
    };
    FontWeightMap = {
        100: "normal",
        200: "normal",
        300: "normal",
        400: "normal",
        500: "bold",
        600: "bold",
        700: "bold",
        800: "bold",
        900: "bold",
        normal: "normal",
        bold: "bold",
        bolder: "bold",
        lighter: "normal"
    };
    FontStyleMap = {
        normal: "normal",
        italic: "italic",
        oblique: "italic"
    };
    TextAlignMap = {
        left: "left",
        right: "right",
        center: "center",
        justify: "justify"
    };
    FloatMap = {
        none: 'none',
        right: 'right',
        left: 'left'
    };
    ClearMap = {
        none: 'none',
        both: 'both'
    };
    UnitedNumberMap = {
        normal: 1
    };
    jsPDFAPI.fromHTML = function(HTML, x, y, settings, callback, margins) {
        "use strict";
        this.margins_doc = margins || {
            top: 0,
            bottom: 0
        };
        if (!settings)
            settings = {};
        if (!settings.elementHandlers)
            settings.elementHandlers = {};
        return process(this, HTML, isNaN(x) ? 4 : x, isNaN(y) ? 4 : y, settings, callback);
    };
})(jsPDF.API);
(function(jsPDFAPI) {
    'use strict';
    var jsNamesObj, jsJsObj, text;
    jsPDFAPI.addJS = function(txt) {
        text = txt;
        this.internal.events.subscribe('postPutResources', function(txt) {
            jsNamesObj = this.internal.newObject();
            this.internal.write('<< /Names [(EmbeddedJS) ' + (jsNamesObj + 1) + ' 0 R] >>', 'endobj');
            jsJsObj = this.internal.newObject();
            this.internal.write('<< /S /JavaScript /JS (', text, ') >>', 'endobj');
        });
        this.internal.events.subscribe('putCatalog', function() {
            if (jsNamesObj !== undefined && jsJsObj !== undefined) {
                this.internal.write('/Names <</JavaScript ' + jsNamesObj + ' 0 R>>');
            }
        });
        return this;
    };
}(jsPDF.API));
(function(jsPDFAPI) {
    'use strict'
    var doesNotHavePngJS = function() {
            return typeof PNG !== 'function' || typeof FlateStream !== 'function';
        },
        canCompress = function(value) {
            return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();
        },
        hasCompressionJS = function() {
            var inst = typeof Deflater === 'function';
            if (!inst)
                throw new Error("requires deflate.js for compression")
            return inst;
        },
        compressBytes = function(bytes, lineLength, colorsPerPixel, compression) {
            var level = 5,
                filter_method = filterUp;
            switch (compression) {
                case jsPDFAPI.image_compression.FAST:
                    level = 3;
                    filter_method = filterSub;
                    break;
                case jsPDFAPI.image_compression.MEDIUM:
                    level = 6;
                    filter_method = filterAverage;
                    break;
                case jsPDFAPI.image_compression.SLOW:
                    level = 9;
                    filter_method = filterPaeth;
                    break;
            }
            bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);
            var header = new Uint8Array(createZlibHeader(level));
            var checksum = adler32(bytes);
            var deflate = new Deflater(level);
            var a = deflate.append(bytes);
            var cBytes = deflate.flush();
            var len = header.length + a.length + cBytes.length;
            var cmpd = new Uint8Array(len + 4);
            cmpd.set(header);
            cmpd.set(a, header.length);
            cmpd.set(cBytes, header.length + a.length);
            cmpd[len++] = (checksum >>> 24) & 0xff;
            cmpd[len++] = (checksum >>> 16) & 0xff;
            cmpd[len++] = (checksum >>> 8) & 0xff;
            cmpd[len++] = checksum & 0xff;
            return jsPDFAPI.arrayBufferToBinaryString(cmpd);
        },
        createZlibHeader = function(bytes, level) {
            var cm = 8;
            var cinfo = Math.LOG2E * Math.log(0x8000) - 8;
            var cmf = (cinfo << 4) | cm;
            var hdr = cmf << 8;
            var flevel = Math.min(3, ((level - 1) & 0xff) >> 1);
            hdr |= (flevel << 6);
            hdr |= 0;
            hdr += 31 - (hdr % 31);
            return [cmf, (hdr & 0xff) & 0xff];
        },
        adler32 = function(array, param) {
            var adler = 1;
            var s1 = adler & 0xffff,
                s2 = (adler >>> 16) & 0xffff;
            var len = array.length;
            var tlen;
            var i = 0;
            while (len > 0) {
                tlen = len > param ? param : len;
                len -= tlen;
                do {
                    s1 += array[i++];
                    s2 += s1;
                } while (--tlen);
                s1 %= 65521;
                s2 %= 65521;
            }
            return ((s2 << 16) | s1) >>> 0;
        },
        applyPngFilterMethod = function(bytes, lineLength, colorsPerPixel, filter_method) {
            var lines = bytes.length / lineLength,
                result = new Uint8Array(bytes.length + lines),
                filter_methods = getFilterMethods(),
                i = 0,
                line, prevLine, offset;
            for (; i < lines; i++) {
                offset = i * lineLength;
                line = bytes.subarray(offset, offset + lineLength);
                if (filter_method) {
                    result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);
                } else {
                    var j = 0,
                        len = filter_methods.length,
                        results = [];
                    for (; j < len; j++)
                        results[j] = filter_methods[j](line, colorsPerPixel, prevLine);
                    var ind = getIndexOfSmallestSum(results.concat());
                    result.set(results[ind], offset + i);
                }
                prevLine = line;
            }
            return result;
        },
        filterNone = function(line, colorsPerPixel, prevLine) {
            var result = Array.apply([], line);
            result.unshift(0);
            return result;
        },
        filterSub = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left;
            result[0] = 1;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                result[i + 1] = (line[i] - left + 0x0100) & 0xff;
            }
            return result;
        },
        filterUp = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                up;
            result[0] = 2;
            for (; i < len; i++) {
                up = prevLine && prevLine[i] || 0;
                result[i + 1] = (line[i] - up + 0x0100) & 0xff;
            }
            return result;
        },
        filterAverage = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left, up;
            result[0] = 3;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                up = prevLine && prevLine[i] || 0;
                result[i + 1] = (line[i] + 0x0100 - ((left + up) >>> 1)) & 0xff;
            }
            return result;
        },
        filterPaeth = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left, up, upLeft, paeth;
            result[0] = 4;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                up = prevLine && prevLine[i] || 0;
                upLeft = prevLine && prevLine[i - colorsPerPixel] || 0;
                paeth = paethPredictor(left, up, upLeft);
                result[i + 1] = (line[i] - paeth + 0x0100) & 0xff;
            }
            return result;
        },
        paethPredictor = function(left, up, upLeft) {
            var p = left + up - upLeft,
                pLeft = Math.abs(p - left),
                pUp = Math.abs(p - up),
                pUpLeft = Math.abs(p - upLeft);
            return (pLeft <= pUp && pLeft <= pUpLeft) ? left : (pUp <= pUpLeft) ? up : upLeft;
        },
        getFilterMethods = function() {
            return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];
        },
        getIndexOfSmallestSum = function(arrays) {
            var i = 0,
                len = arrays.length,
                sum, min, ind;
            while (i < len) {
                sum = absSum(arrays[i].slice(1));
                if (sum < min || !min) {
                    min = sum;
                    ind = i;
                }
                i++;
            }
            return ind;
        },
        absSum = function(array) {
            var i = 0,
                len = array.length,
                sum = 0;
            while (i < len)
                sum += Math.abs(array[i++]);
            return sum;
        },
        logImg = function(img) {
            console.log("width: " + img.width);
            console.log("height: " + img.height);
            console.log("bits: " + img.bits);
            console.log("colorType: " + img.colorType);
            console.log("transparency:");
            console.log(img.transparency);
            console.log("text:");
            console.log(img.text);
            console.log("compressionMethod: " + img.compressionMethod);
            console.log("filterMethod: " + img.filterMethod);
            console.log("interlaceMethod: " + img.interlaceMethod);
            console.log("imgData:");
            console.log(img.imgData);
            console.log("palette:");
            console.log(img.palette);
            console.log("colors: " + img.colors);
            console.log("colorSpace: " + img.colorSpace);
            console.log("pixelBitlength: " + img.pixelBitlength);
            console.log("hasAlphaChannel: " + img.hasAlphaChannel);
        };
    jsPDFAPI.processPNG = function(imageData, imageIndex, alias, compression, dataAsBinaryString) {
        'use strict'
        var colorSpace = this.color_spaces.DEVICE_RGB,
            decode = this.decode.FLATE_DECODE,
            bpc = 8,
            img, dp, trns, colors, pal, smask;
        if (this.isArrayBuffer(imageData))
            imageData = new Uint8Array(imageData);
        if (this.isArrayBufferView(imageData)) {
            if (doesNotHavePngJS())
                throw new Error("PNG support requires png.js and zlib.js");
            img = new PNG(imageData);
            imageData = img.imgData;
            bpc = img.bits;
            colorSpace = img.colorSpace;
            colors = img.colors;
            if ([4, 6].indexOf(img.colorType) !== -1) {
                if (img.bits === 8) {
                    var pixelsArrayType = window['Uint' + img.pixelBitlength + 'Array'],
                        pixels = new pixelsArrayType(img.decodePixels().buffer),
                        len = pixels.length,
                        imgData = new Uint8Array(len * img.colors),
                        alphaData = new Uint8Array(len),
                        pDiff = img.pixelBitlength - img.bits,
                        i = 0,
                        n = 0,
                        pixel, pbl;
                    for (; i < len; i++) {
                        pixel = pixels[i];
                        pbl = 0;
                        while (pbl < pDiff) {
                            imgData[n++] = (pixel >>> pbl) & 0xff;
                            pbl = pbl + img.bits;
                        }
                        alphaData[i] = (pixel >>> pbl) & 0xff;
                    }
                }
                if (img.bits === 16) {
                    var pixels = new Uint32Array(img.decodePixels().buffer),
                        len = pixels.length,
                        imgData = new Uint8Array((len * (32 / img.pixelBitlength)) * img.colors),
                        alphaData = new Uint8Array(len * (32 / img.pixelBitlength)),
                        hasColors = img.colors > 1,
                        i = 0,
                        n = 0,
                        a = 0,
                        pixel;
                    while (i < len) {
                        pixel = pixels[i++];
                        imgData[n++] = (pixel >>> 0) & 0xFF;
                        if (hasColors) {
                            imgData[n++] = (pixel >>> 16) & 0xFF;
                            pixel = pixels[i++];
                            imgData[n++] = (pixel >>> 0) & 0xFF;
                        }
                        alphaData[a++] = (pixel >>> 16) & 0xFF;
                    }
                    bpc = 8;
                }
                if (canCompress(compression)) {
                    imageData = compressBytes(imgData, img.width * img.colors, img.colors, compression);
                    smask = compressBytes(alphaData, img.width, 1, compression);
                } else {
                    imageData = imgData;
                    smask = alphaData;
                    decode = null;
                }
            }
            if (img.colorType === 3) {
                colorSpace = this.color_spaces.INDEXED;
                pal = img.palette;
                if (img.transparency.indexed) {
                    var trans = img.transparency.indexed;
                    var total = 0,
                        i = 0,
                        len = trans.length;
                    for (; i < len; ++i)
                        total += trans[i];
                    total = total / 255;
                    if (total === len - 1 && trans.indexOf(0) !== -1) {
                        trns = [trans.indexOf(0)];
                    } else if (total !== len) {
                        var pixels = img.decodePixels(),
                            alphaData = new Uint8Array(pixels.length),
                            i = 0,
                            len = pixels.length;
                        for (; i < len; i++)
                            alphaData[i] = trans[pixels[i]];
                        smask = compressBytes(alphaData, img.width, 1);
                    }
                }
            }
            if (decode === this.decode.FLATE_DECODE)
                dp = '/Predictor 15 /Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;
            else
                dp = '/Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;
            if (this.isArrayBuffer(imageData) || this.isArrayBufferView(imageData))
                imageData = this.arrayBufferToBinaryString(imageData);
            if (smask && this.isArrayBuffer(smask) || this.isArrayBufferView(smask))
                smask = this.arrayBufferToBinaryString(smask);
            return this.createImageInfo(imageData, img.width, img.height, colorSpace, bpc, decode, imageIndex, alias, dp, trns, pal, smask);
        }
        throw new Error("Unsupported PNG image data, try using JPEG instead.");
    }
})(jsPDF.API);
(function(jsPDFAPI) {
    'use strict'
    jsPDFAPI.addSVG = function(svgtext, x, y, w, h) {
        var undef
        if (x === undef || y === undef) {
            throw new Error("addSVG needs values for 'x' and 'y'");
        }

        function InjectCSS(cssbody, document) {
            var styletag = document.createElement('style');
            styletag.type = 'text/css';
            if (styletag.styleSheet) {
                styletag.styleSheet.cssText = cssbody;
            } else {
                styletag.appendChild(document.createTextNode(cssbody));
            }
            document.getElementsByTagName("head")[0].appendChild(styletag);
        }

        function createWorkerNode(document) {
            var frameID = 'childframe',
                frame = document.createElement('iframe')
            InjectCSS('.jsPDF_sillysvg_iframe {display:none;position:absolute;}', document)
            frame.name = frameID
            frame.setAttribute("width", 0)
            frame.setAttribute("height", 0)
            frame.setAttribute("frameborder", "0")
            frame.setAttribute("scrolling", "no")
            frame.setAttribute("seamless", "seamless")
            frame.setAttribute("class", "jsPDF_sillysvg_iframe")
            document.body.appendChild(frame)
            return frame
        }

        function attachSVGToWorkerNode(svgtext, frame) {
            var framedoc = (frame.contentWindow || frame.contentDocument).document
            framedoc.write(svgtext)
            framedoc.close()
            return framedoc.getElementsByTagName('svg')[0]
        }

        function convertPathToPDFLinesArgs(path) {
            'use strict'
            var x = parseFloat(path[1]),
                y = parseFloat(path[2]),
                vectors = [],
                position = 3,
                len = path.length
            while (position < len) {
                if (path[position] === 'c') {
                    vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2]), parseFloat(path[position + 3]), parseFloat(path[position + 4]), parseFloat(path[position + 5]), parseFloat(path[position + 6])])
                    position += 7
                } else if (path[position] === 'l') {
                    vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2])])
                    position += 3
                } else {
                    position += 1
                }
            }
            return [x, y, vectors]
        }
        var workernode = createWorkerNode(document),
            svgnode = attachSVGToWorkerNode(svgtext, workernode),
            scale = [1, 1],
            svgw = parseFloat(svgnode.getAttribute('width')),
            svgh = parseFloat(svgnode.getAttribute('height'))
        if (svgw && svgh) {
            if (w && h) {
                scale = [w / svgw, h / svgh]
            } else if (w) {
                scale = [w / svgw, w / svgw]
            } else if (h) {
                scale = [h / svgh, h / svgh]
            }
        }
        var i, l, tmp, linesargs, items = svgnode.childNodes
        for (i = 0, l = items.length; i < l; i++) {
            tmp = items[i]
            if (tmp.tagName && tmp.tagName.toUpperCase() === 'PATH') {
                linesargs = convertPathToPDFLinesArgs(tmp.getAttribute("d").split(' '))
                linesargs[0] = linesargs[0] * scale[0] + x
                linesargs[1] = linesargs[1] * scale[1] + y
                this.lines.call(this, linesargs[2], linesargs[0], linesargs[1], scale)
            }
        }
        return this
    }
})(jsPDF.API);;
(function(API) {
    'use strict'
    var getCharWidthsArray = API.getCharWidthsArray = function(text, options) {
        if (!options) {
            options = {}
        }
        var widths = options.widths ? options.widths : this.internal.getFont().metadata.Unicode.widths,
            widthsFractionOf = widths.fof ? widths.fof : 1,
            kerning = options.kerning ? options.kerning : this.internal.getFont().metadata.Unicode.kerning,
            kerningFractionOf = kerning.fof ? kerning.fof : 1
        var i, l, char_code, prior_char_code = 0,
            default_char_width = widths[0] || widthsFractionOf,
            output = []
        for (i = 0, l = text.length; i < l; i++) {
            char_code = text.charCodeAt(i)
            output.push((widths[char_code] || default_char_width) / widthsFractionOf +
                (kerning[char_code] && kerning[char_code][prior_char_code] || 0) / kerningFractionOf)
            prior_char_code = char_code
        }
        return output
    }
    var getArraySum = function(array) {
        var i = array.length,
            output = 0
        while (i) {;
            i--;
            output += array[i]
        }
        return output
    }
    var getStringUnitWidth = API.getStringUnitWidth = function(text, options) {
        return getArraySum(getCharWidthsArray.call(this, text, options))
    }
    var splitLongWord = function(word, widths_array, firstLineMaxLen, maxLen) {
        var answer = []
        var i = 0,
            l = word.length,
            workingLen = 0
        while (i !== l && workingLen + widths_array[i] < firstLineMaxLen) {
            workingLen += widths_array[i];
            i++;
        }
        answer.push(word.slice(0, i))
        var startOfLine = i
        workingLen = 0
        while (i !== l) {
            if (workingLen + widths_array[i] > maxLen) {
                answer.push(word.slice(startOfLine, i))
                workingLen = 0
                startOfLine = i
            }
            workingLen += widths_array[i];
            i++;
        }
        if (startOfLine !== i) {
            answer.push(word.slice(startOfLine, i))
        }
        return answer
    }
    var splitParagraphIntoLines = function(text, maxlen, options) {
        if (!options) {
            options = {}
        }
        var line = [],
            lines = [line],
            line_length = options.textIndent || 0,
            separator_length = 0,
            current_word_length = 0,
            word, widths_array, words = text.split(' '),
            spaceCharWidth = getCharWidthsArray(' ', options)[0],
            i, l, tmp, lineIndent
        if (options.lineIndent === -1) {
            lineIndent = words[0].length + 2;
        } else {
            lineIndent = options.lineIndent || 0;
        }
        if (lineIndent) {
            var pad = Array(lineIndent).join(" "),
                wrds = [];
            words.map(function(wrd) {
                wrd = wrd.split(/\s*\n/);
                if (wrd.length > 1) {
                    wrds = wrds.concat(wrd.map(function(wrd, idx) {
                        return (idx && wrd.length ? "\n" : "") + wrd;
                    }));
                } else {
                    wrds.push(wrd[0]);
                }
            });
            words = wrds;
            lineIndent = getStringUnitWidth(pad, options);
        }
        for (i = 0, l = words.length; i < l; i++) {
            var force = 0;
            word = words[i]
            if (lineIndent && word[0] == "\n") {
                word = word.substr(1);
                force = 1;
            }
            widths_array = getCharWidthsArray(word, options)
            current_word_length = getArraySum(widths_array)
            if (line_length + separator_length + current_word_length > maxlen || force) {
                if (current_word_length > maxlen) {
                    tmp = splitLongWord(word, widths_array, maxlen - (line_length + separator_length), maxlen)
                    line.push(tmp.shift())
                    line = [tmp.pop()]
                    while (tmp.length) {
                        lines.push([tmp.shift()])
                    }
                    current_word_length = getArraySum(widths_array.slice(word.length - line[0].length))
                } else {
                    line = [word]
                }
                lines.push(line)
                line_length = current_word_length + lineIndent
                separator_length = spaceCharWidth
            } else {
                line.push(word)
                line_length += separator_length + current_word_length
                separator_length = spaceCharWidth
            }
        }
        if (lineIndent) {
            var postProcess = function(ln, idx) {
                return (idx ? pad : '') + ln.join(" ");
            };
        } else {
            var postProcess = function(ln) {
                return ln.join(" ")
            };
        }
        return lines.map(postProcess);
    }
    API.splitTextToSize = function(text, maxlen, options) {
        'use strict'
        if (!options) {
            options = {}
        }
        var fsize = options.fontSize || this.internal.getFontSize(),
            newOptions = (function(options) {
                var widths = {
                        0: 1
                    },
                    kerning = {}
                if (!options.widths || !options.kerning) {
                    var f = this.internal.getFont(options.fontName, options.fontStyle),
                        encoding = 'Unicode'
                    if (f.metadata[encoding]) {
                        return {
                            widths: f.metadata[encoding].widths || widths,
                            kerning: f.metadata[encoding].kerning || kerning
                        }
                    }
                } else {
                    return {
                        widths: options.widths,
                        kerning: options.kerning
                    }
                }
                return {
                    widths: widths,
                    kerning: kerning
                }
            }).call(this, options)
        var paragraphs
        if (Array.isArray(text)) {
            paragraphs = text;
        } else {
            paragraphs = text.split(/\r?\n/);
        }
        var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize
        newOptions.textIndent = options.textIndent ? options.textIndent * 1.0 * this.internal.scaleFactor / fsize : 0
        newOptions.lineIndent = options.lineIndent;
        var i, l, output = []
        for (i = 0, l = paragraphs.length; i < l; i++) {
            output = output.concat(splitParagraphIntoLines(paragraphs[i], fontUnit_maxLen, newOptions))
        }
        return output
    }
})(jsPDF.API);;
(function(API) {
    'use strict'
    var uncompress = function(data) {
        var decoded = '0123456789abcdef',
            encoded = 'klmnopqrstuvwxyz',
            mapping = {}
        for (var i = 0; i < encoded.length; i++) {
            mapping[encoded[i]] = decoded[i]
        }
        var undef, output = {},
            sign = 1,
            stringparts, activeobject = output,
            parentchain = [],
            parent_key_pair, keyparts = '',
            valueparts = '',
            key, datalen = data.length - 1,
            ch
        i = 1
        while (i != datalen) {
            ch = data[i]
            i += 1
            if (ch == "'") {
                if (stringparts) {
                    key = stringparts.join('')
                    stringparts = undef
                } else {
                    stringparts = []
                }
            } else if (stringparts) {
                stringparts.push(ch)
            } else if (ch == '{') {
                parentchain.push([activeobject, key])
                activeobject = {}
                key = undef
            } else if (ch == '}') {
                parent_key_pair = parentchain.pop()
                parent_key_pair[0][parent_key_pair[1]] = activeobject
                key = undef
                activeobject = parent_key_pair[0]
            } else if (ch == '-') {
                sign = -1
            } else {
                if (key === undef) {
                    if (mapping.hasOwnProperty(ch)) {
                        keyparts += mapping[ch]
                        key = parseInt(keyparts, 16) * sign
                        sign = +1
                        keyparts = ''
                    } else {
                        keyparts += ch
                    }
                } else {
                    if (mapping.hasOwnProperty(ch)) {
                        valueparts += mapping[ch]
                        activeobject[key] = parseInt(valueparts, 16) * sign
                        sign = +1
                        key = undef
                        valueparts = ''
                    } else {
                        valueparts += ch
                    }
                }
            }
        }
        return output
    }
    var encodingBlock = {
            'codePages': ['WinAnsiEncoding'],
            'WinAnsiEncoding': uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
        },
        encodings = {
            'Unicode': {
                'Courier': encodingBlock,
                'Courier-Bold': encodingBlock,
                'Courier-BoldOblique': encodingBlock,
                'Courier-Oblique': encodingBlock,
                'Helvetica': encodingBlock,
                'Helvetica-Bold': encodingBlock,
                'Helvetica-BoldOblique': encodingBlock,
                'Helvetica-Oblique': encodingBlock,
                'Times-Roman': encodingBlock,
                'Times-Bold': encodingBlock,
                'Times-BoldItalic': encodingBlock,
                'Times-Italic': encodingBlock
            }
        },
        fontMetrics = {
            'Unicode': {
                'Courier-Oblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                'Times-BoldItalic': uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
                'Helvetica-Bold': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
                'Courier': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                'Courier-BoldOblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                'Times-Bold': uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
                'Helvetica': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
                'Helvetica-BoldOblique': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
                'Courier-Bold': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                'Times-Italic': uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
                'Times-Roman': uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
                'Helvetica-Oblique': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
            }
        };
    API.events.push(['addFonts', function(fontManagementObjects) {
        var font, fontID, metrics, unicode_section, encoding = 'Unicode',
            encodingBlock
        for (fontID in fontManagementObjects.fonts) {
            if (fontManagementObjects.fonts.hasOwnProperty(fontID)) {
                font = fontManagementObjects.fonts[fontID]
                metrics = fontMetrics[encoding][font.PostScriptName]
                if (metrics) {
                    if (font.metadata[encoding]) {
                        unicode_section = font.metadata[encoding]
                    } else {
                        unicode_section = font.metadata[encoding] = {}
                    }
                    unicode_section.widths = metrics.widths
                    unicode_section.kerning = metrics.kerning
                }
                encodingBlock = encodings[encoding][font.PostScriptName]
                if (encodingBlock) {
                    if (font.metadata[encoding]) {
                        unicode_section = font.metadata[encoding]
                    } else {
                        unicode_section = font.metadata[encoding] = {}
                    }
                    unicode_section.encoding = encodingBlock
                    if (encodingBlock.codePages && encodingBlock.codePages.length) {
                        font.encoding = encodingBlock.codePages[0]
                    }
                }
            }
        }
    }])
})(jsPDF.API);
(function(jsPDFAPI) {
    'use strict';
    jsPDFAPI.putTotalPages = function(pageExpression) {
        'use strict';
        var replaceExpression = new RegExp(pageExpression, 'g');
        for (var n = 1; n <= this.internal.getNumberOfPages(); n++) {
            for (var i = 0; i < this.internal.pages[n].length; i++)
                this.internal.pages[n][i] = this.internal.pages[n][i].replace(replaceExpression, this.internal.getNumberOfPages());
        }
        return this;
    };
})(jsPDF.API); /*!@source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js*/
(function(view) {
    "use strict";
    view.URL = view.URL || view.webkitURL;
    if (view.Blob && view.URL) {
        try {
            new Blob;
            return;
        } catch (e) {}
    }
    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
        var
            get_class = function(object) {
                return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
            },
            FakeBlobBuilder = function BlobBuilder() {
                this.data = [];
            },
            FakeBlob = function Blob(data, type, encoding) {
                this.data = data;
                this.size = data.length;
                this.type = type;
                this.encoding = encoding;
            },
            FBB_proto = FakeBlobBuilder.prototype,
            FB_proto = FakeBlob.prototype,
            FileReaderSync = view.FileReaderSync,
            FileException = function(type) {
                this.code = this[this.name = type];
            },
            file_ex_codes = ("NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR " +
                "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
            file_ex_code = file_ex_codes.length,
            real_URL = view.URL || view.webkitURL || view,
            real_create_object_URL = real_URL.createObjectURL,
            real_revoke_object_URL = real_URL.revokeObjectURL,
            URL = real_URL,
            btoa = view.btoa,
            atob = view.atob,
            ArrayBuffer = view.ArrayBuffer,
            Uint8Array = view.Uint8Array,
            origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        if (!real_URL.createObjectURL) {
            URL = view.URL = function(uri) {
                var
                    uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                    uri_origin;
                uri_info.href = uri;
                if (!("origin" in uri_info)) {
                    if (uri_info.protocol.toLowerCase() === "data:") {
                        uri_info.origin = null;
                    } else {
                        uri_origin = uri.match(origin);
                        uri_info.origin = uri_origin && uri_origin[1];
                    }
                }
                return uri_info;
            };
        }
        URL.createObjectURL = function(blob) {
            var
                type = blob.type,
                data_URI_header;
            if (type === null) {
                type = "application/octet-stream";
            }
            if (blob instanceof FakeBlob) {
                data_URI_header = "data:" + type;
                if (blob.encoding === "base64") {
                    return data_URI_header + ";base64," + blob.data;
                } else if (blob.encoding === "URI") {
                    return data_URI_header + "," + decodeURIComponent(blob.data);
                }
                if (btoa) {
                    return data_URI_header + ";base64," + btoa(blob.data);
                } else {
                    return data_URI_header + "," + encodeURIComponent(blob.data);
                }
            } else if (real_create_object_URL) {
                return real_create_object_URL.call(real_URL, blob);
            }
        };
        URL.revokeObjectURL = function(object_URL) {
            if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                real_revoke_object_URL.call(real_URL, object_URL);
            }
        };
        FBB_proto.append = function(data) {
            var bb = this.data;
            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                var
                    str = "",
                    buf = new Uint8Array(data),
                    i = 0,
                    buf_len = buf.length;
                for (; i < buf_len; i++) {
                    str += String.fromCharCode(buf[i]);
                }
                bb.push(str);
            } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                if (FileReaderSync) {
                    var fr = new FileReaderSync;
                    bb.push(fr.readAsBinaryString(data));
                } else {
                    throw new FileException("NOT_READABLE_ERR");
                }
            } else if (data instanceof FakeBlob) {
                if (data.encoding === "base64" && atob) {
                    bb.push(atob(data.data));
                } else if (data.encoding === "URI") {
                    bb.push(decodeURIComponent(data.data));
                } else if (data.encoding === "raw") {
                    bb.push(data.data);
                }
            } else {
                if (typeof data !== "string") {
                    data += "";
                }
                bb.push(unescape(encodeURIComponent(data)));
            }
        };
        FBB_proto.getBlob = function(type) {
            if (!arguments.length) {
                type = null;
            }
            return new FakeBlob(this.data.join(""), type, "raw");
        };
        FBB_proto.toString = function() {
            return "[object BlobBuilder]";
        };
        FB_proto.slice = function(start, end, type) {
            var args = arguments.length;
            if (args < 3) {
                type = null;
            }
            return new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding);
        };
        FB_proto.toString = function() {
            return "[object Blob]";
        };
        FB_proto.close = function() {
            this.size = 0;
            delete this.data;
        };
        return FakeBlobBuilder;
    }(view));
    view.Blob = function(blobParts, options) {
        var type = options ? (options.type || "") : "";
        var builder = new BlobBuilder();
        if (blobParts) {
            for (var i = 0, len = blobParts.length; i < len; i++) {
                builder.append(blobParts[i]);
            }
        }
        return builder.getBlob(type);
    };
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this)); /*!@source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js*/
var saveAs = saveAs || (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator)) || (function(view) {
    "use strict";
    if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var
        doc = view.document,
        get_URL = function() {
            return view.URL || view.webkitURL || view;
        },
        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
        can_use_save_link = "download" in save_link,
        click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent("click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            node.dispatchEvent(event);
        },
        webkit_req_fs = view.webkitRequestFileSystem,
        req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
        throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        },
        force_saveable_type = "application/octet-stream",
        fs_min_size = 0,
        arbitrary_revoke_timeout = 10,
        revoke = function(file) {
            var revoker = function() {
                if (typeof file === "string") {
                    get_URL().revokeObjectURL(file);
                } else {
                    file.remove();
                }
            };
            if (view.chrome) {
                revoker();
            } else {
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
        },
        dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        },
        FileSaver = function(blob, name) {
            var
                filesaver = this,
                type = blob.type,
                blob_changed = false,
                object_url, target_view, dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                },
                fs_error = function() {
                    if (blob_changed || !object_url) {
                        object_url = get_URL().createObjectURL(blob);
                    }
                    if (target_view) {
                        target_view.location.href = object_url;
                    } else {
                        var new_tab = view.open(object_url, "_blank");
                        if (new_tab == undefined && typeof safari !== "undefined") {
                            view.location.href = object_url
                        }
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                },
                abortable = function(func) {
                    return function() {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                },
                create_if_not_found = {
                    create: true,
                    exclusive: false
                },
                slice;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_URL().createObjectURL(blob);
                save_link.href = object_url;
                save_link.download = name;
                click(save_link);
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                revoke(object_url);
                return;
            }
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            if (webkit_req_fs && name !== "download") {
                name += ".download";
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL();
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, "writeend", event);
                                    revoke(file);
                                };
                                writer.onerror = function() {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function() {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {
                        create: false
                    }, abortable(function(file) {
                        file.remove();
                        save();
                    }), abortable(function(ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        },
        FS_proto = FileSaver.prototype,
        saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        };
    FS_proto.abort = function() {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;
    FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
    return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content));
if (typeof module !== "undefined" && module !== null) {
    module.exports = saveAs;
} else if ((typeof define !== "undefined" && 0)) {
    define([], function() {
        return saveAs;
    });
}
void
function(global, callback) {
    if (typeof module === 'object') {
        module.exports = callback();
    } else if (0 === 'function') {
        define(callback);
    } else {
        global.adler32cs = callback();
    }
}(jsPDF, function() {
    var _hasArrayBuffer = typeof ArrayBuffer === 'function' && typeof Uint8Array === 'function';
    var _Buffer = null,
        _isBuffer = (function() {
            if (!_hasArrayBuffer)
                return function _isBuffer() {
                    return false
                };
            try {
                var buffer = require('buffer');
                if (typeof buffer.Buffer === 'function')
                    _Buffer = buffer.Buffer;
            } catch (error) {}
            return function _isBuffer(value) {
                return value instanceof ArrayBuffer || _Buffer !== null && value instanceof _Buffer;
            };
        }());
    var _utf8ToBinary = (function() {
        if (_Buffer !== null) {
            return function _utf8ToBinary(utf8String) {
                return new _Buffer(utf8String, 'utf8').toString('binary');
            };
        } else {
            return function _utf8ToBinary(utf8String) {
                return unescape(encodeURIComponent(utf8String));
            };
        }
    }());
    var MOD = 65521;
    var _update = function _update(checksum, binaryString) {
        var a = checksum & 0xFFFF,
            b = checksum >>> 16;
        for (var i = 0, length = binaryString.length; i < length; i++) {
            a = (a + (binaryString.charCodeAt(i) & 0xFF)) % MOD;
            b = (b + a) % MOD;
        }
        return (b << 16 | a) >>> 0;
    };
    var _updateUint8Array = function _updateUint8Array(checksum, uint8Array) {
        var a = checksum & 0xFFFF,
            b = checksum >>> 16;
        for (var i = 0, length = uint8Array.length, x; i < length; i++) {
            a = (a + uint8Array[i]) % MOD;
            b = (b + a) % MOD;
        }
        return (b << 16 | a) >>> 0
    };
    var exports = {};
    var Adler32 = exports.Adler32 = (function() {
        var ctor = function Adler32(checksum) {
            if (!(this instanceof ctor)) {
                throw new TypeError('Constructor cannot called be as a function.');
            }
            if (!isFinite(checksum = checksum == null ? 1 : +checksum)) {
                throw new Error('First arguments needs to be a finite number.');
            }
            this.checksum = checksum >>> 0;
        };
        var proto = ctor.prototype = {};
        proto.constructor = ctor;
        ctor.from = function(from) {
            from.prototype = proto;
            return from;
        }(function from(binaryString) {
            if (!(this instanceof ctor)) {
                throw new TypeError('Constructor cannot called be as a function.');
            }
            if (binaryString == null)
                throw new Error('First argument needs to be a string.');
            this.checksum = _update(1, binaryString.toString());
        });
        ctor.fromUtf8 = function(fromUtf8) {
            fromUtf8.prototype = proto;
            return fromUtf8;
        }(function fromUtf8(utf8String) {
            if (!(this instanceof ctor)) {
                throw new TypeError('Constructor cannot called be as a function.');
            }
            if (utf8String == null)
                throw new Error('First argument needs to be a string.');
            var binaryString = _utf8ToBinary(utf8String.toString());
            this.checksum = _update(1, binaryString);
        });
        if (_hasArrayBuffer) {
            ctor.fromBuffer = function(fromBuffer) {
                fromBuffer.prototype = proto;
                return fromBuffer;
            }(function fromBuffer(buffer) {
                if (!(this instanceof ctor)) {
                    throw new TypeError('Constructor cannot called be as a function.');
                }
                if (!_isBuffer(buffer))
                    throw new Error('First argument needs to be ArrayBuffer.');
                var array = new Uint8Array(buffer);
                return this.checksum = _updateUint8Array(1, array);
            });
        }
        proto.update = function update(binaryString) {
            if (binaryString == null)
                throw new Error('First argument needs to be a string.');
            binaryString = binaryString.toString();
            return this.checksum = _update(this.checksum, binaryString);
        };
        proto.updateUtf8 = function updateUtf8(utf8String) {
            if (utf8String == null)
                throw new Error('First argument needs to be a string.');
            var binaryString = _utf8ToBinary(utf8String.toString());
            return this.checksum = _update(this.checksum, binaryString);
        };
        if (_hasArrayBuffer) {
            proto.updateBuffer = function updateBuffer(buffer) {
                if (!_isBuffer(buffer))
                    throw new Error('First argument needs to be ArrayBuffer.');
                var array = new Uint8Array(buffer);
                return this.checksum = _updateUint8Array(this.checksum, array);
            };
        }
        proto.clone = function clone() {
            return new Adler32(this.checksum);
        };
        return ctor;
    }());
    exports.from = function from(binaryString) {
        if (binaryString == null)
            throw new Error('First argument needs to be a string.');
        return _update(1, binaryString.toString());
    };
    exports.fromUtf8 = function fromUtf8(utf8String) {
        if (utf8String == null)
            throw new Error('First argument needs to be a string.');
        var binaryString = _utf8ToBinary(utf8String.toString());
        return _update(1, binaryString);
    };
    if (_hasArrayBuffer) {
        exports.fromBuffer = function fromBuffer(buffer) {
            if (!_isBuffer(buffer))
                throw new Error('First argument need to be ArrayBuffer.');
            var array = new Uint8Array(buffer);
            return _updateUint8Array(1, array);
        };
    }
    return exports;
});
var Deflater = (function(obj) {
    var MAX_BITS = 15;
    var D_CODES = 30;
    var BL_CODES = 19;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = (LITERALS + 1 + LENGTH_CODES);
    var HEAP_SIZE = (2 * L_CODES + 1);
    var END_BLOCK = 256;
    var MAX_BL_BITS = 7;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var Buf_size = 8 * 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var _dist_code = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];

    function Tree() {
        var that = this;

        function gen_bitlen(s) {
            var tree = that.dyn_tree;
            var stree = that.stat_desc.static_tree;
            var extra = that.stat_desc.extra_bits;
            var base = that.stat_desc.extra_base;
            var max_length = that.stat_desc.max_length;
            var h;
            var n, m;
            var bits;
            var xbits;
            var f;
            var overflow = 0;
            for (bits = 0; bits <= MAX_BITS; bits++)
                s.bl_count[bits] = 0;
            tree[s.heap[s.heap_max] * 2 + 1] = 0;
            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                n = s.heap[h];
                bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                }
                tree[n * 2 + 1] = bits;
                if (n > that.max_code)
                    continue;
                s.bl_count[bits]++;
                xbits = 0;
                if (n >= base)
                    xbits = extra[n - base];
                f = tree[n * 2];
                s.opt_len += f * (bits + xbits);
                if (stree)
                    s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
            if (overflow === 0)
                return;
            do {
                bits = max_length - 1;
                while (s.bl_count[bits] === 0)
                    bits--;
                s.bl_count[bits]--;
                s.bl_count[bits + 1] += 2;
                s.bl_count[max_length]--;
                overflow -= 2;
            } while (overflow > 0);
            for (bits = max_length; bits !== 0; bits--) {
                n = s.bl_count[bits];
                while (n !== 0) {
                    m = s.heap[--h];
                    if (m > that.max_code)
                        continue;
                    if (tree[m * 2 + 1] != bits) {
                        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                        tree[m * 2 + 1] = bits;
                    }
                    n--;
                }
            }
        }

        function bi_reverse(code, len) {
            var res = 0;
            do {
                res |= code & 1;
                code >>>= 1;
                res <<= 1;
            } while (--len > 0);
            return res >>> 1;
        }

        function gen_codes(tree, max_code, bl_count) {
            var next_code = [];
            var code = 0;
            var bits;
            var n;
            var len;
            for (bits = 1; bits <= MAX_BITS; bits++) {
                next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);
            }
            for (n = 0; n <= max_code; n++) {
                len = tree[n * 2 + 1];
                if (len === 0)
                    continue;
                tree[n * 2] = bi_reverse(next_code[len]++, len);
            }
        }
        that.build_tree = function(s) {
            var tree = that.dyn_tree;
            var stree = that.stat_desc.static_tree;
            var elems = that.stat_desc.elems;
            var n, m;
            var max_code = -1;
            var node;
            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;
            for (n = 0; n < elems; n++) {
                if (tree[n * 2] !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;
                } else {
                    tree[n * 2 + 1] = 0;
                }
            }
            while (s.heap_len < 2) {
                node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                tree[node * 2] = 1;
                s.depth[node] = 0;
                s.opt_len--;
                if (stree)
                    s.static_len -= stree[node * 2 + 1];
            }
            that.max_code = max_code;
            for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
                s.pqdownheap(tree, n);
            node = elems;
            do {
                n = s.heap[1];
                s.heap[1] = s.heap[s.heap_len--];
                s.pqdownheap(tree, 1);
                m = s.heap[1];
                s.heap[--s.heap_max] = n;
                s.heap[--s.heap_max] = m;
                tree[node * 2] = (tree[n * 2] + tree[m * 2]);
                s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
                tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                s.heap[1] = node++;
                s.pqdownheap(tree, 1);
            } while (s.heap_len >= 2);
            s.heap[--s.heap_max] = s.heap[1];
            gen_bitlen(s);
            gen_codes(tree, that.max_code, s.bl_count);
        };
    }
    Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28];
    Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
    Tree.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576];
    Tree.d_code = function(dist) {
        return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);
    };
    Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

    function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
        var that = this;
        that.static_tree = static_tree;
        that.extra_bits = extra_bits;
        that.extra_base = extra_base;
        that.elems = elems;
        that.max_length = max_length;
    }
    StaticTree.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8];
    StaticTree.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5];
    StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
    StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    var MAX_MEM_LEVEL = 9;
    var DEF_MEM_LEVEL = 8;

    function Config(good_length, max_lazy, nice_length, max_chain, func) {
        var that = this;
        that.good_length = good_length;
        that.max_lazy = max_lazy;
        that.nice_length = nice_length;
        that.max_chain = max_chain;
        that.func = func;
    }
    var STORED = 0;
    var FAST = 1;
    var SLOW = 2;
    var config_table = [new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST), new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW), new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW)];
    var z_errmsg = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""];
    var NeedMore = 0;
    var BlockDone = 1;
    var FinishStarted = 2;
    var FinishDone = 3;
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var Z_DEFLATED = 8;
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

    function smaller(tree, n, m, depth) {
        var tn2 = tree[n * 2];
        var tm2 = tree[m * 2];
        return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));
    }

    function Deflate() {
        var that = this;
        var strm;
        var status;
        var pending_buf_size;
        var method;
        var last_flush;
        var w_size;
        var w_bits;
        var w_mask;
        var window;
        var window_size;
        var prev;
        var head;
        var ins_h;
        var hash_size;
        var hash_bits;
        var hash_mask;
        var hash_shift;
        var block_start;
        var match_length;
        var prev_match;
        var match_available;
        var strstart;
        var match_start;
        var lookahead;
        var prev_length;
        var max_chain_length;
        var max_lazy_match;
        var level;
        var strategy;
        var good_match;
        var nice_match;
        var dyn_ltree;
        var dyn_dtree;
        var bl_tree;
        var l_desc = new Tree();
        var d_desc = new Tree();
        var bl_desc = new Tree();
        that.depth = [];
        var l_buf;
        var lit_bufsize;
        var last_lit;
        var d_buf;
        var matches;
        var last_eob_len;
        var bi_buf;
        var bi_valid;
        that.bl_count = [];
        that.heap = [];
        dyn_ltree = [];
        dyn_dtree = [];
        bl_tree = [];

        function lm_init() {
            var i;
            window_size = 2 * w_size;
            head[hash_size - 1] = 0;
            for (i = 0; i < hash_size - 1; i++) {
                head[i] = 0;
            }
            max_lazy_match = config_table[level].max_lazy;
            good_match = config_table[level].good_length;
            nice_match = config_table[level].nice_length;
            max_chain_length = config_table[level].max_chain;
            strstart = 0;
            block_start = 0;
            lookahead = 0;
            match_length = prev_length = MIN_MATCH - 1;
            match_available = 0;
            ins_h = 0;
        }

        function init_block() {
            var i;
            for (i = 0; i < L_CODES; i++)
                dyn_ltree[i * 2] = 0;
            for (i = 0; i < D_CODES; i++)
                dyn_dtree[i * 2] = 0;
            for (i = 0; i < BL_CODES; i++)
                bl_tree[i * 2] = 0;
            dyn_ltree[END_BLOCK * 2] = 1;
            that.opt_len = that.static_len = 0;
            last_lit = matches = 0;
        }

        function tr_init() {
            l_desc.dyn_tree = dyn_ltree;
            l_desc.stat_desc = StaticTree.static_l_desc;
            d_desc.dyn_tree = dyn_dtree;
            d_desc.stat_desc = StaticTree.static_d_desc;
            bl_desc.dyn_tree = bl_tree;
            bl_desc.stat_desc = StaticTree.static_bl_desc;
            bi_buf = 0;
            bi_valid = 0;
            last_eob_len = 8;
            init_block();
        }
        that.pqdownheap = function(tree, k) {
            var heap = that.heap;
            var v = heap[k];
            var j = k << 1;
            while (j <= that.heap_len) {
                if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
                    j++;
                }
                if (smaller(tree, v, heap[j], that.depth))
                    break;
                heap[k] = heap[j];
                k = j;
                j <<= 1;
            }
            heap[k] = v;
        };

        function scan_tree(tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }
            tree[(max_code + 1) * 2 + 1] = 0xffff;
            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1];
                if (++count < max_count && curlen == nextlen) {
                    continue;
                } else if (count < min_count) {
                    bl_tree[curlen * 2] += count;
                } else if (curlen !== 0) {
                    if (curlen != prevlen)
                        bl_tree[curlen * 2]++;
                    bl_tree[REP_3_6 * 2]++;
                } else if (count <= 10) {
                    bl_tree[REPZ_3_10 * 2]++;
                } else {
                    bl_tree[REPZ_11_138 * 2]++;
                }
                count = 0;
                prevlen = curlen;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                } else if (curlen == nextlen) {
                    max_count = 6;
                    min_count = 3;
                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }

        function build_bl_tree() {
            var max_blindex;
            scan_tree(dyn_ltree, l_desc.max_code);
            scan_tree(dyn_dtree, d_desc.max_code);
            bl_desc.build_tree(that);
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
                    break;
            }
            that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
            return max_blindex;
        }

        function put_byte(p) {
            that.pending_buf[that.pending++] = p;
        }

        function put_short(w) {
            put_byte(w & 0xff);
            put_byte((w >>> 8) & 0xff);
        }

        function putShortMSB(b) {
            put_byte((b >> 8) & 0xff);
            put_byte((b & 0xff) & 0xff);
        }

        function send_bits(value, length) {
            var val, len = length;
            if (bi_valid > Buf_size - len) {
                val = value;
                bi_buf |= ((val << bi_valid) & 0xffff);
                put_short(bi_buf);
                bi_buf = val >>> (Buf_size - bi_valid);
                bi_valid += len - Buf_size;
            } else {
                bi_buf |= (((value) << bi_valid) & 0xffff);
                bi_valid += len;
            }
        }

        function send_code(c, tree) {
            var c2 = c * 2;
            send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
        }

        function send_tree(tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }
            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1];
                if (++count < max_count && curlen == nextlen) {
                    continue;
                } else if (count < min_count) {
                    do {
                        send_code(curlen, bl_tree);
                    } while (--count !== 0);
                } else if (curlen !== 0) {
                    if (curlen != prevlen) {
                        send_code(curlen, bl_tree);
                        count--;
                    }
                    send_code(REP_3_6, bl_tree);
                    send_bits(count - 3, 2);
                } else if (count <= 10) {
                    send_code(REPZ_3_10, bl_tree);
                    send_bits(count - 3, 3);
                } else {
                    send_code(REPZ_11_138, bl_tree);
                    send_bits(count - 11, 7);
                }
                count = 0;
                prevlen = curlen;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                } else if (curlen == nextlen) {
                    max_count = 6;
                    min_count = 3;
                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }

        function send_all_trees(lcodes, dcodes, blcodes) {
            var rank;
            send_bits(lcodes - 257, 5);
            send_bits(dcodes - 1, 5);
            send_bits(blcodes - 4, 4);
            for (rank = 0; rank < blcodes; rank++) {
                send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
            }
            send_tree(dyn_ltree, lcodes - 1);
            send_tree(dyn_dtree, dcodes - 1);
        }

        function bi_flush() {
            if (bi_valid == 16) {
                put_short(bi_buf);
                bi_buf = 0;
                bi_valid = 0;
            } else if (bi_valid >= 8) {
                put_byte(bi_buf & 0xff);
                bi_buf >>>= 8;
                bi_valid -= 8;
            }
        }

        function _tr_align() {
            send_bits(STATIC_TREES << 1, 3);
            send_code(END_BLOCK, StaticTree.static_ltree);
            bi_flush();
            if (1 + last_eob_len + 10 - bi_valid < 9) {
                send_bits(STATIC_TREES << 1, 3);
                send_code(END_BLOCK, StaticTree.static_ltree);
                bi_flush();
            }
            last_eob_len = 7;
        }

        function _tr_tally(dist, lc) {
            var out_length, in_length, dcode;
            that.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;
            that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;
            that.pending_buf[l_buf + last_lit] = lc & 0xff;
            last_lit++;
            if (dist === 0) {
                dyn_ltree[lc * 2]++;
            } else {
                matches++;
                dist--;
                dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
                dyn_dtree[Tree.d_code(dist) * 2]++;
            }
            if ((last_lit & 0x1fff) === 0 && level > 2) {
                out_length = last_lit * 8;
                in_length = strstart - block_start;
                for (dcode = 0; dcode < D_CODES; dcode++) {
                    out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
                }
                out_length >>>= 3;
                if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))
                    return true;
            }
            return (last_lit == lit_bufsize - 1);
        }

        function compress_block(ltree, dtree) {
            var dist;
            var lc;
            var lx = 0;
            var code;
            var extra;
            if (last_lit !== 0) {
                do {
                    dist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);
                    lc = (that.pending_buf[l_buf + lx]) & 0xff;
                    lx++;
                    if (dist === 0) {
                        send_code(lc, ltree);
                    } else {
                        code = Tree._length_code[lc];
                        send_code(code + LITERALS + 1, ltree);
                        extra = Tree.extra_lbits[code];
                        if (extra !== 0) {
                            lc -= Tree.base_length[code];
                            send_bits(lc, extra);
                        }
                        dist--;
                        code = Tree.d_code(dist);
                        send_code(code, dtree);
                        extra = Tree.extra_dbits[code];
                        if (extra !== 0) {
                            dist -= Tree.base_dist[code];
                            send_bits(dist, extra);
                        }
                    }
                } while (lx < last_lit);
            }
            send_code(END_BLOCK, ltree);
            last_eob_len = ltree[END_BLOCK * 2 + 1];
        }

        function bi_windup() {
            if (bi_valid > 8) {
                put_short(bi_buf);
            } else if (bi_valid > 0) {
                put_byte(bi_buf & 0xff);
            }
            bi_buf = 0;
            bi_valid = 0;
        }

        function copy_block(buf, len, header) {
            bi_windup();
            last_eob_len = 8;
            if (header) {
                put_short(len);
                put_short(~len);
            }
            that.pending_buf.set(window.subarray(buf, buf + len), that.pending);
            that.pending += len;
        }

        function _tr_stored_block(buf, stored_len, eof) {
            send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
            copy_block(buf, stored_len, true);
        }

        function _tr_flush_block(buf, stored_len, eof) {
            var opt_lenb, static_lenb;
            var max_blindex = 0;
            if (level > 0) {
                l_desc.build_tree(that);
                d_desc.build_tree(that);
                max_blindex = build_bl_tree();
                opt_lenb = (that.opt_len + 3 + 7) >>> 3;
                static_lenb = (that.static_len + 3 + 7) >>> 3;
                if (static_lenb <= opt_lenb)
                    opt_lenb = static_lenb;
            } else {
                opt_lenb = static_lenb = stored_len + 5;
            }
            if ((stored_len + 4 <= opt_lenb) && buf != -1) {
                _tr_stored_block(buf, stored_len, eof);
            } else if (static_lenb == opt_lenb) {
                send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
                compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
            } else {
                send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
                send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
                compress_block(dyn_ltree, dyn_dtree);
            }
            init_block();
            if (eof) {
                bi_windup();
            }
        }

        function flush_block_only(eof) {
            _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
            block_start = strstart;
            strm.flush_pending();
        }

        function fill_window() {
            var n, m;
            var p;
            var more;
            do {
                more = (window_size - lookahead - strstart);
                if (more === 0 && strstart === 0 && lookahead === 0) {
                    more = w_size;
                } else if (more == -1) {
                    more--;
                } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
                    window.set(window.subarray(w_size, w_size + w_size), 0);
                    match_start -= w_size;
                    strstart -= w_size;
                    block_start -= w_size;
                    n = hash_size;
                    p = n;
                    do {
                        m = (head[--p] & 0xffff);
                        head[p] = (m >= w_size ? m - w_size : 0);
                    } while (--n !== 0);
                    n = w_size;
                    p = n;
                    do {
                        m = (prev[--p] & 0xffff);
                        prev[p] = (m >= w_size ? m - w_size : 0);
                    } while (--n !== 0);
                    more += w_size;
                }
                if (strm.avail_in === 0)
                    return;
                n = strm.read_buf(window, strstart + lookahead, more);
                lookahead += n;
                if (lookahead >= MIN_MATCH) {
                    ins_h = window[strstart] & 0xff;
                    ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;
                }
            } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
        }

        function deflate_stored(flush) {
            var max_block_size = 0xffff;
            var max_start;
            if (max_block_size > pending_buf_size - 5) {
                max_block_size = pending_buf_size - 5;
            }
            while (true) {
                if (lookahead <= 1) {
                    fill_window();
                    if (lookahead === 0 && flush == Z_NO_FLUSH)
                        return NeedMore;
                    if (lookahead === 0)
                        break;
                }
                strstart += lookahead;
                lookahead = 0;
                max_start = block_start + max_block_size;
                if (strstart === 0 || strstart >= max_start) {
                    lookahead = (strstart - max_start);
                    strstart = max_start;
                    flush_block_only(false);
                    if (strm.avail_out === 0)
                        return NeedMore;
                }
                if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
                    flush_block_only(false);
                    if (strm.avail_out === 0)
                        return NeedMore;
                }
            }
            flush_block_only(flush == Z_FINISH);
            if (strm.avail_out === 0)
                return (flush == Z_FINISH) ? FinishStarted : NeedMore;
            return flush == Z_FINISH ? FinishDone : BlockDone;
        }

        function longest_match(cur_match) {
            var chain_length = max_chain_length;
            var scan = strstart;
            var match;
            var len;
            var best_len = prev_length;
            var limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
            var _nice_match = nice_match;
            var wmask = w_mask;
            var strend = strstart + MAX_MATCH;
            var scan_end1 = window[scan + best_len - 1];
            var scan_end = window[scan + best_len];
            if (prev_length >= good_match) {
                chain_length >>= 2;
            }
            if (_nice_match > lookahead)
                _nice_match = lookahead;
            do {
                match = cur_match;
                if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1])
                    continue;
                scan += 2;
                match++;
                do {} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);
                len = MAX_MATCH - (strend - scan);
                scan = strend - MAX_MATCH;
                if (len > best_len) {
                    match_start = cur_match;
                    best_len = len;
                    if (len >= _nice_match)
                        break;
                    scan_end1 = window[scan + best_len - 1];
                    scan_end = window[scan + best_len];
                }
            } while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);
            if (best_len <= lookahead)
                return best_len;
            return lookahead;
        }

        function deflate_fast(flush) {
            var hash_head = 0;
            var bflush;
            while (true) {
                if (lookahead < MIN_LOOKAHEAD) {
                    fill_window();
                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                        return NeedMore;
                    }
                    if (lookahead === 0)
                        break;
                }
                if (lookahead >= MIN_MATCH) {
                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
                    hash_head = (head[ins_h] & 0xffff);
                    prev[strstart & w_mask] = head[ins_h];
                    head[ins_h] = strstart;
                }
                if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                    if (strategy != Z_HUFFMAN_ONLY) {
                        match_length = longest_match(hash_head);
                    }
                }
                if (match_length >= MIN_MATCH) {
                    bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
                    lookahead -= match_length;
                    if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
                        match_length--;
                        do {
                            strstart++;
                            ins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
                            hash_head = (head[ins_h] & 0xffff);
                            prev[strstart & w_mask] = head[ins_h];
                            head[ins_h] = strstart;
                        } while (--match_length !== 0);
                        strstart++;
                    } else {
                        strstart += match_length;
                        match_length = 0;
                        ins_h = window[strstart] & 0xff;
                        ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;
                    }
                } else {
                    bflush = _tr_tally(0, window[strstart] & 0xff);
                    lookahead--;
                    strstart++;
                }
                if (bflush) {
                    flush_block_only(false);
                    if (strm.avail_out === 0)
                        return NeedMore;
                }
            }
            flush_block_only(flush == Z_FINISH);
            if (strm.avail_out === 0) {
                if (flush == Z_FINISH)
                    return FinishStarted;
                else
                    return NeedMore;
            }
            return flush == Z_FINISH ? FinishDone : BlockDone;
        }

        function deflate_slow(flush) {
            var hash_head = 0;
            var bflush;
            var max_insert;
            while (true) {
                if (lookahead < MIN_LOOKAHEAD) {
                    fill_window();
                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                        return NeedMore;
                    }
                    if (lookahead === 0)
                        break;
                }
                if (lookahead >= MIN_MATCH) {
                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
                    hash_head = (head[ins_h] & 0xffff);
                    prev[strstart & w_mask] = head[ins_h];
                    head[ins_h] = strstart;
                }
                prev_length = match_length;
                prev_match = match_start;
                match_length = MIN_MATCH - 1;
                if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                    if (strategy != Z_HUFFMAN_ONLY) {
                        match_length = longest_match(hash_head);
                    }
                    if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {
                        match_length = MIN_MATCH - 1;
                    }
                }
                if (prev_length >= MIN_MATCH && match_length <= prev_length) {
                    max_insert = strstart + lookahead - MIN_MATCH;
                    bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
                    lookahead -= prev_length - 1;
                    prev_length -= 2;
                    do {
                        if (++strstart <= max_insert) {
                            ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
                            hash_head = (head[ins_h] & 0xffff);
                            prev[strstart & w_mask] = head[ins_h];
                            head[ins_h] = strstart;
                        }
                    } while (--prev_length !== 0);
                    match_available = 0;
                    match_length = MIN_MATCH - 1;
                    strstart++;
                    if (bflush) {
                        flush_block_only(false);
                        if (strm.avail_out === 0)
                            return NeedMore;
                    }
                } else if (match_available !== 0) {
                    bflush = _tr_tally(0, window[strstart - 1] & 0xff);
                    if (bflush) {
                        flush_block_only(false);
                    }
                    strstart++;
                    lookahead--;
                    if (strm.avail_out === 0)
                        return NeedMore;
                } else {
                    match_available = 1;
                    strstart++;
                    lookahead--;
                }
            }
            if (match_available !== 0) {
                bflush = _tr_tally(0, window[strstart - 1] & 0xff);
                match_available = 0;
            }
            flush_block_only(flush == Z_FINISH);
            if (strm.avail_out === 0) {
                if (flush == Z_FINISH)
                    return FinishStarted;
                else
                    return NeedMore;
            }
            return flush == Z_FINISH ? FinishDone : BlockDone;
        }

        function deflateReset(strm) {
            strm.total_in = strm.total_out = 0;
            strm.msg = null;
            that.pending = 0;
            that.pending_out = 0;
            status = BUSY_STATE;
            last_flush = Z_NO_FLUSH;
            tr_init();
            lm_init();
            return Z_OK;
        }
        that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {
            if (!_method)
                _method = Z_DEFLATED;
            if (!memLevel)
                memLevel = DEF_MEM_LEVEL;
            if (!_strategy)
                _strategy = Z_DEFAULT_STRATEGY;
            strm.msg = null;
            if (_level == Z_DEFAULT_COMPRESSION)
                _level = 6;
            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
                return Z_STREAM_ERROR;
            }
            strm.dstate = that;
            w_bits = bits;
            w_size = 1 << w_bits;
            w_mask = w_size - 1;
            hash_bits = memLevel + 7;
            hash_size = 1 << hash_bits;
            hash_mask = hash_size - 1;
            hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
            window = new Uint8Array(w_size * 2);
            prev = [];
            head = [];
            lit_bufsize = 1 << (memLevel + 6);
            that.pending_buf = new Uint8Array(lit_bufsize * 4);
            pending_buf_size = lit_bufsize * 4;
            d_buf = Math.floor(lit_bufsize / 2);
            l_buf = (1 + 2) * lit_bufsize;
            level = _level;
            strategy = _strategy;
            method = _method & 0xff;
            return deflateReset(strm);
        };
        that.deflateEnd = function() {
            if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
                return Z_STREAM_ERROR;
            }
            that.pending_buf = null;
            head = null;
            prev = null;
            window = null;
            that.dstate = null;
            return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
        };
        that.deflateParams = function(strm, _level, _strategy) {
            var err = Z_OK;
            if (_level == Z_DEFAULT_COMPRESSION) {
                _level = 6;
            }
            if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
                return Z_STREAM_ERROR;
            }
            if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
                err = strm.deflate(Z_PARTIAL_FLUSH);
            }
            if (level != _level) {
                level = _level;
                max_lazy_match = config_table[level].max_lazy;
                good_match = config_table[level].good_length;
                nice_match = config_table[level].nice_length;
                max_chain_length = config_table[level].max_chain;
            }
            strategy = _strategy;
            return err;
        };
        that.deflateSetDictionary = function(strm, dictionary, dictLength) {
            var length = dictLength;
            var n, index = 0;
            if (!dictionary || status != INIT_STATE)
                return Z_STREAM_ERROR;
            if (length < MIN_MATCH)
                return Z_OK;
            if (length > w_size - MIN_LOOKAHEAD) {
                length = w_size - MIN_LOOKAHEAD;
                index = dictLength - length;
            }
            window.set(dictionary.subarray(index, index + length), 0);
            strstart = length;
            block_start = length;
            ins_h = window[0] & 0xff;
            ins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;
            for (n = 0; n <= length - MIN_MATCH; n++) {
                ins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
                prev[n & w_mask] = head[ins_h];
                head[ins_h] = n;
            }
            return Z_OK;
        };
        that.deflate = function(_strm, flush) {
            var i, header, level_flags, old_flush, bstate;
            if (flush > Z_FINISH || flush < 0) {
                return Z_STREAM_ERROR;
            }
            if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {
                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];
                return Z_STREAM_ERROR;
            }
            if (_strm.avail_out === 0) {
                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
                return Z_BUF_ERROR;
            }
            strm = _strm;
            old_flush = last_flush;
            last_flush = flush;
            if (status == INIT_STATE) {
                header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
                level_flags = ((level - 1) & 0xff) >> 1;
                if (level_flags > 3)
                    level_flags = 3;
                header |= (level_flags << 6);
                if (strstart !== 0)
                    header |= PRESET_DICT;
                header += 31 - (header % 31);
                status = BUSY_STATE;
                putShortMSB(header);
            }
            if (that.pending !== 0) {
                strm.flush_pending();
                if (strm.avail_out === 0) {
                    last_flush = -1;
                    return Z_OK;
                }
            } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
                strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
                return Z_BUF_ERROR;
            }
            if (status == FINISH_STATE && strm.avail_in !== 0) {
                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
                return Z_BUF_ERROR;
            }
            if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {
                bstate = -1;
                switch (config_table[level].func) {
                    case STORED:
                        bstate = deflate_stored(flush);
                        break;
                    case FAST:
                        bstate = deflate_fast(flush);
                        break;
                    case SLOW:
                        bstate = deflate_slow(flush);
                        break;
                    default:
                }
                if (bstate == FinishStarted || bstate == FinishDone) {
                    status = FINISH_STATE;
                }
                if (bstate == NeedMore || bstate == FinishStarted) {
                    if (strm.avail_out === 0) {
                        last_flush = -1;
                    }
                    return Z_OK;
                }
                if (bstate == BlockDone) {
                    if (flush == Z_PARTIAL_FLUSH) {
                        _tr_align();
                    } else {
                        _tr_stored_block(0, 0, false);
                        if (flush == Z_FULL_FLUSH) {
                            for (i = 0; i < hash_size; i++)
                                head[i] = 0;
                        }
                    }
                    strm.flush_pending();
                    if (strm.avail_out === 0) {
                        last_flush = -1;
                        return Z_OK;
                    }
                }
            }
            if (flush != Z_FINISH)
                return Z_OK;
            return Z_STREAM_END;
        };
    }

    function ZStream() {
        var that = this;
        that.next_in_index = 0;
        that.next_out_index = 0;
        that.avail_in = 0;
        that.total_in = 0;
        that.avail_out = 0;
        that.total_out = 0;
    }
    ZStream.prototype = {
        deflateInit: function(level, bits) {
            var that = this;
            that.dstate = new Deflate();
            if (!bits)
                bits = MAX_BITS;
            return that.dstate.deflateInit(that, level, bits);
        },
        deflate: function(flush) {
            var that = this;
            if (!that.dstate) {
                return Z_STREAM_ERROR;
            }
            return that.dstate.deflate(that, flush);
        },
        deflateEnd: function() {
            var that = this;
            if (!that.dstate)
                return Z_STREAM_ERROR;
            var ret = that.dstate.deflateEnd();
            that.dstate = null;
            return ret;
        },
        deflateParams: function(level, strategy) {
            var that = this;
            if (!that.dstate)
                return Z_STREAM_ERROR;
            return that.dstate.deflateParams(that, level, strategy);
        },
        deflateSetDictionary: function(dictionary, dictLength) {
            var that = this;
            if (!that.dstate)
                return Z_STREAM_ERROR;
            return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
        },
        read_buf: function(buf, start, size) {
            var that = this;
            var len = that.avail_in;
            if (len > size)
                len = size;
            if (len === 0)
                return 0;
            that.avail_in -= len;
            buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
            that.next_in_index += len;
            that.total_in += len;
            return len;
        },
        flush_pending: function() {
            var that = this;
            var len = that.dstate.pending;
            if (len > that.avail_out)
                len = that.avail_out;
            if (len === 0)
                return;
            that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
            that.next_out_index += len;
            that.dstate.pending_out += len;
            that.total_out += len;
            that.avail_out -= len;
            that.dstate.pending -= len;
            if (that.dstate.pending === 0) {
                that.dstate.pending_out = 0;
            }
        }
    };
    return function Deflater(level) {
        var that = this;
        var z = new ZStream();
        var bufsize = 512;
        var flush = Z_NO_FLUSH;
        var buf = new Uint8Array(bufsize);
        if (typeof level == "undefined")
            level = Z_DEFAULT_COMPRESSION;
        z.deflateInit(level);
        z.next_out = buf;
        that.append = function(data, onprogress) {
            var err, buffers = [],
                lastIndex = 0,
                bufferIndex = 0,
                bufferSize = 0,
                array;
            if (!data.length)
                return;
            z.next_in_index = 0;
            z.next_in = data;
            z.avail_in = data.length;
            do {
                z.next_out_index = 0;
                z.avail_out = bufsize;
                err = z.deflate(flush);
                if (err != Z_OK)
                    throw "deflating: " + z.msg;
                if (z.next_out_index)
                    if (z.next_out_index == bufsize)
                        buffers.push(new Uint8Array(buf));
                    else
                        buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));
                bufferSize += z.next_out_index;
                if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                    onprogress(z.next_in_index);
                    lastIndex = z.next_in_index;
                }
            } while (z.avail_in > 0 || z.avail_out === 0);
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
            return array;
        };
        that.flush = function() {
            var err, buffers = [],
                bufferIndex = 0,
                bufferSize = 0,
                array;
            do {
                z.next_out_index = 0;
                z.avail_out = bufsize;
                err = z.deflate(Z_FINISH);
                if (err != Z_STREAM_END && err != Z_OK)
                    throw "deflating: " + z.msg;
                if (bufsize - z.avail_out > 0)
                    buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));
                bufferSize += z.next_out_index;
            } while (z.avail_in > 0 || z.avail_out === 0);
            z.deflateEnd();
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
            return array;
        };
    };
})(this);
(function(global) {
    var PNG;
    PNG = (function() {
        var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;
        PNG.load = function(url, canvas, callback) {
            var xhr, _this = this;
            if (typeof canvas === 'function') {
                callback = canvas;
            }
            xhr = new XMLHttpRequest;
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function() {
                var data, png;
                data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                png = new PNG(data);
                if (typeof(canvas != null ? canvas.getContext : void 0) === 'function') {
                    png.render(canvas);
                }
                return typeof callback === "function" ? callback(png) : void 0;
            };
            return xhr.send(null);
        };
        APNG_DISPOSE_OP_NONE = 0;
        APNG_DISPOSE_OP_BACKGROUND = 1;
        APNG_DISPOSE_OP_PREVIOUS = 2;
        APNG_BLEND_OP_SOURCE = 0;
        APNG_BLEND_OP_OVER = 1;

        function PNG(data) {
            var chunkSize, colors, palLen, delayDen, delayNum, frame, i, index, key, section, palShort, text, _i, _j, _ref;
            this.data = data;
            this.pos = 8;
            this.palette = [];
            this.imgData = [];
            this.transparency = {};
            this.animation = null;
            this.text = {};
            frame = null;
            while (true) {
                chunkSize = this.readUInt32();
                section = ((function() {
                    var _i, _results;
                    _results = [];
                    for (i = _i = 0; _i < 4; i = ++_i) {
                        _results.push(String.fromCharCode(this.data[this.pos++]));
                    }
                    return _results;
                }).call(this)).join('');
                switch (section) {
                    case 'IHDR':
                        this.width = this.readUInt32();
                        this.height = this.readUInt32();
                        this.bits = this.data[this.pos++];
                        this.colorType = this.data[this.pos++];
                        this.compressionMethod = this.data[this.pos++];
                        this.filterMethod = this.data[this.pos++];
                        this.interlaceMethod = this.data[this.pos++];
                        break;
                    case 'acTL':
                        this.animation = {
                            numFrames: this.readUInt32(),
                            numPlays: this.readUInt32() || Infinity,
                            frames: []
                        };
                        break;
                    case 'PLTE':
                        this.palette = this.read(chunkSize);
                        break;
                    case 'fcTL':
                        if (frame) {
                            this.animation.frames.push(frame);
                        }
                        this.pos += 4;
                        frame = {
                            width: this.readUInt32(),
                            height: this.readUInt32(),
                            xOffset: this.readUInt32(),
                            yOffset: this.readUInt32()
                        };
                        delayNum = this.readUInt16();
                        delayDen = this.readUInt16() || 100;
                        frame.delay = 1000 * delayNum / delayDen;
                        frame.disposeOp = this.data[this.pos++];
                        frame.blendOp = this.data[this.pos++];
                        frame.data = [];
                        break;
                    case 'IDAT':
                    case 'fdAT':
                        if (section === 'fdAT') {
                            this.pos += 4;
                            chunkSize -= 4;
                        }
                        data = (frame != null ? frame.data : void 0) || this.imgData;
                        for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
                            data.push(this.data[this.pos++]);
                        }
                        break;
                    case 'tRNS':
                        this.transparency = {};
                        switch (this.colorType) {
                            case 3:
                                palLen = this.palette.length / 3;
                                this.transparency.indexed = this.read(chunkSize);
                                if (this.transparency.indexed.length > palLen)
                                    throw new Error('More transparent colors than palette size');
                                palShort = palLen - this.transparency.indexed.length;
                                if (palShort > 0) {
                                    for (i = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i = 0 <= palShort ? ++_j : --_j) {
                                        this.transparency.indexed.push(255);
                                    }
                                }
                                break;
                            case 0:
                                this.transparency.grayscale = this.read(chunkSize)[0];
                                break;
                            case 2:
                                this.transparency.rgb = this.read(chunkSize);
                        }
                        break;
                    case 'tEXt':
                        text = this.read(chunkSize);
                        index = text.indexOf(0);
                        key = String.fromCharCode.apply(String, text.slice(0, index));
                        this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                        break;
                    case 'IEND':
                        if (frame) {
                            this.animation.frames.push(frame);
                        }
                        this.colors = (function() {
                            switch (this.colorType) {
                                case 0:
                                case 3:
                                case 4:
                                    return 1;
                                case 2:
                                case 6:
                                    return 3;
                            }
                        }).call(this);
                        this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
                        colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                        this.pixelBitlength = this.bits * colors;
                        this.colorSpace = (function() {
                            switch (this.colors) {
                                case 1:
                                    return 'DeviceGray';
                                case 3:
                                    return 'DeviceRGB';
                            }
                        }).call(this);
                        this.imgData = new Uint8Array(this.imgData);
                        return;
                    default:
                        this.pos += chunkSize;
                }
                this.pos += 4;
                if (this.pos > this.data.length) {
                    throw new Error("Incomplete or corrupt PNG file");
                }
            }
            return;
        }
        PNG.prototype.read = function(bytes) {
            var i, _i, _results;
            _results = [];
            for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                _results.push(this.data[this.pos++]);
            }
            return _results;
        };
        PNG.prototype.readUInt32 = function() {
            var b1, b2, b3, b4;
            b1 = this.data[this.pos++] << 24;
            b2 = this.data[this.pos++] << 16;
            b3 = this.data[this.pos++] << 8;
            b4 = this.data[this.pos++];
            return b1 | b2 | b3 | b4;
        };
        PNG.prototype.readUInt16 = function() {
            var b1, b2;
            b1 = this.data[this.pos++] << 8;
            b2 = this.data[this.pos++];
            return b1 | b2;
        };
        PNG.prototype.decodePixels = function(data) {
            var abyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
            if (data == null) {
                data = this.imgData;
            }
            if (data.length === 0) {
                return new Uint8Array(0);
            }
            data = new FlateStream(data);
            data = data.getBytes();
            pixelBytes = this.pixelBitlength / 8;
            scanlineLength = pixelBytes * this.width;
            pixels = new Uint8Array(scanlineLength * this.height);
            length = data.length;
            row = 0;
            pos = 0;
            c = 0;
            while (pos < length) {
                switch (data[pos++]) {
                    case 0:
                        for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                            pixels[c++] = data[pos++];
                        }
                        break;
                    case 1:
                        for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                            abyte = data[pos++];
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            pixels[c++] = (abyte + left) % 256;
                        }
                        break;
                    case 2:
                        for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                            pixels[c++] = (upper + abyte) % 256;
                        }
                        break;
                    case 3:
                        for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                            pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;
                        }
                        break;
                    case 4:
                        for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            if (row === 0) {
                                upper = upperLeft = 0;
                            } else {
                                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];
                            }
                            p = left + upper - upperLeft;
                            pa = Math.abs(p - left);
                            pb = Math.abs(p - upper);
                            pc = Math.abs(p - upperLeft);
                            if (pa <= pb && pa <= pc) {
                                paeth = left;
                            } else if (pb <= pc) {
                                paeth = upper;
                            } else {
                                paeth = upperLeft;
                            }
                            pixels[c++] = (abyte + paeth) % 256;
                        }
                        break;
                    default:
                        throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                }
                row++;
            }
            return pixels;
        };
        PNG.prototype.decodePalette = function() {
            var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
            palette = this.palette;
            transparency = this.transparency.indexed || [];
            ret = new Uint8Array((transparency.length || 0) + palette.length);
            pos = 0;
            length = palette.length;
            c = 0;
            for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                ret[pos++] = palette[i];
                ret[pos++] = palette[i + 1];
                ret[pos++] = palette[i + 2];
                ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;
            }
            return ret;
        };
        PNG.prototype.copyToImageData = function(imageData, pixels) {
            var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
            colors = this.colors;
            palette = null;
            alpha = this.hasAlphaChannel;
            if (this.palette.length) {
                palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
                colors = 4;
                alpha = true;
            }
            data = imageData.data || imageData;
            length = data.length;
            input = palette || pixels;
            i = j = 0;
            if (colors === 1) {
                while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    v = input[k++];
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                }
            } else {
                while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                }
            }
        };
        PNG.prototype.decode = function() {
            var ret;
            ret = new Uint8Array(this.width * this.height * 4);
            this.copyToImageData(ret, this.decodePixels());
            return ret;
        };
        try {
            scratchCanvas = global.document.createElement('canvas');
            scratchCtx = scratchCanvas.getContext('2d');
        } catch (e) {
            return -1;
        }
        makeImage = function(imageData) {
            var img;
            scratchCtx.width = imageData.width;
            scratchCtx.height = imageData.height;
            scratchCtx.clearRect(0, 0, imageData.width, imageData.height);
            scratchCtx.putImageData(imageData, 0, 0);
            img = new Image;
            img.src = scratchCanvas.toDataURL();
            return img;
        };
        PNG.prototype.decodeFrames = function(ctx) {
            var frame, i, imageData, pixels, _i, _len, _ref, _results;
            if (!this.animation) {
                return;
            }
            _ref = this.animation.frames;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                frame = _ref[i];
                imageData = ctx.createImageData(frame.width, frame.height);
                pixels = this.decodePixels(new Uint8Array(frame.data));
                this.copyToImageData(imageData, pixels);
                frame.imageData = imageData;
                _results.push(frame.image = makeImage(imageData));
            }
            return _results;
        };
        PNG.prototype.renderFrame = function(ctx, number) {
            var frame, frames, prev;
            frames = this.animation.frames;
            frame = frames[number];
            prev = frames[number - 1];
            if (number === 0) {
                ctx.clearRect(0, 0, this.width, this.height);
            }
            if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {
                ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);
            } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {
                ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);
            }
            if (frame.blendOp === APNG_BLEND_OP_SOURCE) {
                ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);
            }
            return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);
        };
        PNG.prototype.animate = function(ctx) {
            var doFrame, frameNumber, frames, numFrames, numPlays, _ref, _this = this;
            frameNumber = 0;
            _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;
            return (doFrame = function() {
                var f, frame;
                f = frameNumber++ % numFrames;
                frame = frames[f];
                _this.renderFrame(ctx, f);
                if (numFrames > 1 && frameNumber / numFrames < numPlays) {
                    return _this.animation._timeout = setTimeout(doFrame, frame.delay);
                }
            })();
        };
        PNG.prototype.stopAnimation = function() {
            var _ref;
            return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);
        };
        PNG.prototype.render = function(canvas) {
            var ctx, data;
            if (canvas._png) {
                canvas._png.stopAnimation();
            }
            canvas._png = this;
            canvas.width = this.width;
            canvas.height = this.height;
            ctx = canvas.getContext("2d");
            if (this.animation) {
                this.decodeFrames(ctx);
                return this.animate(ctx);
            } else {
                data = ctx.createImageData(this.width, this.height);
                this.copyToImageData(data, this.decodePixels());
                return ctx.putImageData(data, 0, 0);
            }
        };
        return PNG;
    })();
    global.PNG = PNG;
})(typeof window !== "undefined" && window || this);
var DecodeStream = (function() {
    function constructor() {
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = false;
        this.buffer = null;
    }
    constructor.prototype = {
        ensureBuffer: function decodestream_ensureBuffer(requested) {
            var buffer = this.buffer;
            var current = buffer ? buffer.byteLength : 0;
            if (requested < current)
                return buffer;
            var size = 512;
            while (size < requested)
                size <<= 1;
            var buffer2 = new Uint8Array(size);
            for (var i = 0; i < current; ++i)
                buffer2[i] = buffer[i];
            return this.buffer = buffer2;
        },
        getByte: function decodestream_getByte() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return this.buffer[this.pos++];
        },
        getBytes: function decodestream_getBytes(length) {
            var pos = this.pos;
            if (length) {
                this.ensureBuffer(pos + length);
                var end = pos + length;
                while (!this.eof && this.bufferLength < end)
                    this.readBlock();
                var bufEnd = this.bufferLength;
                if (end > bufEnd)
                    end = bufEnd;
            } else {
                while (!this.eof)
                    this.readBlock();
                var end = this.bufferLength;
            }
            this.pos = end;
            return this.buffer.subarray(pos, end);
        },
        lookChar: function decodestream_lookChar() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos]);
        },
        getChar: function decodestream_getChar() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos++]);
        },
        makeSubStream: function decodestream_makeSubstream(start, length, dict) {
            var end = start + length;
            while (this.bufferLength <= end && !this.eof)
                this.readBlock();
            return new Stream(this.buffer, start, length, dict);
        },
        skip: function decodestream_skip(n) {
            if (!n)
                n = 1;
            this.pos += n;
        },
        reset: function decodestream_reset() {
            this.pos = 0;
        }
    };
    return constructor;
})();
var FlateStream = (function() {
    if (typeof Uint32Array === 'undefined') {
        return undefined;
    }
    var codeLenCodeMap = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var lengthDecode = new Uint32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
    var distDecode = new Uint32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
    var fixedLitCodeTab = [new Uint32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
    var fixedDistCodeTab = [new Uint32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];

    function error(e) {
        throw new Error(e)
    }

    function constructor(bytes) {
        var bytesPos = 0;
        var cmf = bytes[bytesPos++];
        var flg = bytes[bytesPos++];
        if (cmf == -1 || flg == -1)
            error('Invalid header in flate stream');
        if ((cmf & 0x0f) != 0x08)
            error('Unknown compression method in flate stream');
        if ((((cmf << 8) + flg) % 31) != 0)
            error('Bad FCHECK in flate stream');
        if (flg & 0x20)
            error('FDICT bit set in flate stream');
        this.bytes = bytes;
        this.bytesPos = bytesPos;
        this.codeSize = 0;
        this.codeBuf = 0;
        DecodeStream.call(this);
    }
    constructor.prototype = Object.create(DecodeStream.prototype);
    constructor.prototype.getBits = function(bits) {
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var bytes = this.bytes;
        var bytesPos = this.bytesPos;
        var b;
        while (codeSize < bits) {
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad encoding in flate stream');
            codeBuf |= b << codeSize;
            codeSize += 8;
        }
        b = codeBuf & ((1 << bits) - 1);
        this.codeBuf = codeBuf >> bits;
        this.codeSize = codeSize -= bits;
        this.bytesPos = bytesPos;
        return b;
    };
    constructor.prototype.getCode = function(table) {
        var codes = table[0];
        var maxLen = table[1];
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var bytes = this.bytes;
        var bytesPos = this.bytesPos;
        while (codeSize < maxLen) {
            var b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad encoding in flate stream');
            codeBuf |= (b << codeSize);
            codeSize += 8;
        }
        var code = codes[codeBuf & ((1 << maxLen) - 1)];
        var codeLen = code >> 16;
        var codeVal = code & 0xffff;
        if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
            error('Bad encoding in flate stream');
        this.codeBuf = (codeBuf >> codeLen);
        this.codeSize = (codeSize - codeLen);
        this.bytesPos = bytesPos;
        return codeVal;
    };
    constructor.prototype.generateHuffmanTable = function(lengths) {
        var n = lengths.length;
        var maxLen = 0;
        for (var i = 0; i < n; ++i) {
            if (lengths[i] > maxLen)
                maxLen = lengths[i];
        }
        var size = 1 << maxLen;
        var codes = new Uint32Array(size);
        for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
            for (var val = 0; val < n; ++val) {
                if (lengths[val] == len) {
                    var code2 = 0;
                    var t = code;
                    for (var i = 0; i < len; ++i) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (var i = code2; i < size; i += skip)
                        codes[i] = (len << 16) | val;
                    ++code;
                }
            }
        }
        return [codes, maxLen];
    };
    constructor.prototype.readBlock = function() {
        function repeat(stream, array, len, offset, what) {
            var repeat = stream.getBits(len) + offset;
            while (repeat-- > 0)
                array[i++] = what;
        }
        var hdr = this.getBits(3);
        if (hdr & 1)
            this.eof = true;
        hdr >>= 1;
        if (hdr == 0) {
            var bytes = this.bytes;
            var bytesPos = this.bytesPos;
            var b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            var blockLen = b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            blockLen |= (b << 8);
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            var check = b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            check |= (b << 8);
            if (check != (~blockLen & 0xffff))
                error('Bad uncompressed block length in flate stream');
            this.codeBuf = 0;
            this.codeSize = 0;
            var bufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(bufferLength + blockLen);
            var end = bufferLength + blockLen;
            this.bufferLength = end;
            for (var n = bufferLength; n < end; ++n) {
                if (typeof(b = bytes[bytesPos++]) == 'undefined') {
                    this.eof = true;
                    break;
                }
                buffer[n] = b;
            }
            this.bytesPos = bytesPos;
            return;
        }
        var litCodeTable;
        var distCodeTable;
        if (hdr == 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
        } else if (hdr == 2) {
            var numLitCodes = this.getBits(5) + 257;
            var numDistCodes = this.getBits(5) + 1;
            var numCodeLenCodes = this.getBits(4) + 4;
            var codeLenCodeLengths = Array(codeLenCodeMap.length);
            var i = 0;
            while (i < numCodeLenCodes)
                codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);
            var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            var len = 0;
            var i = 0;
            var codes = numLitCodes + numDistCodes;
            var codeLengths = new Array(codes);
            while (i < codes) {
                var code = this.getCode(codeLenCodeTab);
                if (code == 16) {
                    repeat(this, codeLengths, 2, 3, len);
                } else if (code == 17) {
                    repeat(this, codeLengths, 3, 3, len = 0);
                } else if (code == 18) {
                    repeat(this, codeLengths, 7, 11, len = 0);
                } else {
                    codeLengths[i++] = len = code;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));
        } else {
            error('Unknown block type in flate stream');
        }
        var buffer = this.buffer;
        var limit = buffer ? buffer.length : 0;
        var pos = this.bufferLength;
        while (true) {
            var code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (pos + 1 >= limit) {
                    buffer = this.ensureBuffer(pos + 1);
                    limit = buffer.length;
                }
                buffer[pos++] = code1;
                continue;
            }
            if (code1 == 256) {
                this.bufferLength = pos;
                return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1];
            var code2 = code1 >> 16;
            if (code2 > 0)
                code2 = this.getBits(code2);
            var len = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0)
                code2 = this.getBits(code2);
            var dist = (code1 & 0xffff) + code2;
            if (pos + len >= limit) {
                buffer = this.ensureBuffer(pos + len);
                limit = buffer.length;
            }
            for (var k = 0; k < len; ++k, ++pos)
                buffer[pos] = buffer[pos - dist];
        }
    };
    return constructor;
})();
(function(global) {
    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    if (typeof global.btoa === 'undefined') {
        global.btoa = function(data) {
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];
            if (!data) {
                return data;
            }
            do {
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);
                bits = o1 << 16 | o2 << 8 | o3;
                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);
            enc = tmp_arr.join('');
            var r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
        };
    }
    if (typeof global.atob === 'undefined') {
        global.atob = function(data) {
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                dec = '',
                tmp_arr = [];
            if (!data) {
                return data;
            }
            data += '';
            do {
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));
                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;
                if (h3 == 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 == 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);
            dec = tmp_arr.join('');
            return dec;
        };
    }
    if (!Array.prototype.map) {
        Array.prototype.map = function(fun) {
            if (this === void 0 || this === null || typeof fun !== "function")
                throw new TypeError();
            var t = Object(this),
                len = t.length >>> 0,
                res = new Array(len);
            var thisArg = arguments.length > 1 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t)
                    res[i] = fun.call(thisArg, t[i], i, t);
            }
            return res;
        };
    }
    if (!Array.isArray) {
        Array.isArray = function(arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
        };
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun, thisArg) {
            "use strict";
            if (this === void 0 || this === null || typeof fun !== "function")
                throw new TypeError();
            var t = Object(this),
                len = t.length >>> 0;
            for (var i = 0; i < len; i++) {
                if (i in t)
                    fun.call(thisArg, t[i], i, t);
            }
        };
    }
    if (!Object.keys) {
        Object.keys = (function() {
            'use strict';
            var hasOwnProperty = Object.prototype.hasOwnProperty,
                hasDontEnumBug = !({
                    toString: null
                }).propertyIsEnumerable('toString'),
                dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
                dontEnumsLength = dontEnums.length;
            return function(obj) {
                if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                    throw new TypeError();
                }
                var result = [],
                    prop, i;
                for (prop in obj) {
                    if (hasOwnProperty.call(obj, prop)) {
                        result.push(prop);
                    }
                }
                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnumsLength; i++) {
                        if (hasOwnProperty.call(obj, dontEnums[i])) {
                            result.push(dontEnums[i]);
                        }
                    }
                }
                return result;
            };
        }());
    }
    if (!String.prototype.trim) {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, '');
        };
    }
    if (!String.prototype.trimLeft) {
        String.prototype.trimLeft = function() {
            return this.replace(/^\s+/g, "");
        };
    }
    if (!String.prototype.trimRight) {
        String.prototype.trimRight = function() {
            return this.replace(/\s+$/g, "");
        };
    }
})(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this);; /*!autotrack.js v1.1.0*/
! function t(e, i, n) {
    function s(o, a) {
        if (!i[o]) {
            if (!e[o]) {
                var l = "function" == typeof require && require;
                if (!a && l) return l(o, !0);
                if (r) return r(o, !0);
                var h = new Error("Cannot find module '" + o + "'");
                throw h.code = "MODULE_NOT_FOUND", h
            }
            var c = i[o] = {
                exports: {}
            };
            e[o][0].call(c.exports, function(t) {
                var i = e[o][1][t];
                return s(i ? i : t)
            }, c, c.exports, t, e, i, n)
        }
        return i[o].exports
    }
    for (var r = "function" == typeof require && require, o = 0; o < n.length; o++) s(n[o]);
    return s
}({
    1: [function(t, e, i) {
        e.exports = {
            VERSION: "1.0.0",
            DEV_ID: "i5iSjo",
            VERSION_PARAM: "&_av",
            USAGE_PARAM: "&_au",
            NULL_DIMENSION: "(not set)"
        }
    }, {}],
    2: [function(t, e, i) {
        function n() {
            console.error("Warning! Requiring the `autotrack` plugin no longer requires  all sub-plugins by default.\nSee https://goo.gl/XsXPg5 for details.")
        }
        var s = t("../provide");
        s("autotrack", n)
    }, {
        "../provide": 12
    }],
    3: [function(t, e, i) {
        function n(t, e) {
            l.track(t, l.plugins.CLEAN_URL_TRACKER), this.opts = s({
                stripQuery: !1,
                queryDimensionIndex: null,
                indexFilename: null,
                trailingSlash: null
            }, e), this.tracker = t, this.overrideTrackerBuildHitTask()
        }
        var s = t("object-assign"),
            r = t("dom-utils/lib/parse-url"),
            o = t("../constants"),
            a = t("../provide"),
            l = t("../usage");
        n.prototype.cleanUrlTask = function(t) {
            var e = t.get("location"),
                i = t.get("page"),
                n = r(i || e),
                s = n.pathname,
                a = s;
            if (this.opts.indexFilename) {
                var l = a.split("/");
                this.opts.indexFilename == l[l.length - 1] && (l[l.length - 1] = "", a = l.join("/"))
            }
            if ("remove" == this.opts.trailingSlash) a = a.replace(/\/+$/, "");
            else if ("add" == this.opts.trailingSlash) {
                var h = /\.\w+$/.test(a);
                h || "/" == a.substr(-1) || (a += "/")
            }
            this.opts.stripQuery && this.opts.queryDimensionIndex && t.set("dimension" + this.opts.queryDimensionIndex, n.query || o.NULL_DIMENSION), t.set("page", a + (this.opts.stripQuery ? "" : n.search))
        }, n.prototype.overrideTrackerBuildHitTask = function() {
            this.originalTrackerBuildHitTask = this.tracker.get("buildHitTask"), this.tracker.set("buildHitTask", function(t) {
                this.cleanUrlTask(t), this.originalTrackerBuildHitTask(t)
            }.bind(this))
        }, n.prototype.remove = function() {
            this.tracker.set("sendHitTask", this.originalTrackerSendHitTask)
        }, a("cleanUrlTracker", n)
    }, {
        "../constants": 1,
        "../provide": 12,
        "../usage": 13,
        "dom-utils/lib/parse-url": 22,
        "object-assign": 23
    }],
    4: [function(t, e, i) {
        function n(t, e) {
            if (a.track(t, a.plugins.EVENT_TRACKER), window.addEventListener) {
                this.opts = s({
                    events: ["click"],
                    fieldsObj: {},
                    attributePrefix: "ga-",
                    hitFilter: null
                }, e), this.tracker = t, this.handleEvents = this.handleEvents.bind(this);
                var i = "[" + this.opts.attributePrefix + "on]";
                this.delegates = {}, this.opts.events.forEach(function(t) {
                    this.delegates[t] = r(document, t, i, this.handleEvents, {
                        composed: !0,
                        useCapture: !0
                    })
                }.bind(this))
            }
        }
        var s = t("object-assign"),
            r = t("dom-utils/lib/delegate"),
            o = t("../provide"),
            a = t("../usage"),
            l = t("../utilities").createFieldsObj,
            h = t("../utilities").getAttributeFields;
        n.prototype.handleEvents = function(t, e) {
            var i = this.opts.attributePrefix;
            if (t.type == e.getAttribute(i + "on")) {
                var n = {
                        transport: "beacon"
                    },
                    r = h(e, i),
                    o = s({}, this.opts.fieldsObj, r),
                    a = r.hitType || "event";
                this.tracker.send(a, l(n, o, this.tracker, this.opts.hitFilter, e))
            }
        }, n.prototype.remove = function() {
            Object.keys(this.delegates).forEach(function(t) {
                this.delegates[t].destroy()
            }.bind(this))
        }, o("eventTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "dom-utils/lib/delegate": 18,
        "object-assign": 23
    }],
    5: [function(t, e, i) {
        function n(t, e) {
            l.track(t, l.plugins.IMPRESSION_TRACKER), window.IntersectionObserver && window.MutationObserver && (this.opts = o({
                elements: null,
                rootMargin: "0px",
                fieldsObj: {},
                attributePrefix: "ga-",
                hitFilter: null
            }, e), this.tracker = t, this.handleDomMutations = this.handleDomMutations.bind(this), this.handleIntersectionChanges = this.handleIntersectionChanges.bind(this), this.handleDomElementAdded = this.handleDomElementAdded.bind(this), this.handleDomElementRemoved = this.handleDomElementRemoved.bind(this), this.items = [], this.elementMap = {}, this.thresholdMap = {}, c(function() {
                this.observeElements(this.opts.elements)
            }.bind(this)))
        }

        function s(t, e) {
            if (0 === t) {
                var i = e.intersectionRect;
                return i.top > 0 || i.bottom > 0 || i.left > 0 || i.right > 0
            }
            return e.intersectionRatio >= t
        }

        function r(t) {
            return o({
                threshold: 0,
                trackFirstImpressionOnly: !0
            }, "string" == typeof t ? {
                id: t
            } : t)
        }
        var o = t("object-assign"),
            a = t("../provide"),
            l = t("../usage"),
            h = t("../utilities").createFieldsObj,
            c = t("../utilities").domReady,
            d = t("../utilities").getAttributeFields;
        n.prototype.observeElements = function(t) {
            var e = this.deriveDataFromElements(t);
            this.items = this.items.concat(e.items), this.elementMap = o({}, e.elementMap, this.elementMap), this.thresholdMap = o({}, e.thresholdMap, this.thresholdMap), e.items.forEach(function(t) {
                var e = this.thresholdMap[t.threshold] = this.thresholdMap[t.threshold] || new IntersectionObserver(this.handleIntersectionChanges, {
                        rootMargin: this.opts.rootMargin,
                        threshold: [+t.threshold]
                    }),
                    i = this.elementMap[t.id] || (this.elementMap[t.id] = document.getElementById(t.id));
                i && e.observe(i)
            }.bind(this)), this.mutationObserver || (this.mutationObserver = new MutationObserver(this.handleDomMutations), this.mutationObserver.observe(document.body, {
                childList: !0,
                subtree: !0
            })), requestAnimationFrame(function() {})
        }, n.prototype.unobserveElements = function(t) {
            var e = [],
                i = [];
            if (this.items.forEach(function(n) {
                    var s = t.some(function(t) {
                        var e = r(t);
                        return e.id === n.id && e.threshold === n.threshold && e.trackFirstImpressionOnly === n.trackFirstImpressionOnly
                    });
                    s ? i.push(n) : e.push(n)
                }), !e.length) return this.unobserveAllElements();
            var n = this.deriveDataFromElements(e),
                s = this.deriveDataFromElements(i);
            this.items = n.items, this.elementMap = n.elementMap, this.thresholdMap = n.thresholdMap, i.forEach(function(t) {
                if (!n.elementMap[t.id]) {
                    var e = s.thresholdMap[t.threshold],
                        i = s.elementMap[t.id];
                    i && e.unobserve(i), n.thresholdMap[t.threshold] || s.thresholdMap[t.threshold].disconnect()
                }
            })
        }, n.prototype.unobserveAllElements = function() {
            Object.keys(this.thresholdMap).forEach(function(t) {
                this.thresholdMap[t].disconnect()
            }.bind(this)), this.mutationObserver.disconnect(), this.mutationObserver = null, this.items = [], this.elementMap = {}, this.thresholdMap = {}
        }, n.prototype.deriveDataFromElements = function(t) {
            var e = [],
                i = {},
                n = {};
            return t.length && t.forEach(function(t) {
                var s = r(t);
                e.push(s), n[s.id] = this.elementMap[s.id] || null, i[s.threshold] = this.thresholdMap[s.threshold] || null
            }.bind(this)), {
                items: e,
                elementMap: n,
                thresholdMap: i
            }
        }, n.prototype.observeElement = function(t) {
            var e = this.elementMap[t] || (this.elementMap[t] = document.getElementById(t));
            e && this.intersectionObserver.observe(e)
        }, n.prototype.handleDomMutations = function(t) {
            for (var e, i = 0; e = t[i]; i++) {
                for (var n, s = 0; n = e.removedNodes[s]; s++) this.walkNodeTree(n, this.handleDomElementRemoved);
                for (var r, o = 0; r = e.addedNodes[o]; o++) this.walkNodeTree(r, this.handleDomElementAdded)
            }
        }, n.prototype.walkNodeTree = function(t, e) {
            1 == t.nodeType && t.id in this.elementMap && e(t.id);
            for (var i, n = 0; i = t.childNodes[n]; n++) this.walkNodeTree(i, e)
        }, n.prototype.handleIntersectionChanges = function(t) {
            for (var e, i = [], n = 0; e = t[n]; n++)
                for (var r, o = 0; r = this.items[o]; o++) e.target.id === r.id && s(r.threshold, e) && (this.handleImpression(r.id), r.trackFirstImpressionOnly && i.push(r));
            i.length && this.unobserveElements(i)
        }, n.prototype.handleImpression = function(t) {
            var e = document.getElementById(t),
                i = {
                    transport: "beacon",
                    eventCategory: "Viewport",
                    eventAction: "impression",
                    eventLabel: t
                },
                n = o({}, this.opts.fieldsObj, d(e, this.opts.attributePrefix));
            this.tracker.send("event", h(i, n, this.tracker, this.opts.hitFilter, e))
        }, n.prototype.handleDomElementAdded = function(t) {
            var e = this.elementMap[t] = document.getElementById(t);
            this.items.forEach(function(i) {
                t == i.id && this.thresholdMap[i.threshold].observe(e)
            }.bind(this))
        }, n.prototype.handleDomElementRemoved = function(t) {
            var e = this.elementMap[t];
            this.items.forEach(function(i) {
                t == i.id && this.thresholdMap[i.threshold].unobserve(e)
            }.bind(this)), this.elementMap[t] = null
        }, n.prototype.remove = function() {
            this.unobserveAllElements()
        }, a("impressionTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "object-assign": 23
    }],
    6: [function(t, e, i) {
        function n(t, e) {
            h.track(t, h.plugins.MEDIA_QUERY_TRACKER), window.matchMedia && (this.opts = r({
                definitions: null,
                changeTemplate: this.changeTemplate,
                changeTimeout: 1e3,
                fieldsObj: {},
                hitFilter: null
            }, e), d(this.opts.definitions) && (this.opts.definitions = u(this.opts.definitions), this.tracker = t, this.changeListeners = [], this.processMediaQueries()))
        }

        function s(t) {
            return p[t] ? p[t] : (p[t] = window.matchMedia(t), p[t])
        }
        var r = t("object-assign"),
            o = t("debounce"),
            a = t("../constants"),
            l = t("../provide"),
            h = t("../usage"),
            c = t("../utilities").createFieldsObj,
            d = t("../utilities").isObject,
            u = t("../utilities").toArray,
            p = {};
        n.prototype.processMediaQueries = function() {
            this.opts.definitions.forEach(function(t) {
                if (t.name && t.dimensionIndex) {
                    var e = this.getMatchName(t);
                    this.tracker.set("dimension" + t.dimensionIndex, e), this.addChangeListeners(t)
                }
            }.bind(this))
        }, n.prototype.getMatchName = function(t) {
            var e;
            return t.items.forEach(function(t) {
                s(t.media).matches && (e = t)
            }), e ? e.name : a.NULL_DIMENSION
        }, n.prototype.addChangeListeners = function(t) {
            t.items.forEach(function(e) {
                var i = s(e.media),
                    n = o(function() {
                        this.handleChanges(t)
                    }.bind(this), this.opts.changeTimeout);
                i.addListener(n), this.changeListeners.push({
                    mql: i,
                    fn: n
                })
            }.bind(this))
        }, n.prototype.handleChanges = function(t) {
            var e = this.getMatchName(t),
                i = this.tracker.get("dimension" + t.dimensionIndex);
            if (e !== i) {
                this.tracker.set("dimension" + t.dimensionIndex, e);
                var n = {
                    eventCategory: t.name,
                    eventAction: "change",
                    eventLabel: this.opts.changeTemplate(i, e)
                };
                this.tracker.send("event", c(n, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
            }
        }, n.prototype.remove = function() {
            for (var t, e = 0; t = this.changeListeners[e]; e++) t.mql.removeListener(t.fn)
        }, n.prototype.changeTemplate = function(t, e) {
            return t + " => " + e
        }, l("mediaQueryTracker", n)
    }, {
        "../constants": 1,
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        debounce: 16,
        "object-assign": 23
    }],
    7: [function(t, e, i) {
        function n(t, e) {
            l.track(t, l.plugins.OUTBOUND_FORM_TRACKER), window.addEventListener && (this.opts = s({
                formSelector: "form",
                shouldTrackOutboundForm: this.shouldTrackOutboundForm,
                fieldsObj: {},
                attributePrefix: "ga-",
                hitFilter: null
            }, e), this.tracker = t, this.delegate = r(document, "submit", "form", this.handleFormSubmits.bind(this), {
                composed: !0,
                useCapture: !0
            }))
        }
        var s = t("object-assign"),
            r = t("dom-utils/lib/delegate"),
            o = t("dom-utils/lib/parse-url"),
            a = t("../provide"),
            l = t("../usage"),
            h = t("../utilities").createFieldsObj,
            c = t("../utilities").getAttributeFields,
            d = t("../utilities").withTimeout;
        n.prototype.handleFormSubmits = function(t, e) {
            var i = o(e.action).href,
                n = {
                    transport: "beacon",
                    eventCategory: "Outbound Form",
                    eventAction: "submit",
                    eventLabel: i
                };
            if (this.opts.shouldTrackOutboundForm(e, o)) {
                navigator.sendBeacon || (t.preventDefault(), n.hitCallback = d(function() {
                    e.submit()
                }));
                var r = s({}, this.opts.fieldsObj, c(e, this.opts.attributePrefix));
                this.tracker.send("event", h(n, r, this.tracker, this.opts.hitFilter, e))
            }
        }, n.prototype.shouldTrackOutboundForm = function(t, e) {
            var i = e(t.action);
            return i.hostname != location.hostname && "http" == i.protocol.slice(0, 4)
        }, n.prototype.remove = function() {
            this.delegate.destroy()
        }, a("outboundFormTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "dom-utils/lib/delegate": 18,
        "dom-utils/lib/parse-url": 22,
        "object-assign": 23
    }],
    8: [function(t, e, i) {
        function n(t, e) {
            l.track(t, l.plugins.OUTBOUND_LINK_TRACKER), window.addEventListener && (this.opts = s({
                events: ["click"],
                linkSelector: "a, area",
                shouldTrackOutboundLink: this.shouldTrackOutboundLink,
                fieldsObj: {},
                attributePrefix: "ga-",
                hitFilter: null
            }, e), this.tracker = t, this.handleLinkInteractions = this.handleLinkInteractions.bind(this), this.delegates = {}, this.opts.events.forEach(function(t) {
                this.delegates[t] = r(document, t, this.opts.linkSelector, this.handleLinkInteractions, {
                    composed: !0,
                    useCapture: !0
                })
            }.bind(this)))
        }
        var s = t("object-assign"),
            r = t("dom-utils/lib/delegate"),
            o = t("dom-utils/lib/parse-url"),
            a = t("../provide"),
            l = t("../usage"),
            h = t("../utilities").createFieldsObj,
            c = t("../utilities").getAttributeFields;
        n.prototype.handleLinkInteractions = function(t, e) {
            if (this.opts.shouldTrackOutboundLink(e, o)) {
                navigator.sendBeacon || (e.target = "_blank");
                var i = e.getAttribute("href") || e.getAttribute("xlink:href"),
                    n = o(i),
                    r = {
                        transport: "beacon",
                        eventCategory: "Outbound Link",
                        eventAction: t.type,
                        eventLabel: n.href
                    },
                    a = s({}, this.opts.fieldsObj, c(e, this.opts.attributePrefix));
                this.tracker.send("event", h(r, a, this.tracker, this.opts.hitFilter, e))
            }
        }, n.prototype.shouldTrackOutboundLink = function(t, e) {
            var i = t.getAttribute("href") || t.getAttribute("xlink:href"),
                n = e(i);
            return n.hostname != location.hostname && "http" == n.protocol.slice(0, 4)
        }, n.prototype.remove = function() {
            Object.keys(this.delegates).forEach(function(t) {
                this.delegates[t].destroy()
            }.bind(this))
        }, a("outboundLinkTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "dom-utils/lib/delegate": 18,
        "dom-utils/lib/parse-url": 22,
        "object-assign": 23
    }],
    9: [function(t, e, i) {
        function n(t, e) {
            o.track(t, o.plugins.PAGE_VISIBILITY_TRACKER), window.addEventListener && (this.opts = s({
                sessionTimeout: h,
                changeTemplate: this.changeTemplate,
                hiddenMetricIndex: null,
                visibleMetricIndex: null,
                fieldsObj: {},
                hitFilter: null
            }, e), this.tracker = t, this.visibilityState = document.visibilityState, this.lastVisibilityChangeTime = +new Date, this.handleVisibilityStateChange = this.handleVisibilityStateChange.bind(this), this.overrideTrackerSendMethod(), this.overrideTrackerSendHitTask(), document.addEventListener("visibilitychange", this.handleVisibilityStateChange))
        }
        var s = t("object-assign"),
            r = t("../provide"),
            o = t("../usage"),
            a = t("../utilities").createFieldsObj,
            l = t("../utilities").isObject,
            h = 30;
        n.prototype.handleVisibilityStateChange = function() {
            var t;
            if (this.prevVisibilityState = this.visibilityState, this.visibilityState = document.visibilityState, this.sessionHasTimedOut()) {
                if ("hidden" == this.visibilityState) return;
                "visible" == this.visibilityState && (t = {
                    transport: "beacon"
                }, this.tracker.send("pageview", a(t, this.opts.fieldsObj, this.tracker, this.opts.hitFilter)))
            } else {
                var e = Math.round((new Date - this.lastVisibilityChangeTime) / 1e3) || 1;
                t = {
                    transport: "beacon",
                    eventCategory: "Page Visibility",
                    eventAction: "change",
                    eventLabel: this.opts.changeTemplate(this.prevVisibilityState, this.visibilityState),
                    eventValue: e
                }, "hidden" == this.visibilityState && (t.nonInteraction = !0);
                var i = this.opts[this.prevVisibilityState + "MetricIndex"];
                i && (t["metric" + i] = e), this.tracker.send("event", a(t, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
            }
            this.lastVisibilityChangeTime = +new Date
        }, n.prototype.sessionHasTimedOut = function() {
            var t = (new Date - this.lastHitTime) / 6e4;
            return this.opts.sessionTimeout < t
        }, n.prototype.overrideTrackerSendMethod = function() {
            this.originalTrackerSendMethod = this.tracker.send, this.tracker.send = function() {
                var t = Array.prototype.slice.call(arguments),
                    e = t[0],
                    i = l(e) ? e.hitType : e,
                    n = "pageview" == i;
                if (!n && this.sessionHasTimedOut()) {
                    var s = {
                        transport: "beacon"
                    };
                    this.originalTrackerSendMethod.call(this.tracker, "pageview", a(s, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
                }
                this.originalTrackerSendMethod.apply(this.tracker, t)
            }.bind(this)
        }, n.prototype.overrideTrackerSendHitTask = function() {
            this.originalTrackerSendHitTask = this.tracker.get("sendHitTask"), this.lastHitTime = +new Date, this.tracker.set("sendHitTask", function(t) {
                this.originalTrackerSendHitTask(t), this.lastHitTime = +new Date
            }.bind(this))
        }, n.prototype.changeTemplate = function(t, e) {
            return t + " => " + e
        }, n.prototype.remove = function() {
            this.tracker.set("sendHitTask", this.originalTrackerSendHitTask), this.tracker.send = this.originalTrackerSendMethod, document.removeEventListener("visibilitychange", this.handleVisibilityStateChange)
        }, r("pageVisibilityTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "object-assign": 23
    }],
    10: [function(t, e, i) {
        function n(t, e) {
            o.track(t, o.plugins.SOCIAL_WIDGET_TRACKER), window.addEventListener && (this.opts = s({
                fieldsObj: {},
                hitFilter: null
            }, e), this.tracker = t, this.addWidgetListeners = this.addWidgetListeners.bind(this), this.addTwitterEventHandlers = this.addTwitterEventHandlers.bind(this), this.handleTweetEvents = this.handleTweetEvents.bind(this), this.handleFollowEvents = this.handleFollowEvents.bind(this), this.handleLikeEvents = this.handleLikeEvents.bind(this), this.handleUnlikeEvents = this.handleUnlikeEvents.bind(this), "complete" != document.readyState ? window.addEventListener("load", this.addWidgetListeners) : this.addWidgetListeners())
        }
        var s = t("object-assign"),
            r = t("../provide"),
            o = t("../usage"),
            a = t("../utilities").createFieldsObj;
        n.prototype.addWidgetListeners = function() {
            window.FB && this.addFacebookEventHandlers(), window.twttr && this.addTwitterEventHandlers()
        }, n.prototype.addTwitterEventHandlers = function() {
            try {
                twttr.ready(function() {
                    twttr.events.bind("tweet", this.handleTweetEvents), twttr.events.bind("follow", this.handleFollowEvents)
                }.bind(this))
            } catch (t) {}
        }, n.prototype.removeTwitterEventHandlers = function() {
            try {
                twttr.ready(function() {
                    twttr.events.unbind("tweet", this.handleTweetEvents), twttr.events.unbind("follow", this.handleFollowEvents)
                }.bind(this))
            } catch (t) {}
        }, n.prototype.addFacebookEventHandlers = function() {
            try {
                FB.Event.subscribe("edge.create", this.handleLikeEvents), FB.Event.subscribe("edge.remove", this.handleUnlikeEvents)
            } catch (t) {}
        }, n.prototype.removeFacebookEventHandlers = function() {
            try {
                FB.Event.unsubscribe("edge.create", this.handleLikeEvents), FB.Event.unsubscribe("edge.remove", this.handleUnlikeEvents)
            } catch (t) {}
        }, n.prototype.handleTweetEvents = function(t) {
            if ("tweet" == t.region) {
                var e = t.data.url || t.target.getAttribute("data-url") || location.href,
                    i = {
                        transport: "beacon",
                        socialNetwork: "Twitter",
                        socialAction: "tweet",
                        socialTarget: e
                    };
                this.tracker.send("social", a(i, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
            }
        }, n.prototype.handleFollowEvents = function(t) {
            if ("follow" == t.region) {
                var e = t.data.screen_name || t.target.getAttribute("data-screen-name"),
                    i = {
                        transport: "beacon",
                        socialNetwork: "Twitter",
                        socialAction: "follow",
                        socialTarget: e
                    };
                this.tracker.send("social", a(i, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
            }
        }, n.prototype.handleLikeEvents = function(t) {
            var e = {
                transport: "beacon",
                socialNetwork: "Facebook",
                socialAction: "like",
                socialTarget: t
            };
            this.tracker.send("social", a(e, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
        }, n.prototype.handleUnlikeEvents = function(t) {
            var e = {
                transport: "beacon",
                socialNetwork: "Facebook",
                socialAction: "unlike",
                socialTarget: t
            };
            this.tracker.send("social", a(e, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
        }, n.prototype.remove = function() {
            window.removeEventListener("load", this.addWidgetListeners), this.removeFacebookEventHandlers(), this.removeTwitterEventHandlers()
        }, r("socialWidgetTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "object-assign": 23
    }],
    11: [function(t, e, i) {
        function n(t, e) {
            a.track(t, a.plugins.URL_CHANGE_TRACKER), history.pushState && window.addEventListener && (this.opts = r({
                shouldTrackUrlChange: this.shouldTrackUrlChange,
                fieldsObj: {},
                hitFilter: null
            }, e), this.tracker = t, this.path = s(), this.updateTrackerData = this.updateTrackerData.bind(this), this.originalPushState = history.pushState, history.pushState = function(t, e) {
                h(t) && e && (t.title = e), this.originalPushState.apply(history, arguments), this.updateTrackerData()
            }.bind(this), this.originalReplaceState = history.replaceState, history.replaceState = function(t, e) {
                h(t) && e && (t.title = e), this.originalReplaceState.apply(history, arguments), this.updateTrackerData(!1)
            }.bind(this), window.addEventListener("popstate", this.updateTrackerData))
        }

        function s() {
            return location.pathname + location.search
        }
        var r = t("object-assign"),
            o = t("../provide"),
            a = t("../usage"),
            l = t("../utilities").createFieldsObj,
            h = t("../utilities").isObject;
        n.prototype.updateTrackerData = function(t) {
            t = t !== !1, setTimeout(function() {
                var e = this.path,
                    i = s();
                if (e != i && this.opts.shouldTrackUrlChange.call(this, i, e) && (this.path = i, this.tracker.set({
                        page: i,
                        title: h(history.state) && history.state.title || document.title
                    }), t)) {
                    var n = {
                        transport: "beacon"
                    };
                    this.tracker.send("pageview", l(n, this.opts.fieldsObj, this.tracker, this.opts.hitFilter))
                }
            }.bind(this), 0)
        }, n.prototype.shouldTrackUrlChange = function(t, e) {
            return t && e
        }, n.prototype.remove = function() {
            window.removeEventListener("popstate", this.updateTrackerData), history.replaceState = this.originalReplaceState, history.pushState = this.originalPushState, this.tracker = null, this.opts = null, this.path = null, this.updateTrackerData = null, this.originalReplaceState = null, this.originalPushState = null
        }, o("urlChangeTracker", n)
    }, {
        "../provide": 12,
        "../usage": 13,
        "../utilities": 14,
        "object-assign": 23
    }],
    12: [function(t, e, i) {
        var n = t("./constants"),
            s = t("./utilities");
        (window.gaDevIds = window.gaDevIds || []).push(n.DEV_ID), e.exports = function(t, e) {
            var i = window.GoogleAnalyticsObject || "ga";
            window[i] = window[i] || function() {
                (window[i].q = window[i].q || []).push(arguments)
            }, window[i]("provide", t, e), window.gaplugins = window.gaplugins || {}, window.gaplugins[s.capitalize(t)] = e
        }
    }, {
        "./constants": 1,
        "./utilities": 14
    }],
    13: [function(t, e, i) {
        function n(t) {
            return parseInt(t || "0", 16).toString(2)
        }

        function s(t) {
            return parseInt(t || "0", 2).toString(16)
        }

        function r(t, e) {
            if (t.length < e)
                for (var i = e - t.length; i;) t = "0" + t, i--;
            return t
        }

        function o(t, e) {
            return t.substr(0, e) + 1 + t.substr(e + 1)
        }

        function a(t, e) {
            var i = t.get(h.USAGE_PARAM),
                a = r(n(i), d);
            a = o(a, d - e), t.set(h.USAGE_PARAM, s(a))
        }

        function l(t) {
            t.set(h.VERSION_PARAM, h.VERSION)
        }
        var h = t("./constants"),
            c = {
                CLEAN_URL_TRACKER: 1,
                EVENT_TRACKER: 2,
                IMPRESSION_TRACKER: 3,
                MEDIA_QUERY_TRACKER: 4,
                OUTBOUND_FORM_TRACKER: 5,
                OUTBOUND_LINK_TRACKER: 6,
                PAGE_VISIBILITY_TRACKER: 7,
                SOCIAL_WIDGET_TRACKER: 8,
                URL_CHANGE_TRACKER: 9
            },
            d = 9;
        e.exports = {
            track: function(t, e) {
                l(t), a(t, e)
            },
            plugins: c
        }
    }, {
        "./constants": 1
    }],
    14: [function(t, e, i) {
        var n = t("object-assign"),
            s = t("dom-utils/lib/get-attributes"),
            r = {
                createFieldsObj: function(t, e, i, s, r) {
                    if ("function" == typeof s) {
                        var o = i.get("buildHitTask");
                        return {
                            buildHitTask: function(i) {
                                i.set(t, null, !0), i.set(e, null, !0), s(i, r), o(i)
                            }
                        }
                    }
                    return n({}, t, e)
                },
                getAttributeFields: function(t, e) {
                    var i = s(t),
                        n = {};
                    return Object.keys(i).forEach(function(t) {
                        if (0 === t.indexOf(e) && t != e + "on") {
                            var s = i[t];
                            "true" == s && (s = !0), "false" == s && (s = !1);
                            var o = r.camelCase(t.slice(e.length));
                            n[o] = s
                        }
                    }), n
                },
                domReady: function(t) {
                    "loading" == document.readyState ? document.addEventListener("DOMContentLoaded", function e() {
                        document.removeEventListener("DOMContentLoaded", e), t()
                    }) : t()
                },
                withTimeout: function(t, e) {
                    var i = !1,
                        n = function() {
                            i || (i = !0, t())
                        };
                    return setTimeout(n, e || 2e3), n
                },
                camelCase: function(t) {
                    return t.replace(/[\-\_]+(\w?)/g, function(t, e) {
                        return e.toUpperCase()
                    })
                },
                capitalize: function(t) {
                    return t.charAt(0).toUpperCase() + t.slice(1)
                },
                isObject: function(t) {
                    return "object" == typeof t && null !== t
                },
                isArray: Array.isArray || function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                },
                toArray: function(t) {
                    return r.isArray(t) ? t : [t]
                }
            };
        e.exports = r
    }, {
        "dom-utils/lib/get-attributes": 19,
        "object-assign": 23
    }],
    15: [function(t, e, i) {
        function n() {
            return (new Date).getTime()
        }
        e.exports = Date.now || n
    }, {}],
    16: [function(t, e, i) {
        var n = t("date-now");
        e.exports = function(t, e, i) {
            function s() {
                var c = n() - l;
                c < e && c > 0 ? r = setTimeout(s, e - c) : (r = null, i || (h = t.apply(a, o), r || (a = o = null)))
            }
            var r, o, a, l, h;
            return null == e && (e = 100),
                function() {
                    a = this, o = arguments, l = n();
                    var c = i && !r;
                    return r || (r = setTimeout(s, e)), c && (h = t.apply(a, o), a = o = null), h
                }
        }
    }, {
        "date-now": 15
    }],
    17: [function(t, e, i) {
        var n = t("./matches"),
            s = t("./parents");
        e.exports = function(t, e, i) {
            if (t && 1 == t.nodeType && e)
                for (var r, o = (i ? [t] : []).concat(s(t)), a = 0; r = o[a]; a++)
                    if (n(r, e)) return r
        }
    }, {
        "./matches": 20,
        "./parents": 21
    }],
    18: [function(t, e, i) {
        var n = t("./closest"),
            s = t("./matches");
        e.exports = function(t, e, i, r, o) {
            o = o || {};
            var a = function(t) {
                if (o.composed && "function" == typeof t.composedPath)
                    for (var e, a = t.composedPath(), l = 0; e = a[l]; l++) 1 == e.nodeType && s(e, i) && (h = e);
                else var h = n(t.target, i, !0);
                h && r.call(h, t, h)
            };
            return t.addEventListener(e, a, o.useCapture), {
                destroy: function() {
                    t.removeEventListener(e, a, o.useCapture)
                }
            }
        }
    }, {
        "./closest": 17,
        "./matches": 20
    }],
    19: [function(t, e, i) {
        e.exports = function(t) {
            var e = {};
            if (!t || 1 != t.nodeType) return e;
            var i = t.attributes;
            if (0 === i.length) return {};
            for (var n, s = 0; n = i[s]; s++) e[n.name] = n.value;
            return e
        }
    }, {}],
    20: [function(t, e, i) {
        function n(t, e) {
            if ("string" != typeof e) return !1;
            if (r) return r.call(t, e);
            for (var i, n = t.parentNode.querySelectorAll(e), s = 0; i = n[s]; s++)
                if (i == t) return !0;
            return !1
        }
        var s = window.Element.prototype,
            r = s.matches || s.matchesSelector || s.webkitMatchesSelector || s.mozMatchesSelector || s.msMatchesSelector || s.oMatchesSelector;
        e.exports = function(t, e) {
            if (t && 1 == t.nodeType && e) {
                if ("string" == typeof e || 1 == e.nodeType) return t == e || n(t, e);
                if ("length" in e)
                    for (var i, s = 0; i = e[s]; s++)
                        if (t == i || n(t, i)) return !0
            }
            return !1
        }
    }, {}],
    21: [function(t, e, i) {
        e.exports = function(t) {
            for (var e = []; t && t.parentNode && 1 == t.parentNode.nodeType;) e.push(t = t.parentNode);
            return e
        }
    }, {}],
    22: [function(t, e, i) {
        var n = "80",
            s = "443",
            r = RegExp(":(" + n + "|" + s + ")$"),
            o = document.createElement("a"),
            a = {};
        e.exports = function t(e) {
            if (e = e && "." != e ? e : location.href, a[e]) return a[e];
            if (o.href = e, "." == e.charAt(0)) return t(o.href);
            var i = o.protocol && ":" != o.protocol ? o.protocol : location.protocol,
                l = o.port == n || o.port == s ? "" : o.port;
            l = "0" == l ? "" : l;
            var h = "" == o.host ? location.host : o.host,
                c = "" == o.hostname ? location.hostname : o.hostname;
            h = h.replace(r, "");
            var d = o.origin ? o.origin : i + "//" + h,
                u = "/" == o.pathname.charAt(0) ? o.pathname : "/" + o.pathname;
            return a[e] = {
                hash: o.hash,
                host: h,
                hostname: c,
                href: o.href,
                origin: d,
                pathname: u,
                port: l,
                protocol: i,
                search: o.search,
                fragment: o.hash.slice(1),
                path: u + o.search,
                query: o.search.slice(1)
            }
        }
    }, {}],
    23: [function(t, e, i) {
        "use strict";

        function n(t) {
            if (null === t || void 0 === t) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(t)
        }

        function s() {
            try {
                if (!Object.assign) return !1;
                var t = new String("abc");
                if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                for (var e = {}, i = 0; i < 10; i++) e["_" + String.fromCharCode(i)] = i;
                var n = Object.getOwnPropertyNames(e).map(function(t) {
                    return e[t]
                });
                if ("0123456789" !== n.join("")) return !1;
                var s = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(t) {
                    s[t] = t
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, s)).join("")
            } catch (t) {
                return !1
            }
        }
        var r = Object.prototype.hasOwnProperty,
            o = Object.prototype.propertyIsEnumerable;
        e.exports = s() ? Object.assign : function(t, e) {
            for (var i, s, a = n(t), l = 1; l < arguments.length; l++) {
                i = Object(arguments[l]);
                for (var h in i) r.call(i, h) && (a[h] = i[h]);
                if (Object.getOwnPropertySymbols) {
                    s = Object.getOwnPropertySymbols(i);
                    for (var c = 0; c < s.length; c++) o.call(i, s[c]) && (a[s[c]] = i[s[c]])
                }
            }
            return a
        }
    }, {}],
    24: [function(t, e, i) {
        t("./plugins/clean-url-tracker"), t("./plugins/event-tracker"), t("./plugins/impression-tracker"), t("./plugins/media-query-tracker"), t("./plugins/outbound-form-tracker"), t("./plugins/outbound-link-tracker"), t("./plugins/page-visibility-tracker"), t("./plugins/social-widget-tracker"), t("./plugins/url-change-tracker"), t("./plugins/autotrack")
    }, {
        "./plugins/autotrack": 2,
        "./plugins/clean-url-tracker": 3,
        "./plugins/event-tracker": 4,
        "./plugins/impression-tracker": 5,
        "./plugins/media-query-tracker": 6,
        "./plugins/outbound-form-tracker": 7,
        "./plugins/outbound-link-tracker": 8,
        "./plugins/page-visibility-tracker": 9,
        "./plugins/social-widget-tracker": 10,
        "./plugins/url-change-tracker": 11
    }]
}, {}, [24]);
yii.validation = (function($) {
    var pub = {
        isEmpty: function(value) {
            return value === null || value === undefined || value == [] || value === '';
        },
        addMessage: function(messages, message, value) {
            messages.push(message.replace(/\{value\}/g, value));
        },
        required: function(value, messages, options) {
            var valid = false;
            if (options.requiredValue === undefined) {
                var isString = typeof value == 'string' || value instanceof String;
                if (options.strict && value !== undefined || !options.strict && !pub.isEmpty(isString ? $.trim(value) : value)) {
                    valid = true;
                }
            } else if (!options.strict && value == options.requiredValue || options.strict && value === options.requiredValue) {
                valid = true;
            }
            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },
        'boolean': function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var valid = !options.strict && (value == options.trueValue || value == options.falseValue) || options.strict && (value === options.trueValue || value === options.falseValue);
            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },
        string: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            if (typeof value !== 'string') {
                pub.addMessage(messages, options.message, value);
                return;
            }
            if (options.min !== undefined && value.length < options.min) {
                pub.addMessage(messages, options.tooShort, value);
            }
            if (options.max !== undefined && value.length > options.max) {
                pub.addMessage(messages, options.tooLong, value);
            }
            if (options.is !== undefined && value.length != options.is) {
                pub.addMessage(messages, options.notEqual, value);
            }
        },
        file: function(attribute, messages, options) {
            var files = getUploadedFiles(attribute, messages, options);
            $.each(files, function(i, file) {
                validateFile(file, messages, options);
            });
        },
        image: function(attribute, messages, options, deferred) {
            var files = getUploadedFiles(attribute, messages, options);
            $.each(files, function(i, file) {
                validateFile(file, messages, options);
                if (typeof FileReader === "undefined") {
                    return;
                }
                var def = $.Deferred(),
                    fr = new FileReader(),
                    img = new Image();
                img.onload = function() {
                    if (options.minWidth && this.width < options.minWidth) {
                        messages.push(options.underWidth.replace(/\{file\}/g, file.name));
                    }
                    if (options.maxWidth && this.width > options.maxWidth) {
                        messages.push(options.overWidth.replace(/\{file\}/g, file.name));
                    }
                    if (options.minHeight && this.height < options.minHeight) {
                        messages.push(options.underHeight.replace(/\{file\}/g, file.name));
                    }
                    if (options.maxHeight && this.height > options.maxHeight) {
                        messages.push(options.overHeight.replace(/\{file\}/g, file.name));
                    }
                    def.resolve();
                };
                img.onerror = function() {
                    messages.push(options.notImage.replace(/\{file\}/g, file.name));
                    def.resolve();
                };
                fr.onload = function() {
                    img.src = fr.result;
                };
                fr.onerror = function() {
                    def.resolve();
                };
                fr.readAsDataURL(file);
                deferred.push(def);
            });
        },
        number: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            if (typeof value === 'string' && !value.match(options.pattern)) {
                pub.addMessage(messages, options.message, value);
                return;
            }
            if (options.min !== undefined && value < options.min) {
                pub.addMessage(messages, options.tooSmall, value);
            }
            if (options.max !== undefined && value > options.max) {
                pub.addMessage(messages, options.tooBig, value);
            }
        },
        range: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            if (!options.allowArray && $.isArray(value)) {
                pub.addMessage(messages, options.message, value);
                return;
            }
            var inArray = true;
            $.each($.isArray(value) ? value : [value], function(i, v) {
                if ($.inArray(v, options.range) == -1) {
                    inArray = false;
                    return false;
                } else {
                    return true;
                }
            });
            if (options.not === inArray) {
                pub.addMessage(messages, options.message, value);
            }
        },
        regularExpression: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            if (!options.not && !value.match(options.pattern) || options.not && value.match(options.pattern)) {
                pub.addMessage(messages, options.message, value);
            }
        },
        email: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var valid = true;
            var regexp = /^((?:"?([^"]*)"?\s)?)(?:\s+)?(?:(<?)((.+)@([^>]+))(>?))$/,
                matches = regexp.exec(value);
            if (matches === null) {
                valid = false
            } else {
                if (options.enableIDN) {
                    matches[5] = punycode.toASCII(matches[5]);
                    matches[6] = punycode.toASCII(matches[6]);
                    value = matches[1] + matches[3] + matches[5] + '@' + matches[6] + matches[7];
                }
                if (matches[5].length > 64) {
                    valid = false;
                } else if ((matches[5] + '@' + matches[6]).length > 254) {
                    valid = false;
                } else {
                    valid = value.match(options.pattern) || (options.allowName && value.match(options.fullPattern));
                }
            }
            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },
        url: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            if (options.defaultScheme && !value.match(/:\/\//)) {
                value = options.defaultScheme + '://' + value;
            }
            var valid = true;
            if (options.enableIDN) {
                var regexp = /^([^:]+):\/\/([^\/]+)(.*)$/,
                    matches = regexp.exec(value);
                if (matches === null) {
                    valid = false;
                } else {
                    value = matches[1] + '://' + punycode.toASCII(matches[2]) + matches[3];
                }
            }
            if (!valid || !value.match(options.pattern)) {
                pub.addMessage(messages, options.message, value);
            }
        },
        trim: function($form, attribute, options) {
            var $input = $form.find(attribute.input);
            var value = $input.val();
            if (!options.skipOnEmpty || !pub.isEmpty(value)) {
                value = $.trim(value);
                $input.val(value);
            }
            return value;
        },
        captcha: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var hash = $('body').data(options.hashKey);
            if (hash == null) {
                hash = options.hash;
            } else {
                hash = hash[options.caseSensitive ? 0 : 1];
            }
            var v = options.caseSensitive ? value : value.toLowerCase();
            for (var i = v.length - 1, h = 0; i >= 0; --i) {
                h += v.charCodeAt(i);
            }
            if (h != hash) {
                pub.addMessage(messages, options.message, value);
            }
        },
        compare: function(value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var compareValue, valid = true;
            if (options.compareAttribute === undefined) {
                compareValue = options.compareValue;
            } else {
                compareValue = $('#' + options.compareAttribute).val();
            }
            if (options.type === 'number') {
                value = parseFloat(value);
                compareValue = parseFloat(compareValue);
            }
            switch (options.operator) {
                case '==':
                    valid = value == compareValue;
                    break;
                case '===':
                    valid = value === compareValue;
                    break;
                case '!=':
                    valid = value != compareValue;
                    break;
                case '!==':
                    valid = value !== compareValue;
                    break;
                case '>':
                    valid = value > compareValue;
                    break;
                case '>=':
                    valid = value >= compareValue;
                    break;
                case '<':
                    valid = value < compareValue;
                    break;
                case '<=':
                    valid = value <= compareValue;
                    break;
                default:
                    valid = false;
                    break;
            }
            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },
        ip: function(value, messages, options) {
            var getIpVersion = function(value) {
                return value.indexOf(':') === -1 ? 4 : 6;
            };
            var negation = null,
                cidr = null;
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var matches = new RegExp(options.ipParsePattern).exec(value);
            if (matches) {
                negation = matches[1] || null;
                value = matches[2];
                cidr = matches[4] || null;
            }
            if (options.subnet === true && cidr === null) {
                pub.addMessage(messages, options.messages.noSubnet, value);
                return;
            }
            if (options.subnet === false && cidr !== null) {
                pub.addMessage(messages, options.messages.hasSubnet, value);
                return;
            }
            if (options.negation === false && negation !== null) {
                pub.addMessage(messages, options.messages.message, value);
                return;
            }
            if (getIpVersion(value) == 6) {
                if (!options.ipv6) {
                    pub.addMessage(messages, options.messages.ipv6NotAllowed, value);
                }
                if (!(new RegExp(options.ipv6Pattern)).test(value)) {
                    pub.addMessage(messages, options.messages.message, value);
                }
            } else {
                if (!options.ipv4) {
                    pub.addMessage(messages, options.messages.ipv4NotAllowed, value);
                }
                if (!(new RegExp(options.ipv4Pattern)).test(value)) {
                    pub.addMessage(messages, options.messages.message, value);
                }
            }
        }
    };

    function getUploadedFiles(attribute, messages, options) {
        if (typeof File === "undefined") {
            return [];
        }
        var files = $(attribute.input, attribute.$form).get(0).files;
        if (!files) {
            messages.push(options.message);
            return [];
        }
        if (files.length === 0) {
            if (!options.skipOnEmpty) {
                messages.push(options.uploadRequired);
            }
            return [];
        }
        if (options.maxFiles && options.maxFiles < files.length) {
            messages.push(options.tooMany);
            return [];
        }
        return files;
    }

    function validateFile(file, messages, options) {
        if (options.extensions && options.extensions.length > 0) {
            var index, ext;
            index = file.name.lastIndexOf('.');
            if (!~index) {
                ext = '';
            } else {
                ext = file.name.substr(index + 1, file.name.length).toLowerCase();
            }
            if (!~options.extensions.indexOf(ext)) {
                messages.push(options.wrongExtension.replace(/\{file\}/g, file.name));
            }
        }
        if (options.mimeTypes && options.mimeTypes.length > 0) {
            if (!validateMimeType(options.mimeTypes, file.type)) {
                messages.push(options.wrongMimeType.replace(/\{file\}/g, file.name));
            }
        }
        if (options.maxSize && options.maxSize < file.size) {
            messages.push(options.tooBig.replace(/\{file\}/g, file.name));
        }
        if (options.minSize && options.minSize > file.size) {
            messages.push(options.tooSmall.replace(/\{file\}/g, file.name));
        }
    }

    function validateMimeType(mimeTypes, fileType) {
        for (var i = 0, len = mimeTypes.length; i < len; i++) {
            if (new RegExp(mimeTypes[i]).test(fileType)) {
                return true;
            }
        }
        return false;
    }
    return pub;
})(jQuery);;
(function($) {
    $.fn.yiiActiveForm = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.yiiActiveForm');
            return false;
        }
    };
    var events = {
        beforeValidate: 'beforeValidate',
        afterValidate: 'afterValidate',
        beforeValidateAttribute: 'beforeValidateAttribute',
        afterValidateAttribute: 'afterValidateAttribute',
        beforeSubmit: 'beforeSubmit',
        ajaxBeforeSend: 'ajaxBeforeSend',
        ajaxComplete: 'ajaxComplete',
        afterInit: 'afterInit'
    };
    var defaults = {
        encodeErrorSummary: true,
        errorSummary: '.error-summary',
        validateOnSubmit: true,
        errorCssClass: 'has-error',
        successCssClass: 'has-success',
        validatingCssClass: 'validating',
        ajaxParam: 'ajax',
        ajaxDataType: 'json',
        validationUrl: undefined,
        scrollToError: true
    };
    var attributeDefaults = {
        id: undefined,
        name: undefined,
        container: undefined,
        input: undefined,
        error: '.help-block',
        encodeError: true,
        validateOnChange: true,
        validateOnBlur: true,
        validateOnType: false,
        validationDelay: 500,
        enableAjaxValidation: false,
        validate: undefined,
        status: 0,
        cancelled: false,
        value: undefined
    };
    var submitDefer;
    var setSubmitFinalizeDefer = function($form) {
        submitDefer = $.Deferred();
        $form.data('yiiSubmitFinalizePromise', submitDefer.promise());
    };
    var submitFinalize = function($form) {
        if (submitDefer) {
            submitDefer.resolve();
            submitDefer = undefined;
            $form.removeData('yiiSubmitFinalizePromise');
        }
    };
    var methods = {
        init: function(attributes, options) {
            return this.each(function() {
                var $form = $(this);
                if ($form.data('yiiActiveForm')) {
                    return;
                }
                var settings = $.extend({}, defaults, options || {});
                if (settings.validationUrl === undefined) {
                    settings.validationUrl = $form.attr('action');
                }
                $.each(attributes, function(i) {
                    attributes[i] = $.extend({
                        value: getValue($form, this)
                    }, attributeDefaults, this);
                    watchAttribute($form, attributes[i]);
                });
                $form.data('yiiActiveForm', {
                    settings: settings,
                    attributes: attributes,
                    submitting: false,
                    validated: false,
                    options: getFormOptions($form)
                });
                $form.bind('reset.yiiActiveForm', methods.resetForm);
                if (settings.validateOnSubmit) {
                    $form.on('mouseup.yiiActiveForm keyup.yiiActiveForm', ':submit', function() {
                        $form.data('yiiActiveForm').submitObject = $(this);
                    });
                    $form.on('submit.yiiActiveForm', methods.submitForm);
                }
                var event = $.Event(events.afterInit);
                $form.trigger(event);
            });
        },
        add: function(attribute) {
            var $form = $(this);
            attribute = $.extend({
                value: getValue($form, attribute)
            }, attributeDefaults, attribute);
            $form.data('yiiActiveForm').attributes.push(attribute);
            watchAttribute($form, attribute);
        },
        remove: function(id) {
            var $form = $(this),
                attributes = $form.data('yiiActiveForm').attributes,
                index = -1,
                attribute = undefined;
            $.each(attributes, function(i) {
                if (attributes[i]['id'] == id) {
                    index = i;
                    attribute = attributes[i];
                    return false;
                }
            });
            if (index >= 0) {
                attributes.splice(index, 1);
                unwatchAttribute($form, attribute);
            }
            return attribute;
        },
        validateAttribute: function(id) {
            var attribute = methods.find.call(this, id);
            if (attribute != undefined) {
                validateAttribute($(this), attribute, true);
            }
        },
        find: function(id) {
            var attributes = $(this).data('yiiActiveForm').attributes,
                result = undefined;
            $.each(attributes, function(i) {
                if (attributes[i]['id'] == id) {
                    result = attributes[i];
                    return false;
                }
            });
            return result;
        },
        destroy: function() {
            return this.each(function() {
                $(this).unbind('.yiiActiveForm');
                $(this).removeData('yiiActiveForm');
            });
        },
        data: function() {
            return this.data('yiiActiveForm');
        },
        validate: function(forceValidate) {
            if (forceValidate) {
                $(this).data('yiiActiveForm').submitting = true;
            }
            var $form = $(this),
                data = $form.data('yiiActiveForm'),
                needAjaxValidation = false,
                messages = {},
                deferreds = deferredArray(),
                submitting = data.submitting;
            if (submitting) {
                var event = $.Event(events.beforeValidate);
                $form.trigger(event, [messages, deferreds]);
                if (event.result === false) {
                    data.submitting = false;
                    submitFinalize($form);
                    return;
                }
            }
            $.each(data.attributes, function() {
                this.$form = $form;
                if (!$(this.input).is(":disabled")) {
                    this.cancelled = false;
                    if (data.submitting || this.status === 2 || this.status === 3) {
                        var msg = messages[this.id];
                        if (msg === undefined) {
                            msg = [];
                            messages[this.id] = msg;
                        }
                        var event = $.Event(events.beforeValidateAttribute);
                        $form.trigger(event, [this, msg, deferreds]);
                        if (event.result !== false) {
                            if (this.validate) {
                                this.validate(this, getValue($form, this), msg, deferreds, $form);
                            }
                            if (this.enableAjaxValidation) {
                                needAjaxValidation = true;
                            }
                        } else {
                            this.cancelled = true;
                        }
                    }
                }
            });
            $.when.apply(this, deferreds).always(function() {
                for (var i in messages) {
                    if (0 === messages[i].length) {
                        delete messages[i];
                    }
                }
                if ($.isEmptyObject(messages) && needAjaxValidation) {
                    var $button = data.submitObject,
                        extData = '&' + data.settings.ajaxParam + '=' + $form.attr('id');
                    if ($button && $button.length && $button.attr('name')) {
                        extData += '&' + $button.attr('name') + '=' + $button.attr('value');
                    }
                    $.ajax({
                        url: data.settings.validationUrl,
                        type: $form.attr('method'),
                        data: $form.serialize() + extData,
                        dataType: data.settings.ajaxDataType,
                        complete: function(jqXHR, textStatus) {
                            $form.trigger(events.ajaxComplete, [jqXHR, textStatus]);
                        },
                        beforeSend: function(jqXHR, settings) {
                            $form.trigger(events.ajaxBeforeSend, [jqXHR, settings]);
                        },
                        success: function(msgs) {
                            if (msgs !== null && typeof msgs === 'object') {
                                $.each(data.attributes, function() {
                                    if (!this.enableAjaxValidation || this.cancelled) {
                                        delete msgs[this.id];
                                    }
                                });
                                updateInputs($form, $.extend(messages, msgs), submitting);
                            } else {
                                updateInputs($form, messages, submitting);
                            }
                        },
                        error: function() {
                            data.submitting = false;
                            submitFinalize($form);
                        }
                    });
                } else if (data.submitting) {
                    setTimeout(function() {
                        updateInputs($form, messages, submitting);
                    }, 200);
                } else {
                    updateInputs($form, messages, submitting);
                }
            });
        },
        submitForm: function() {
            var $form = $(this),
                data = $form.data('yiiActiveForm');
            if (data.validated) {
                data.submitting = false;
                var event = $.Event(events.beforeSubmit);
                $form.trigger(event);
                if (event.result === false) {
                    data.validated = false;
                    submitFinalize($form);
                    return false;
                }
                updateHiddenButton($form);
                return true;
            } else {
                setSubmitFinalizeDefer($form);
                if (data.settings.timer !== undefined) {
                    clearTimeout(data.settings.timer);
                }
                data.submitting = true;
                methods.validate.call($form);
                return false;
            }
        },
        resetForm: function() {
            var $form = $(this);
            var data = $form.data('yiiActiveForm');
            setTimeout(function() {
                $.each(data.attributes, function() {
                    this.value = getValue($form, this);
                    this.status = 0;
                    var $container = $form.find(this.container);
                    $container.removeClass(data.settings.validatingCssClass + ' ' +
                        data.settings.errorCssClass + ' ' +
                        data.settings.successCssClass);
                    $container.find(this.error).html('');
                });
                $form.find(data.settings.errorSummary).hide().find('ul').html('');
            }, 1);
        },
        updateMessages: function(messages, summary) {
            var $form = $(this);
            var data = $form.data('yiiActiveForm');
            $.each(data.attributes, function() {
                updateInput($form, this, messages);
            });
            if (summary) {
                updateSummary($form, messages);
            }
        },
        updateAttribute: function(id, messages) {
            var attribute = methods.find.call(this, id);
            if (attribute != undefined) {
                var msg = {};
                msg[id] = messages;
                updateInput($(this), attribute, msg);
            }
        }
    };
    var watchAttribute = function($form, attribute) {
        var $input = findInput($form, attribute);
        if (attribute.validateOnChange) {
            $input.on('change.yiiActiveForm', function() {
                validateAttribute($form, attribute, false);
            });
        }
        if (attribute.validateOnBlur) {
            $input.on('blur.yiiActiveForm', function() {
                if (attribute.status == 0 || attribute.status == 1) {
                    validateAttribute($form, attribute, true);
                }
            });
        }
        if (attribute.validateOnType) {
            $input.on('keyup.yiiActiveForm', function(e) {
                if ($.inArray(e.which, [16, 17, 18, 37, 38, 39, 40]) !== -1) {
                    return;
                }
                if (attribute.value !== getValue($form, attribute)) {
                    validateAttribute($form, attribute, false, attribute.validationDelay);
                }
            });
        }
    };
    var unwatchAttribute = function($form, attribute) {
        findInput($form, attribute).off('.yiiActiveForm');
    };
    var validateAttribute = function($form, attribute, forceValidate, validationDelay) {
        var data = $form.data('yiiActiveForm');
        if (forceValidate) {
            attribute.status = 2;
        }
        $.each(data.attributes, function() {
            if (this.value !== getValue($form, this)) {
                this.status = 2;
                forceValidate = true;
            }
        });
        if (!forceValidate) {
            return;
        }
        if (data.settings.timer !== undefined) {
            clearTimeout(data.settings.timer);
        }
        data.settings.timer = setTimeout(function() {
            if (data.submitting || $form.is(':hidden')) {
                return;
            }
            $.each(data.attributes, function() {
                if (this.status === 2) {
                    this.status = 3;
                    $form.find(this.container).addClass(data.settings.validatingCssClass);
                }
            });
            methods.validate.call($form);
        }, validationDelay ? validationDelay : 200);
    };
    var deferredArray = function() {
        var array = [];
        array.add = function(callback) {
            this.push(new $.Deferred(callback));
        };
        return array;
    };
    var buttonOptions = ['action', 'target', 'method', 'enctype'];
    var getFormOptions = function($form) {
        var attributes = {};
        for (var i = 0; i < buttonOptions.length; i++) {
            attributes[buttonOptions[i]] = $form.attr(buttonOptions[i]);
        }
        return attributes;
    };
    var applyButtonOptions = function($form, $button) {
        for (var i = 0; i < buttonOptions.length; i++) {
            var value = $button.attr('form' + buttonOptions[i]);
            if (value) {
                $form.attr(buttonOptions[i], value);
            }
        }
    };
    var restoreButtonOptions = function($form) {
        var data = $form.data('yiiActiveForm');
        for (var i = 0; i < buttonOptions.length; i++) {
            $form.attr(buttonOptions[i], data.options[buttonOptions[i]] || null);
        }
    };
    var updateInputs = function($form, messages, submitting) {
        var data = $form.data('yiiActiveForm');
        if (data === undefined) {
            return false;
        }
        if (submitting) {
            var errorAttributes = [];
            $.each(data.attributes, function() {
                if (!$(this.input).is(":disabled") && !this.cancelled && updateInput($form, this, messages)) {
                    errorAttributes.push(this);
                }
            });
            $form.trigger(events.afterValidate, [messages, errorAttributes]);
            updateSummary($form, messages);
            if (errorAttributes.length) {
                if (data.settings.scrollToError) {
                    var top = $form.find($.map(errorAttributes, function(attribute) {
                        return attribute.input;
                    }).join(',')).first().closest(':visible').offset().top;
                    var wtop = $(window).scrollTop();
                    if (top < wtop || top > wtop + $(window).height()) {
                        $(window).scrollTop(top);
                    }
                }
                data.submitting = false;
            } else {
                data.validated = true;
                if (data.submitObject) {
                    data.submitObject.trigger("click");
                } else {
                    $form.submit();
                }
            }
        } else {
            $.each(data.attributes, function() {
                if (!this.cancelled && (this.status === 2 || this.status === 3)) {
                    updateInput($form, this, messages);
                }
            });
        }
        submitFinalize($form);
    };
    var updateHiddenButton = function($form) {
        var data = $form.data('yiiActiveForm');
        var $button = data.submitObject || $form.find(':submit:first');
        if ($button.length && $button.attr('type') == 'submit' && $button.attr('name')) {
            var $hiddenButton = $('input[type="hidden"][name="' + $button.attr('name') + '"]', $form);
            if (!$hiddenButton.length) {
                $('<input>').attr({
                    type: 'hidden',
                    name: $button.attr('name'),
                    value: $button.attr('value')
                }).appendTo($form);
            } else {
                $hiddenButton.attr('value', $button.attr('value'));
            }
        }
    };
    var updateInput = function($form, attribute, messages) {
        var data = $form.data('yiiActiveForm'),
            $input = findInput($form, attribute),
            hasError = false;
        if (!$.isArray(messages[attribute.id])) {
            messages[attribute.id] = [];
        }
        $form.trigger(events.afterValidateAttribute, [attribute, messages[attribute.id]]);
        attribute.status = 1;
        if ($input.length) {
            hasError = messages[attribute.id].length > 0;
            var $container = $form.find(attribute.container);
            var $error = $container.find(attribute.error);
            if (hasError) {
                if (attribute.encodeError) {
                    $error.text(messages[attribute.id][0]);
                } else {
                    $error.html(messages[attribute.id][0]);
                }
                $container.removeClass(data.settings.validatingCssClass + ' ' + data.settings.successCssClass).addClass(data.settings.errorCssClass);
            } else {
                $error.empty();
                $container.removeClass(data.settings.validatingCssClass + ' ' + data.settings.errorCssClass + ' ').addClass(data.settings.successCssClass);
            }
            attribute.value = getValue($form, attribute);
        }
        return hasError;
    };
    var updateSummary = function($form, messages) {
        var data = $form.data('yiiActiveForm'),
            $summary = $form.find(data.settings.errorSummary),
            $ul = $summary.find('ul').empty();
        if ($summary.length && messages) {
            $.each(data.attributes, function() {
                if ($.isArray(messages[this.id]) && messages[this.id].length) {
                    var error = $('<li/>');
                    if (data.settings.encodeErrorSummary) {
                        error.text(messages[this.id][0]);
                    } else {
                        error.html(messages[this.id][0]);
                    }
                    $ul.append(error);
                }
            });
            $summary.toggle($ul.find('li').length > 0);
        }
    };
    var getValue = function($form, attribute) {
        var $input = findInput($form, attribute);
        var type = $input.attr('type');
        if (type === 'checkbox' || type === 'radio') {
            var $realInput = $input.filter(':checked');
            if (!$realInput.length) {
                $realInput = $form.find('input[type=hidden][name="' + $input.attr('name') + '"]');
            }
            return $realInput.val();
        } else {
            return $input.val();
        }
    };
    var findInput = function($form, attribute) {
        var $input = $form.find(attribute.input);
        if ($input.length && $input[0].tagName.toLowerCase() === 'div') {
            return $input.find('input');
        } else {
            return $input;
        }
    };
})(window.jQuery);;